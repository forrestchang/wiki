<!DOCTYPE html>
<html>

<head>
    <title>
         Wiki 
    </title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="asset/yue.css">
    <link rel="stylesheet" type="text/css" href="asset/main.css">
    <link rel="stylesheet" type="text/css" href="asset/tomorrow.css">

    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Wiki">

    <script src="asset/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="yue site-header">
        <div class="wrapper">
            <a class="site-title" href="index.html">Wiki</a>
            <nav class="site-nav">
                <a href="#" class="menu-icon">
                    
                    <svg viewBox="0 0 18 15">
                        <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"
                        />
                        <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"
                        />
                        <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"
                        />
                    </svg>

                </a>
                <div class="trigger">
                    
                        <a class="page-link" href="index.html">INDEX</a>
                    
                        <a class="page-link" href="archives.html">ARCHIVES</a>
                    
                </div>
            </nav>
        </div>
    </header>
</body>

</html> <div class="page-content yue">
    <div class="wrapper">
        <div class="home">
            <div class="divider">
                <p></p>
            </div>
            <ul class="entry-list">
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/3/6">2017/3/6</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14887608416607.html">算法</a></h2>
                        <div itemprop="description">
                            
                                <ul>
<li>
<a href="#toc_0">1.3 背包、队列和栈</a>
<ul>
<li>
<a href="#toc_1">1.3.1 API</a>
<ul>
<li>
<a href="#toc_2">1.3.1.1 泛型</a>
</li>
<li>
<a href="#toc_3">1.3.1.2 自动装箱</a>
</li>
<li>
<a href="#toc_4">1.3.1.3 可迭代的几何类型</a>
</li>
<li>
<a href="#toc_5">1.3.1.4 背包</a>
</li>
<li>
<a href="#toc_6">1.3.1.5 先进先出队列</a>
</li>
<li>
<a href="#toc_7">1.3.1.6 下压栈</a>
</li>
<li>
<a href="#toc_8">1.3.1.7 算数表达式求值</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">1.3.2 集合数据类型的实现</a>
<ul>
<li>
<a href="#toc_10">1.3.2.1 定容栈</a>
</li>
<li>
<a href="#toc_11">1.3.2.2 泛型</a>
</li>
<li>
<a href="#toc_12">1.3.2.3 调整数组的大小</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1.3 背包、队列和栈</h2>

<p>研究方法：1）学习其 API 和用例；2）讨论数据类型的值和所有可能的表示方法；3）各种操作的实现。</p>

<h3 id="toc_1">1.3.1 API</h3>

<p>每份 API 都含有一个无参数的构造函数、一个向集合中添加单个元素的方法、一个测试集合是否为空的方法和一个返回集合大小的方法。Stack 和 Queue 都含有一个能够删除集合中的特定元素的方法。</p>

<p>背包：</p>

<table>
<thead>
<tr>
<th></th>
<th>Bag()</th>
<th>创建一个空背包</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>add(item)</td>
<td>添加一个空元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>背包是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>背包中元素的数量</td>
</tr>
</tbody>
</table>

<p>先进先出（FIFO）队列:</p>

<table>
<thead>
<tr>
<th></th>
<th>Queue()</th>
<th>创建空队列</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>enqueue(item)</td>
<td>添加一个元素</td>
</tr>
<tr>
<td>Item</td>
<td>dequeue()</td>
<td>删除最早添加的元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>队列是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>队列中元素数量</td>
</tr>
</tbody>
</table>

<p>下压（后进先出，LIFO）栈：</p>

<table>
<thead>
<tr>
<th></th>
<th>Stack()</th>
<th>创建一个空栈</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>push(item)</td>
<td>添加一个元素</td>
</tr>
<tr>
<td>Item</td>
<td>pop()</td>
<td>删除最近添加的元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>栈是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>栈中的元素数量</td>
</tr>
</tbody>
</table>

<h4 id="toc_2">1.3.1.1 泛型</h4>

<p>因为这里使用的 Python 语言来实现书中的代码，所以不存在泛型的问题，Python 是鸭子类型。</p>

<h4 id="toc_3">1.3.1.2 自动装箱</h4>

<p>自动讲一个原始数据类型转换为一个封装类型被称为自动装箱，自动将一个封装类型转换为原始数据类型被称为自动拆箱。</p>

<h4 id="toc_4">1.3.1.3 可迭代的几何类型</h4>

<p>对应 Python 中的 Iterable 类型。</p>

<h4 id="toc_5">1.3.1.4 背包</h4>

<p>背包是一种不支持从中删除元素的几何数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。迭代的顺序不确定且与用例无关。</p>

<h4 id="toc_6">1.3.1.5 先进先出队列</h4>

<p>先进先出队列（简称队列）是一种基于先进先出（FIFO）策略的集合类型。</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-06-011739.jpg" alt=""/></p>

<h4 id="toc_7">1.3.1.6 下压栈</h4>

<p>下压栈（简称栈）是一种基于后进先出（LIFO）策略的几何类型。典型例子：1）邮件系统；2）浏览器。</p>

<h4 id="toc_8">1.3.1.7 算数表达式求值</h4>

<p>递归定义：<em>算数表达式</em>可能是一个数、或者是一个由左括号、一个算数表达式、一个运算符、另一个算数表达式和一个右括号组成的表达式。（简单起见，这里定义的是未省略括号的算数表达式）。</p>

<p>E.W.Dijkstra 在 20 世纪 60 年代发明了一个非常简单的算法，用两个栈（一个用于保存运算符，一个用于保存操作数）完成了这个任务。</p>

<p>我们根据以下 4 种情况从左到右逐个将这些实体送入栈处理：</p>

<ol>
<li>将操作数压入操作数栈；</li>
<li>将运算符压入运算符栈；</li>
<li>忽略左括号；</li>
<li>在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。</li>
</ol>

<p>一个用栈实现的简单解释器例子：</p>

<pre><code class="language-python">def evaluate(expression):
    ops = Stack()
    vals = Stack()
    
    for s in expression:
        if s == &#39;(&#39;:
            continue
        elif s == &#39;+&#39;:
            ops.push(s)
        elif s == &#39;-&#39;:
            ops.push(s)
        elif s == &#39;*&#39;:
            ops.push(s)
        elif s == &#39;/&#39;:
            ops.push(s)
        elif s == &#39;)&#39;:
            op = ops.pop()
            v = vals.pop()
            if op == &#39;+&#39;:
                v = vals.pop() + v
            elif op == &#39;-&#39;:
                v = vals.pop() - v
            elif op == &#39;*&#39;:
                v = vals.pop() * v
            elif op == &#39;/&#39;:
                v = vals.pop() / v
            vals.push(v)
        else:
            vals.push(s)
</code></pre>

<h3 id="toc_9">1.3.2 集合数据类型的实现</h3>

<h4 id="toc_10">1.3.2.1 定容栈</h4>

<p>定容栈是一种表示容量固定的字符串栈的抽象数据类型，它的 API 和 Stack 的 API 有所不同：它只能处理 String 值，它要求用例制定一个容量且不支持迭代。实现一份 API 的第一步就是选择数据的表示方式，对于 <code>FixedCapacityStackOfStrings</code>，我们可以选用数组。</p>

<p>API:</p>

<table>
<thead>
<tr>
<th></th>
<th>FixedCapacityStackOfStrings(size)</th>
<th>创建一个容量为 size 的空栈</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>push(item:str)</td>
<td>添加一个字符串</td>
</tr>
<tr>
<td>str</td>
<td>pop()</td>
<td>删除最近添加的字符串</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>栈是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>栈中字符串数量</td>
</tr>
</tbody>
</table>

<p>数据类型的实现：</p>

<pre><code class="language-python">class FixedCapacityStackOfStrings:
    def __init__(self, size):
        _a = []     # stack entries
        _size = size
        N = 0      # stack index
        

    def isEmpty(self):
        return N == 0

    def size(self):
        return N
    
    def push(self, item):
        N += 1
        _a[N] = item

    def pop(self):
        N -= 1
        return _a[N]
</code></pre>

<ul>
<li>数组中的元素顺序和它们被插入的顺序相同</li>
<li>当 N 为 0 时栈为空</li>
<li>栈的顶部位于 <code>_a[N-1]</code></li>
</ul>

<h4 id="toc_11">1.3.2.2 泛型</h4>

<p>如果上面代码是用 Java 写的话，确实只能处理 String 对象，但是 Python 是动态类型的语言，不存在泛型的问题。</p>

<h4 id="toc_12">1.3.2.3 调整数组的大小</h4>

<p>选择用数组表示栈内容意味着用例必须预先估计栈的最大容量（在 Python 中数组是动态变化的，所以不需要，这里为了模拟）。在 Java 中，数组一旦创建，其大小是无法改变的，因此栈使用的空间只能是这个最大容量的一部分。选择大容量的用例在栈为空或几乎为空时会浪费大量的内存。<code>push()</code> 方法需要在代码中检测栈是否已满，我们的 API 中也应该含有一个 <code>isFull()</code> 的方法来允许用例检测栈是否已满。我们在此省略了它实现的代码，因为我们希望用例从处理栈已满的问题中解脱出来，如我们原始的 Stack API 所示。因此，我们修改了数组的实现，动态调整数组的大小，使得它既足以保存所有元素，又不至于浪费过多的空间。</p>

                            
                        </div>
                    </div>
                </li>
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/3/4">2017/3/4</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14886163941964.html">March 2017</a></h2>
                        <div itemprop="description">
                            
                                <ul>
<li>
<a href="#toc_0">2017/03/04</a>
<ul>
<li>
<a href="#toc_1">How do I as a student start contributing to open source?</a>
</li>
<li>
<a href="#toc_2">How can a person get selected in Google Summer of Code?</a>
</li>
<li>
<a href="#toc_3">平台后端开发(Python)面试记录</a>
</li>
<li>
<a href="#toc_4">如何为你的 GitHub 开源项目写一份优秀的 README.md 文档？</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">2017/03/04</h2>

<h3 id="toc_1"><a href="https://www.quora.com/How-do-I-as-a-student-start-contributing-to-open-source">How do I as a student start contributing to open source?</a></h3>

<p>Nimit Shah:</p>

<ol>
<li>Start contributing to an open source project that you use in your day to day life</li>
<li>Select a project from Google Summer of Code or GNOME Outreach Program for Women</li>
</ol>

<h3 id="toc_2"><a href="https://www.quora.com/How-can-a-person-get-selected-in-Google-Summer-of-Code">How can a person get selected in Google Summer of Code?</a></h3>

<p>Ashwyn Sharma:</p>

<p><strong>Do not apply for GSoC if you are not an Open Source Enthusiast!</strong></p>

<p>Crucial steps involved in the process:</p>

<ol>
<li>Start with the list of accepted organisations in the past years and pick one of them.</li>
<li>Contact the organisation telling them about yourself (in most cases - that you are a software developer who is new to their products/applications/platforms etc.) and how you wish to contribute to their codebase.</li>
<li>Get yourself familiar with the codebase. A little perseverance at this stage may prove decisive of your future with both GSoC and Open Source in general. Pick up a simple bug/feature-request from the bug tracker of the given application and try to solve it. Not only this will increase your chances of acceptance dramatically, it will also help you get familiar with the developers and of course, the code itself. An important thing to remember is to make your presence felt amongst the developer community. This will help you at later stages of the application process.</li>
<li>Provided you manage to solve the bug or develop that feature, the next step will be to commit your code to the Trunk/Central Repository.</li>
<li>Next is the application period. As soon as Google announces the list of the accepted organisations, start looking for the prospective <strong>project ideas</strong>. Think over how you can go about executing these ideas. Talk to the prospective mentors about what you think of the idea and may be fetch more details about the ins and outs of project. Though Google allows you to submit your own original ideas as well, I have always believed that its better to choose from the list of the ideas provided by the organization. However, if the idea is truly meaningful and has a feasible implementation plan, there have been instances where original ideas have been accepted as well. If you haven&#39;t already, keep working on that bug and solve it, because if you haven&#39;t really proved your coding skills to the organisation yet, then  your chances of getting accepted gets even simmer, no matter how strong your application maybe.</li>
<li>Start writing the proposal as early as possible. Make sure that before submitting the proposal, you get your proposal reviewed by your mentors as much as possible. The main ingredients of a good proposal are that it should address two kinds of audiences - one which is completely familiar with the technical details of the project (that would be your mentors and organisation devs) and the second one is a neutral not-so-technical audience which is able to understand the deliverables of the project (in most cases that would be the user base). Start coding up your idea.</li>
</ol>

<h3 id="toc_3"><a href="http://blog.csdn.net/huangxiongbiao/article/details/50733303">平台后端开发(Python)面试记录</a></h3>

<ol>
<li>手写 Python 生成器（带 yield 的函数）</li>
<li>手写链表翻转</li>
<li>Tornado 框架中的异步实现原理</li>
<li>select, poll, epoll, epoll 改进了 select/poll 的什么地方</li>
<li>线程与进程的区别</li>
<li>进程间通信方式</li>
<li>数据库原理（索引，B 树）</li>
<li>TCP 四次握手过程</li>
<li>Nginx 的转发原理</li>
<li>Linux 文件系统</li>
</ol>

<h3 id="toc_4"><a href="https://www.diycode.cc/topics/498">如何为你的 GitHub 开源项目写一份优秀的 README.md 文档？</a></h3>

<ul>
<li>Project Title: one paragraph of description goes here.</li>
<li>Getting Started: These istructions will get you a copy of the project up and running on your local machine for development and testing purposes.</li>
<li>Prerequisties: what things you need to install the software and how to install them.</li>
<li>Installing: A step by step series of examples that you have to get a development env running.</li>
<li>Running the tests: Explain how to run the automated tests for this system.</li>
<li>Break down into end to end tests: explain what these tests test and why</li>
<li>And coding style tests: expalin what these tests test and why</li>
<li>Deployment: add additional notes about how to deploy this on a live system</li>
<li>Built with</li>
<li>Contributing: please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us.</li>
<li>Authors</li>
<li>License</li>
<li>Acknowledgemets</li>
</ul>

<hr/>

<p>中英文 readme 各写一份。</p>

                            
                        </div>
                    </div>
                </li>
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/2/16">2017/2/16</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14872260244406.html">Python Cookbook</a></h2>
                        <div itemprop="description">
                            
                                <h2 id="toc_0">调用父类的方法</h2>

<p><code>super()</code> 的常见用法：</p>

<ol>
<li>在 <code>__init__()</code> 方法中确保父类被正确初始化了</li>
<li>另外一个常见用法出现在覆盖 Python 特殊方法的代码中</li>
</ol>

<p>Ex:</p>

<pre><code class="language-python">class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith(&#39;_&#39;):
            super().__setattr__(name, value) # Call original __setattr__
        else:
            setattr(self._obj, name, value)
</code></pre>

<p>在上面代码中，<code>__setattr__()</code> 的实现包含一个名字检查。如果某个属性名以 <code>_</code> 开头，就通过 <code>super()</code> 调用原始的 <code>__setattr__()</code>，否则的话就委派给类内部的代理对象 <code>self._obj</code> 去处理。这看上去有点意思，因为就算没有显式指明某个类的父类，<code>super()</code> 仍然可以有效地工作。</p>

<h2 id="toc_1">子类中扩展 Property</h2>

<p>在自雷中扩展一个 property 可能会引起很多不易察觉的问题，因为一个 property 其实是 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法的几何，而不是单个的方法。因此，当你扩展一个 property 的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中的一个。</p>

<h2 id="toc_2">创建新的类或实例属性</h2>

<p>描述器：一个实现了三个核心的属性访问操作（get, set, delete）的类，分别为 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code> 这三个特殊的方法。这些方法接受一个实例作为输入，之后相应的操作实例实例底层的字典。</p>

<p>为了使用一个描述器，需要将这个描述器的实例作为类属性放到一个类的定义中。</p>

<p>一个基于描述器的高级代码：</p>

<pre><code class="language-python"># Descriptor for a type-checked attribute
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(&#39;Expected &#39; + str(self.expected_type))
        instance.__dict__[self.name] = value
    def __delete__(self, instance):
        del instance.__dict__[self.name]

# Class decorator that applies it to selected attributes
def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            # Attach a Typed descriptor to the class
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
</code></pre>

                            
                        </div>
                    </div>
                </li>
                
            </ul>
            <p class="paging">
                 
            </p>
        </div>
    </div>
</div>  <footer id="footer" class="yue">
    <div class="wrapper">
        <p>© Copyright 2014 - 2017 by <a href="https://twitter.com/Tisoga">@Tisoga</a> and powered by <a href="http://zh.mweb.im/">Mweb</a></p>
    </div>
</footer>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>
