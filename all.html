<!DOCTYPE html>
<html>

<head>
    <title>
         Wiki 
    </title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="asset/yue.css">
    <link rel="stylesheet" type="text/css" href="asset/main.css">
    <link rel="stylesheet" type="text/css" href="asset/tomorrow.css">

    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Wiki">

    <script src="asset/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="yue site-header">
        <div class="wrapper">
            <a class="site-title" href="index.html">Wiki</a>
            <nav class="site-nav">
                <a href="#" class="menu-icon">
                    
                    <svg viewBox="0 0 18 15">
                        <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"
                        />
                        <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"
                        />
                        <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"
                        />
                    </svg>

                </a>
                <div class="trigger">
                    
                        <a class="page-link" href="index.html">INDEX</a>
                    
                        <a class="page-link" href="archives.html">ARCHIVES</a>
                    
                </div>
            </nav>
        </div>
    </header>
</body>

</html> <div class="page-content yue">
    <div class="wrapper">
        <div class="home">
            <div class="divider">
                <p></p>
            </div>
            <ul class="entry-list">
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/3/10">2017/3/10</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14891114444883.html">LeetCode 刷题笔记</a></h2>
                        <div itemprop="description">
                            
                                <ul>
<li>
<a href="#toc_0">001 Two Sum [Easy]</a>
<ul>
<li>
<a href="#toc_1">题目</a>
</li>
<li>
<a href="#toc_2">时间复杂度</a>
</li>
<li>
<a href="#toc_3">思路</a>
</li>
<li>
<a href="#toc_4">代码</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">002 Add Two Numbers [Medium]</a>
<ul>
<li>
<a href="#toc_6">时间复杂度</a>
</li>
<li>
<a href="#toc_7">思路</a>
</li>
<li>
<a href="#toc_8">代码</a>
</li>
<li>
<a href="#toc_9">笔记</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">001 Two Sum [Easy]</h2>

<h3 id="toc_1">题目</h3>

<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>

<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>

<p>Example：</p>

<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>

<h3 id="toc_2">时间复杂度</h3>

<p>\(O(n)\)</p>

<h3 id="toc_3">思路</h3>

<p>比较暴力的做法就是用两个循环来穷举，这样的话时间复杂度会达到 \(O(n^2)\)。</p>

<p>另外一种思路就是使用一个 dict 来保存外循环中 target 与 num 的差值，这样在数组中只要发现这个值就可以直接返回了，而在 dic 查找的时间复杂度为 \(O(1)\)。</p>

<h3 id="toc_4">代码</h3>

<pre><code class="language-python">class Solution(object):
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        dic = {}
        for i, num in enumerate(nums):
            if num in dic:
                return [dic[num], i]
            else:
                dic[target - num] = i
</code></pre>

<h2 id="toc_5">002 Add Two Numbers [Medium]</h2>

<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p>Example:</p>

<pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
</code></pre>

<h3 id="toc_6">时间复杂度</h3>

<p>\(O(n)\)</p>

<h3 id="toc_7">思路</h3>

<p>把两个数相加存在链表里，这两个数字的每一位都存在链表中，并且链表是反转的。思路很简单，就是遍历链表，把数取出来，然后加完后再添加到链表中。</p>

<p>代码写得很直白。</p>

<h3 id="toc_8">代码</h3>

<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        num1 = []
        num2 = []
        current = l1
        while current != None:
            num1.append(str(current.val))
            current = current.next
        current = l2
        while current != None:
            num2.append(str(current.val))
            current = current.next
        num1 = &#39;&#39;.join(num1)[::-1]
        num2 = &#39;&#39;.join(num2)[::-1]
        sum = int(num1) + int(num2)
        first = ListNode(str(sum)[0])
        for i in str(sum)[1:]:
            oldfirst = first
            first = ListNode(i)
            first.next = oldfirst
        return first
</code></pre>

<h3 id="toc_9">笔记</h3>

<p>翻了一下 discuss，发现我的解法实在是太 dirty 了。</p>

<p>下面这一段代码我认为还是非常优美的实现：</p>

<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1, l2):
        def toint(node):
            return node.val + 10 * toint(node.next) if node else 0
        def tolist(n):
            node = ListNode(n % 10)
            if n &gt; 9:
                node.next = tolist(n // 10)
            return node
        return tolist(toint(l1) + toint(l2))
</code></pre>

<p>非递归版本：</p>

<pre><code class="language-python">class Solution:
    def addTwoNumbers(self, l1, l2):
        def toint(node):
            return node.val + 10 * toint(node.next) if node else 0
        n = toint(l1) + toint(l2)
        first = last = ListNode(n % 10)
        while n &gt; 9:
            n /= 10
            last.next = last = ListNode(n % 10)
        return first
</code></pre>

<p>解释一下思路。</p>

<p>首先 <code>toint(node)</code> 函数是将链表转化成 <code>int</code> 类型的数据，因为 Python 中 <code>int</code> 可以存非常大的数，所以不用考虑链表的长度。算法也很简单，因为链表是转置的，所以高位在链表后面，依次乘以 10 的 n 次方再相加就可以了。</p>

<p><code>tolist(n)</code> 函数式将计算好的数据转化成链表，再纸上拿一个一个例子画一个图就很好理解了。<code>node = ListNode(n % 10)</code> 每一次递归都创建一个节点来存放某一位的数据，<code>tolist(n // 10)</code> 每一次递归都截取一位数字。</p>

<p>非递归的方法类似。</p>

                            
                        </div>
                    </div>
                </li>
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/3/8">2017/3/8</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14889309726832.html">计算机网络</a></h2>
                        <div itemprop="description">
                            
                                <ul>
<li>
<a href="#toc_0">HTTP 协议</a>
<ul>
<li>
<a href="#toc_1">HTTP 的特性</a>
</li>
<li>
<a href="#toc_2">HTTP 报文</a>
<ul>
<li>
<a href="#toc_3">请求报文</a>
</li>
<li>
<a href="#toc_4">响应报文</a>
</li>
<li>
<a href="#toc_5">条件 GET</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">持久连接</a>
</li>
<li>
<a href="#toc_7">HTTP Pipelining（HTTP 管线化）</a>
</li>
<li>
<a href="#toc_8">会话跟踪</a>
</li>
<li>
<a href="#toc_9">跨站攻击</a>
<ul>
<li>
<a href="#toc_10">如何防范 CSRF 攻击？</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">XSS（Cross Site Scripting，跨站脚本攻击）</a>
<ul>
<li>
<a href="#toc_12">如何防御 XSS 攻击？</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_13">TCP 协议</a>
<ul>
<li>
<a href="#toc_14">TCP 协议的特性</a>
</li>
<li>
<a href="#toc_15">三次握手与四次握手</a>
</li>
<li>
<a href="#toc_16">SYN 攻击</a>
<ul>
<li>
<a href="#toc_17">什么是 SYN 攻击（SYN Flood）？</a>
</li>
<li>
<a href="#toc_18">如何检测 SYN 攻击？</a>
</li>
<li>
<a href="#toc_19">如何防御 SYN 攻击？</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_20">IP 协议</a>
<ul>
<li>
<a href="#toc_21">广播与多播</a>
<ul>
<li>
<a href="#toc_22">广播</a>
</li>
<li>
<a href="#toc_23">多播</a>
</li>
</ul>
</li>
<li>
<a href="#toc_24">BGP</a>
</li>
</ul>
</li>
<li>
<a href="#toc_25">Socket 编程</a>
</li>
</ul>


<h2 id="toc_0">HTTP 协议</h2>

<h3 id="toc_1">HTTP 的特性</h3>

<ul>
<li>HTTP 构建于 TCP/IP 协议之上</li>
<li>HTTP 是无连接状态的</li>
</ul>

<h3 id="toc_2">HTTP 报文</h3>

<h4 id="toc_3">请求报文</h4>

<p>HTTP 定义了与服务器交互的不同方法，最基本的方法有 4 种，分别是 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>. <code>URL</code> 全称是资源描述符，我们可以这样任务，一个 URL 地址，它用于描述一个网络上的资源，而 HTTP 中的 GET、POST、PUT、DELETE 就对应着对这个资源的差、改、增、删 4 个操作。</p>

<ol>
<li><p>GET 用于信息获取，而且应该是<strong>安全的</strong>和<strong>幂等的</strong></p>

<p>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用，不会影响资源的状态。</p>

<p>幂等的意味着对同一 URL 的多个请求应该返回同样的结果。</p>

<p>GET 请求报文示例：</p>

<pre><code>GET /books/?sex=man&amp;name=Professional HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
</code></pre></li>
<li><p>POST 表示可能修改服务器上的资源</p>

<pre><code>POST / HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive

sex=man&amp;name=Professional
</code></pre></li>
<li><p>注意</p>

<ul>
<li>GET 可提交的数据量受 URL 长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器对它的限制</li>
<li>理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，处于安全考虑，服务器软件在实现时会做一定限制</li>
<li>参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里</li>
</ul></li>
</ol>

<h4 id="toc_4">响应报文</h4>

<p>HTTP 响应与 HTTP 请求相似，HTTP 响应也由 3 个部分构成，分别是：</p>

<ul>
<li>状态行</li>
<li>响应头（Response Header）</li>
<li>响应正文</li>
</ul>

<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>

<p>常见的状态码有如下几种：</p>

<ul>
<li>200 OK：客户端请求成功</li>
<li>302 Moved Temporirily：请求重定向</li>
<li>304 Not Modified：文件未修改，可以直接使用缓存文件</li>
<li>400 Bad Request：由于客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthonzed：请求未经授权。这个状态码必须和 WWW-Authenticate 报头域一起使用</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li>404 Not Found：请求的资源不存在，例如输入了错误的 URL</li>
<li>500 Internal Server Error：服务器发生不可预期的错误，导致无法完成客户端的请求</li>
<li>503 Service Unavailable：服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会回复正常</li>
</ul>

<p>下面是一个 HTTP 响应的例子：</p>

<pre><code>HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Data: Mon,60ct2003 13:23:52 GMT
Content-Length:112

&lt;html&gt;...
</code></pre>

<h4 id="toc_5">条件 GET</h4>

<p>HTTP 条件 GET 是 HTTP 协议为了减少不必要的贷款浪费，提出的一种方案。详见：RFC2616</p>

<ol>
<li><p>HTTP 条件 GET 使用的时机</p>

<p>客户端之前已经访问过某网站，并打算再次访问该网站</p></li>
<li><p>HTTP 条件 GET 使用的方法</p>

<p>客户端想服务器发送一个包询问是否在上一次访问网站的时间后更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p></li>
</ol>

<p>下面是一个具体的发送接收报文的示例：</p>

<p>客户端发送请求：</p>

<pre><code>GET / HTTP/1.1
Host: www.sina.com.cn:80
If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT
Connection: Close
</code></pre>

<p>第一次请求时，服务器端发送请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified 响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。</p>

<pre><code>HTTP/1.0 304 Not Modified
Date: Thu, 04 Feb 2010 12:38:41 GMT
Content-Type: text/html
Expires: Thu, 04 Feb 2010 12:39:41 GMT
Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT
Age: 28
X-Cache: HIT from sy32-21.sina.com.cn
Connection: close
</code></pre>

<p>如果服务器端资源已经更新的话，就返回正常的响应。</p>

<h3 id="toc_6">持久连接</h3>

<p>我们知道 HTTP 协议采用 「请求-应答」模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连击，完成之后立即断开连接（HTTP 协议为无连接协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接。</p>

<p>在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际它是被附加到 HTTP 1.0 协议上，如如过客户端浏览器支持 Keep-Alive，那么就在 HTTP 请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开，当客户端发送另外一个请求时，就是用这条已经建立的连接。</p>

<p>在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 Connection: close 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。</p>

<p>注意：</p>

<ul>
<li>HTTP Keep-Alive 简单说就是保持当前 TCP 连接，避免了重新建立连击</li>
<li>HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100, 表示这个 TCP 通道可以保持 5 秒，max=100 表示这个长连接最多接受 100 次请求就断开</li>
<li>HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。另外，Keep-Alive 也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP 1.1 也是如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于 Keep-Alive 的保持连击特性</li>
<li>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1）判断传输数据是否达到了 Content-Length 指示的大小；2）动态生成的文件没有 Content-Length，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后又一个空 chunked 块，表明本次传输数据结束。</li>
</ul>

<h3 id="toc_7">HTTP Pipelining（HTTP 管线化）</h3>

<p>默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于「请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 —&gt; 响应3」。</p>

<p>HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需要等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样：「请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3」。</p>

<p>注意下面几点：</p>

<ul>
<li>管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0 不支持）</li>
<li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制</li>
<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议</li>
<li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>
<li>HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
<li>由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持</li>
</ul>

<h3 id="toc_8">会话跟踪</h3>

<ul>
<li><p>什么是会话？</p>

<p>客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</p></li>
<li><p>什么是会话跟踪？</p>

<p>会话跟踪指的是对一个用户对服务器的连续的请求和接受响应的监视。</p></li>
<li><p>为什么需要会话跟踪？</p>

<p>浏览器与服务器之间的通信是通过 HTTP 协议进行通信的，而 HTTP 协议是「无状态」的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才会有会话跟踪技术来实现这种要求。</p>

<ol>
<li><p>会话跟踪的常用方法</p>

<ul>
<li>URL 重写。URL 是 Web 上特定页面的地址，URL 重写的技术就是在 URL 结尾添加一个附加数据以标识该会话，把会话 ID 通过 URL 的信息传递过去，以便在服务器端进行识别不同的用户</li>
</ul></li>
<li><p>隐藏表单域</p>

<ul>
<li>将会话 ID 添加到 HTML 表单元素中提交到服务器，此标案元素并不在客户端显示</li>
</ul></li>
<li><p>Cookie</p>

<ul>
<li>Cookie 是 Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到刻画段，在客户端可以进行保存，以便下次使用。</li>
<li>客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称之为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。</li>
<li>Cookie 是可以被禁止的。</li>
</ul></li>
<li><p>Session</p>

<ul>
<li>每一个用户都有一个不同的 Session，各个用户之间是不能共享的，是每个用户所独享的，在 Session 中可以存放信息</li>
<li>在服务器端会创建一个 session 对象，产生一个 session ID 来标识这个 session 对象，然后将这个 session ID 放到 Cookie 中发送到客户端，下一次访问时，session ID 会发送到服务器，在服务器端进行标识不同的用户</li>
<li>session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效</li>
</ul></li>
</ol></li>
</ul>

<h3 id="toc_9">跨站攻击</h3>

<p>CSRF（Cross-site request forgery，跨站请求伪造）</p>

<p>CSRF（XSRF）顾名思义，是伪造请求，冒充用户在站内的正常操作。</p>

<p>例如，一论坛网站的发帖是通过 GET 请求访问，点击发帖之后 JS 把发帖内容拼接成目标 URL 并访问：</p>

<pre><code>http://example.com/bbs/create_post.php?title=标题&amp;content=内容
</code></pre>

<p>那么，我们紫瑶在论坛中发一贴，包含一链接：</p>

<pre><code>http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈
</code></pre>

<p>只要有用户点击了这个连接，那么他们的账户就会在不知情的情况下发不了这一帖子。既然发帖的请求可以伪造，那么删帖、转账、改密码、发邮件全部可以伪造。</p>

<h4 id="toc_10">如何防范 CSRF 攻击？</h4>

<p>可以注意以下几点：</p>

<ul>
<li>关键操作只接受 POST 请求</li>
<li>验证码。CSRF 攻击的过程中，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效地防御了 CSRF 攻击。但是如果你在一个网站做出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时使用</li>
<li>检测 Referer

<ul>
<li>常见的互联网页面与页面之间是存在联系的</li>
<li>通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击</li>
</ul></li>
<li>Token

<ul>
<li>目前主流的做法是使用 Token 抵御 CSRF 攻击</li>
<li>CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击</li>
<li>另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的，这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击</li>
</ul></li>
</ul>

<p>Token 使用原则：</p>

<ul>
<li>Token 要足够随机（只有这样才算不可预测）</li>
<li>Token 是一次性的，即每次请求成功后要更新 Token（这样可以增加攻击难度，增加预测难度）</li>
<li>Token 要注意保密性（敏感操作使用 POST，防止操作出现在 URL）中</li>
</ul>

<h3 id="toc_11">XSS（Cross Site Scripting，跨站脚本攻击）</h3>

<p>XSS 全称「跨站脚本」，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到页面上，其他用户访问这个页面的时候就会运行这个脚本。</p>

<p>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p>

<h4 id="toc_12">如何防御 XSS 攻击？</h4>

<p>理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害却绝育攻击代码的威力，攻击代码也不限于 script。防御 XSS 攻击最简单的方法，就是过滤用户的输入。</p>

<p>如果不需要用户输入 HTML，可以直接对用户输入进行 HTML escape。</p>

<p>当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法的 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿去。</p>

<h2 id="toc_13">TCP 协议</h2>

<h3 id="toc_14">TCP 协议的特性</h3>

<ul>
<li>TCP 提供一种面向连接的、可考的字节流服务</li>
<li>在一个 TCP 连接中，仅有两方进行彼此的通信。广播和多播不能用于 TCP</li>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 使用累积确认</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>

<h3 id="toc_15">三次握手与四次握手</h3>

<p>所谓三次握手（Three-way Handshake），是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。</p>

<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connec()</code> 时，将触发三次握手。</p>

<ul>
<li>第一次握手（SYN=1, seq=x）

<ul>
<li>客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器端口，以及初始序列号 X，保存在包头的序列号（Sequence Number）字段里。</li>
<li>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态</li>
</ul></li>
<li>第二次握手（SYN=1, ACK=1, seq=y, ACKnum=x+1）

<ul>
<li>服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序列号（Acknowledgement Number） 设置为客户的 ISN 加 1，即 x+1</li>
<li>发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态</li>
</ul></li>
<li><p>第三次握手（ACK=1, ACKnum=y+1）</p>

<ul>
<li>客户端再次发送确认包（ACK），SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序列号字段 +1，放在确定字段中发送给对方，并且在数据段放写 ISN 的 +1</li>
<li>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>
</ul>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-08-060918.jpg" alt=""/></p></li>
</ul>

<p>TCP 的连接的拆除需要发送四个包，因此成为四次握手（Four-way handshake），也叫做改进的三次握手。客户端或服务器均可主动法切握手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生握手动作。</p>

<ul>
<li>第一次握手（FIN=1, seq=x）

<ul>
<li>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据</li>
<li>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态</li>
</ul></li>
<li>第二次握手（ACK=1, ACKnum=x+1）

<ul>
<li>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接</li>
<li>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接受到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接</li>
</ul></li>
<li>第三次握手（FIN=1, seq=y）

<ul>
<li>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN 置为 1</li>
<li>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个 ACK</li>
</ul></li>
<li><p>第四次握手（ACK=1, ACKnum=y+1）</p>

<ul>
<li>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code> 状态，等待可能出现的要求重传的 ACK 包</li>
<li>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态</li>
<li>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime） 之后，没有收到服务器端的 ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，计入 <code>CLOSED</code> 状态</li>
</ul>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-08-060951.jpg" alt=""/></p></li>
</ul>

<h3 id="toc_16">SYN 攻击</h3>

<h4 id="toc_17">什么是 SYN 攻击（SYN Flood）？</h4>

<p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接成为半连接（half-open connect）。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态</p>

<p>SYN 攻击指的是，攻击客户端在段时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求会被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>

<p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>

<h4 id="toc_18">如何检测 SYN 攻击？</h4>

<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats  命令来检测 SYN 攻击。</p>

<h4 id="toc_19">如何防御 SYN 攻击？</h4>

<p>SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 SYN 攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p>

<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN Cookie 技术</li>
</ul>

<h2 id="toc_20">IP 协议</h2>

<h3 id="toc_21">广播与多播</h3>

<p>广播和多播仅用于 UDP（TCP是面向连接的）。</p>

<h4 id="toc_22">广播</h4>

<p>一共有四种广播地址：</p>

<ol>
<li><p>受限的广播</p>

<p>受限的广播地址为 255.255.255.255。该地址用于珠玑配置过程中 IP 数据报的目的地址，在任何情况下，router 不转发目的地址为 255.255.255.255 的数据报，这样的数据报近出现在本地网络中。</p></li>
<li><p>指向网络的广播</p>

<ul>
<li>指向网络的广播地址是主机号为全 1 的地址。A 类网络广播地址为 netid.255.255.255，其中 netid 为 A 类网络的网络号。</li>
<li>一个 router 必须转发指向网络的广播，但它也必须有一个不进行转发的选择</li>
</ul></li>
<li><p>指向子网的广播</p>

<p>指向子网的广播地址为主机号为全 1 且有特定子网号的地址。作为子网直接广播地址的 IP 地址需要了解子网的掩码。例如，router 收到 128.1.2.255 的数据报，当 B 类网路 128.1 的子网掩码为 255.255.255.0 时，该地址就是指向子网的广播地址；但是如果子网掩码为 255.255.254.0，该地址就不是指向子网的广播地址。</p></li>
<li><p>指向所有子网的广播</p>

<p>指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开来。指向所有子网的广播地址的子网号和主机号为全 1. 例如，如果子网掩码为 255.255.255.0，那么 128.1.255.255 就是一个指向所有子网的广播地址。</p>

<p>当前看法是这种广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。</p></li>
</ol>

<p>广播示例：</p>

<pre><code>PING 192.168.0.255 (192.168.0.255): 56 data bytes 64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.199 ms 64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=45.357 ms 64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.203 ms 64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=269.475 ms
64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=189.881 ms
</code></pre>

<p>可以看到的确受到了来自两个主机的答复，其中 192.168.0.107 是本机地址。</p>

<h4 id="toc_23">多播</h4>

<p>多播又叫组播，使用 D 类地址，D 类地址分配的 28bit 均用作多播组号而不再表示其他。</p>

<p>多播组地址包括 1110 的最高 4 bit 和多播组号。它们通常可以表示为点分十进制数，范围从 224.0.0.0 到 239.255.255.255.</p>

<p>多播的出现减少了对应用不感兴趣主机的处理负荷。</p>

<p>多播的特点：</p>

<ul>
<li>允许一个或多个发送者（组播源）发送单一的数据包到多个接收者（一次的、同时的）的网络技术</li>
<li>可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包</li>
<li>多播技术的核心就是针对如何节约网络资源的前提下保证服务质量</li>
</ul>

<p>多播示例：</p>

<pre><code>PING 224.0.0.1 (224.0.0.1): 56 data bytes
64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.081 ms
64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=123.081 ms
64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.122 ms
64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=67.312 ms
64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.132 ms
64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=447.073 ms
64 bytes from 192.168.0.107: icmp_seq=3 ttl=64 time=0.132 ms
64 bytes from 192.168.0.106: icmp_seq=3 ttl=64 time=188.800 ms
</code></pre>

<h3 id="toc_24">BGP</h3>

<ul>
<li>边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议</li>
<li>BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不想管路由域间的多路连接的协议</li>
<li>BGP 是一种外部网关协议（Exterior Gateway Protocol, EGP），与 OSPF、RIP 等 内部网关协议（Interior Gateway Protocol, IGP） 不同，BGP 不在于发现和计算路由，而在于控制路由的传播和选择最佳路由</li>
<li>BGP 使用 TCP 作为其传输层协议（端口号 179），提高了协议的可靠性</li>
<li>BGP 支持 CIDR（Classless Inter-Domain Routing，无类别域间路由）</li>
<li>路由更新时，BGP 只发送更新的路由，大大减少了 BGP 传播路由所占用的贷款，适用于在 Internet 上传播大量的路由信息</li>
<li>BGP 路由通过携带 AS 路径信息彻底解决路由环路问题</li>
<li>BGP 提供了丰富的路由策略，能够对路由实现灵活的过滤和选择</li>
<li>BGP 易于扩展，能够实行网络新的发展</li>
</ul>

<h2 id="toc_25">Socket 编程</h2>

<p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与 TCP/IP 协议族通信的中间软件抽象层。从设计模式的角度来看，Socket 其实是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</p>

<p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip 地址、协议、端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其他进程进行交互。</p>

<p>Socket 起源于 Unix，Unix 基本哲学之一就是「一切皆文件」，都可以用「open -&gt; read/write -&gt; close」 模式来进行操作。因此，Socket 也被处理为一种特殊的文件。</p>

                            
                        </div>
                    </div>
                </li>
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/3/7">2017/3/7</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14888872084322.html">Algorithms 4ed 题解</a></h2>
                        <div itemprop="description">
                            
                                <ul>
<li>
<a href="#toc_0">1.3 背包、队列和栈</a>
<ul>
<li>
<a href="#toc_1">1.3.1</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1.3 背包、队列和栈</h2>

<h3 id="toc_1">1.3.1</h3>

                            
                        </div>
                    </div>
                </li>
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/3/6">2017/3/6</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14887608416607.html">算法</a></h2>
                        <div itemprop="description">
                            
                                <ul>
<li>
<a href="#toc_0">1.3 背包、队列和栈</a>
<ul>
<li>
<a href="#toc_1">1.3.1 API</a>
<ul>
<li>
<a href="#toc_2">1.3.1.1 泛型</a>
</li>
<li>
<a href="#toc_3">1.3.1.2 自动装箱</a>
</li>
<li>
<a href="#toc_4">1.3.1.3 可迭代的几何类型</a>
</li>
<li>
<a href="#toc_5">1.3.1.4 背包</a>
</li>
<li>
<a href="#toc_6">1.3.1.5 先进先出队列</a>
</li>
<li>
<a href="#toc_7">1.3.1.6 下压栈</a>
</li>
<li>
<a href="#toc_8">1.3.1.7 算数表达式求值</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">1.3.2 集合数据类型的实现</a>
<ul>
<li>
<a href="#toc_10">1.3.2.1 定容栈</a>
</li>
<li>
<a href="#toc_11">1.3.2.2 泛型</a>
</li>
<li>
<a href="#toc_12">1.3.2.3 调整数组的大小</a>
</li>
<li>
<a href="#toc_13">1.3.2.4 对象游离</a>
</li>
<li>
<a href="#toc_14">1.3.2.5 迭代</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">1.3.3 链表</a>
<ul>
<li>
<a href="#toc_16">1.3.3.1 结点记录</a>
</li>
<li>
<a href="#toc_17">1.3.3.8 栈的实现</a>
</li>
<li>
<a href="#toc_18">1.3.3.9 队列的实现</a>
</li>
<li>
<a href="#toc_19">1.3.3.10 背包的实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_20">1.3.4 综述</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">1.4 算法分析</a>
<ul>
<li>
<a href="#toc_22">1.4.1 科学方法</a>
</li>
<li>
<a href="#toc_23">1.4.3 数学模型</a>
</li>
<li>
<a href="#toc_24">1.4.4 增长数量级的分类</a>
</li>
<li>
<a href="#toc_25">1.4.5 设计更快的算法</a>
</li>
<li>
<a href="#toc_26">1.4.7 注意事项</a>
<ul>
<li>
<a href="#toc_27">1.4.7.1 大常数</a>
</li>
<li>
<a href="#toc_28">1.4.7.2 非决定性的内循环</a>
</li>
<li>
<a href="#toc_29">1.4.7.3 指令时间</a>
</li>
</ul>
</li>
<li>
<a href="#toc_30">1.4.8 处理对于输入的依赖</a>
<ul>
<li>
<a href="#toc_31">1.4.8.1 输入模型</a>
</li>
<li>
<a href="#toc_32">1.4.8.3 随机化算法</a>
</li>
<li>
<a href="#toc_33">1.4.8.5 均摊分析</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_34">1.5 案例研究：union-find 算法</a>
</li>
<li>
<a href="#toc_35">2.1 初级排序算法</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_36">2.1.1.3 额外的内存使用</a>
</li>
</ul>
</li>
<li>
<a href="#toc_37">2.1.2 选择排序</a>
</li>
<li>
<a href="#toc_38">2.1.3 插入排序</a>
</li>
<li>
<a href="#toc_39">2.1.6 希尔排序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_40">2.2 归并排序</a>
<ul>
<li>
<a href="#toc_41">2.2.1 原地归并的抽象方法</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1.3 背包、队列和栈</h2>

<p>研究方法：1）学习其 API 和用例；2）讨论数据类型的值和所有可能的表示方法；3）各种操作的实现。</p>

<h3 id="toc_1">1.3.1 API</h3>

<p>每份 API 都含有一个无参数的构造函数、一个向集合中添加单个元素的方法、一个测试集合是否为空的方法和一个返回集合大小的方法。Stack 和 Queue 都含有一个能够删除集合中的特定元素的方法。</p>

<p>背包：</p>

<table>
<thead>
<tr>
<th></th>
<th>Bag()</th>
<th>创建一个空背包</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>add(item)</td>
<td>添加一个空元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>背包是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>背包中元素的数量</td>
</tr>
</tbody>
</table>

<p>先进先出（FIFO）队列:</p>

<table>
<thead>
<tr>
<th></th>
<th>Queue()</th>
<th>创建空队列</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>enqueue(item)</td>
<td>添加一个元素</td>
</tr>
<tr>
<td>Item</td>
<td>dequeue()</td>
<td>删除最早添加的元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>队列是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>队列中元素数量</td>
</tr>
</tbody>
</table>

<p>下压（后进先出，LIFO）栈：</p>

<table>
<thead>
<tr>
<th></th>
<th>Stack()</th>
<th>创建一个空栈</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>push(item)</td>
<td>添加一个元素</td>
</tr>
<tr>
<td>Item</td>
<td>pop()</td>
<td>删除最近添加的元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>栈是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>栈中的元素数量</td>
</tr>
</tbody>
</table>

<h4 id="toc_2">1.3.1.1 泛型</h4>

<p>因为这里使用的 Python 语言来实现书中的代码，所以不存在泛型的问题，Python 是鸭子类型。</p>

<h4 id="toc_3">1.3.1.2 自动装箱</h4>

<p>自动讲一个原始数据类型转换为一个封装类型被称为自动装箱，自动将一个封装类型转换为原始数据类型被称为自动拆箱。</p>

<h4 id="toc_4">1.3.1.3 可迭代的几何类型</h4>

<p>对应 Python 中的 Iterable 类型。</p>

<h4 id="toc_5">1.3.1.4 背包</h4>

<p>背包是一种不支持从中删除元素的几何数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。迭代的顺序不确定且与用例无关。</p>

<h4 id="toc_6">1.3.1.5 先进先出队列</h4>

<p>先进先出队列（简称队列）是一种基于先进先出（FIFO）策略的集合类型。</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-06-011739.jpg" alt=""/></p>

<h4 id="toc_7">1.3.1.6 下压栈</h4>

<p>下压栈（简称栈）是一种基于后进先出（LIFO）策略的几何类型。典型例子：1）邮件系统；2）浏览器。</p>

<h4 id="toc_8">1.3.1.7 算数表达式求值</h4>

<p>递归定义：<em>算数表达式</em>可能是一个数、或者是一个由左括号、一个算数表达式、一个运算符、另一个算数表达式和一个右括号组成的表达式。（简单起见，这里定义的是未省略括号的算数表达式）。</p>

<p>E.W.Dijkstra 在 20 世纪 60 年代发明了一个非常简单的算法，用两个栈（一个用于保存运算符，一个用于保存操作数）完成了这个任务。</p>

<p>我们根据以下 4 种情况从左到右逐个将这些实体送入栈处理：</p>

<ol>
<li>将操作数压入操作数栈；</li>
<li>将运算符压入运算符栈；</li>
<li>忽略左括号；</li>
<li>在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。</li>
</ol>

<p>一个用栈实现的简单解释器例子：</p>

<pre><code class="language-python">def evaluate(expression):
    ops = Stack()
    vals = Stack()
    
    for s in expression:
        if s == &#39;(&#39;:
            continue
        elif s == &#39;+&#39;:
            ops.push(s)
        elif s == &#39;-&#39;:
            ops.push(s)
        elif s == &#39;*&#39;:
            ops.push(s)
        elif s == &#39;/&#39;:
            ops.push(s)
        elif s == &#39;)&#39;:
            op = ops.pop()
            v = vals.pop()
            if op == &#39;+&#39;:
                v = vals.pop() + v
            elif op == &#39;-&#39;:
                v = vals.pop() - v
            elif op == &#39;*&#39;:
                v = vals.pop() * v
            elif op == &#39;/&#39;:
                v = vals.pop() / v
            vals.push(v)
        else:
            vals.push(s)
</code></pre>

<h3 id="toc_9">1.3.2 集合数据类型的实现</h3>

<h4 id="toc_10">1.3.2.1 定容栈</h4>

<p>定容栈是一种表示容量固定的字符串栈的抽象数据类型，它的 API 和 Stack 的 API 有所不同：它只能处理 String 值，它要求用例制定一个容量且不支持迭代。实现一份 API 的第一步就是选择数据的表示方式，对于 <code>FixedCapacityStackOfStrings</code>，我们可以选用数组。</p>

<p>API:</p>

<table>
<thead>
<tr>
<th></th>
<th>FixedCapacityStackOfStrings(size)</th>
<th>创建一个容量为 size 的空栈</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>push(item:str)</td>
<td>添加一个字符串</td>
</tr>
<tr>
<td>str</td>
<td>pop()</td>
<td>删除最近添加的字符串</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>栈是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>栈中字符串数量</td>
</tr>
</tbody>
</table>

<p>数据类型的实现：</p>

<pre><code class="language-python">class FixedCapacityStackOfStrings:
    def __init__(self, size):
        _a = []     # stack entries
        _size = size
        N = 0      # stack index
        

    def isEmpty(self):
        return N == 0

    def size(self):
        return N
    
    def push(self, item):
        N += 1
        _a[N] = item

    def pop(self):
        N -= 1
        return _a[N]
</code></pre>

<ul>
<li>数组中的元素顺序和它们被插入的顺序相同</li>
<li>当 N 为 0 时栈为空</li>
<li>栈的顶部位于 <code>_a[N-1]</code></li>
</ul>

<h4 id="toc_11">1.3.2.2 泛型</h4>

<p>如果上面代码是用 Java 写的话，确实只能处理 String 对象，但是 Python 是动态类型的语言，不存在泛型的问题。</p>

<h4 id="toc_12">1.3.2.3 调整数组的大小</h4>

<p>选择用数组表示栈内容意味着用例必须预先估计栈的最大容量（在 Python 中数组是动态变化的，所以不需要，这里为了模拟）。在 Java 中，数组一旦创建，其大小是无法改变的，因此栈使用的空间只能是这个最大容量的一部分。选择大容量的用例在栈为空或几乎为空时会浪费大量的内存。<code>push()</code> 方法需要在代码中检测栈是否已满，我们的 API 中也应该含有一个 <code>isFull()</code> 的方法来允许用例检测栈是否已满。我们在此省略了它实现的代码，因为我们希望用例从处理栈已满的问题中解脱出来，如我们原始的 Stack API 所示。因此，我们修改了数组的实现，动态调整数组的大小，使得它既足以保存所有元素，又不至于浪费过多的空间。</p>

<p>首先，实现一个方法将栈移动到另一个大小不同的数组中：</p>

<pre><code class="language-python">def resize(self, max):
   temp = []
   _size = max
   for i in range(N):
       temp[i] = _a[i]
   a = temp
</code></pre>

<p>现在，在 <code>push()</code> 中，检查数组是否太小。具体来说，我们会通过检查栈代销 N 和数组大小 <code>_size</code> 是否相等来检查数组是否能容纳新的元素。如果没有多余的空间，我们会将数组的长度加倍，然后既可以和之前一样用 <code>a[N++] = item</code> 插入新元素了：</p>

<pre><code class="language-python">def push(self, item):
   if N == _size:
       self.resize(2*_size)
   N += 1
   _a[N] = item
</code></pre>

<p>类似，在 <code>pop()</code> 中，首先删除栈顶的元素，然后如果数组太大我们就将它的长度减半。只要稍加思考，技能明白正确的检测条件是栈大小是否小鱼数组的四分之一。在数组长度被减半之后，它的状态为半满，在下次需要改变数组大小之前人能够进行多次 <code>push()</code> 和 <code>pop()</code> 操作。</p>

<pre><code class="language-python">def pop(self):
   N -= 1
   item = _a[N]
   _a[N] = None
   if N &gt; 0 and N == _size/4:
       resize(_size/2)
   return item
</code></pre>

<p>在这个实现中，栈永远都不会溢出，使用率也永远不会低于四分之一。</p>

<h4 id="toc_13">1.3.2.4 对象游离</h4>

<p>Java 的垃圾收集策略是回收所有无法被访问的对象的内存。在我们队 <code>pop()</code> 的实现中，被弹出的元素引用仍然存在于数组中。这个元素实际上已经是一个孤儿了——它永远不会被再访问了，但 Java 的垃圾收集器没法知道这一点，除非该引用被覆盖。即使用例已经不再需要这个元素了，数组中的引用仍然可以让它继续存在，这种情况（保存一个不需要的对象的引用）成为<strong>游离</strong>。</p>

<h4 id="toc_14">1.3.2.5 迭代</h4>

<p>集合类数据类型的基本操作之一就是，能够使用 Python 的 for-in 语句通过迭代遍历并处理集合中的每个元素。这种方式的代码既清晰又简介，且不依赖与集合数据类型的具体实现。</p>

<p>好处：1）我们无需改变任何用例代码就可以随意切换不同的表示方法；2）更重要的是，从用例的角度来说，无需知晓类的实现细节用例也能使用迭代。</p>

<p>在 Python 中，需要在类中实现 <code>__iter__()</code> 和 <code>__next__()</code> 。</p>

<pre><code class="language-python">def __iter__(self):
     return self

def __next__(self):
     index = 0
     if index &gt; _size:
         raise StopIteration
     else:
         index += 1
         return self._a[index-1]
</code></pre>

<p>例如，我们在实现 Queue 的 API 时，可以使用两个实例变量作为索引，一个变量 head 指向队列的开头，一个变量 tail 指向队列的结尾。在删除一个元素时，使用 head 访问它并将 head 加 1；在插入一个元素时，使用 tail 保存它并将 tail 加 1.如果某个索引在增加之后越过了数组的边界则将它重置为 0.</p>

<p>下压（LIFO）栈（能够动态调整数组大小的实现）：</p>

<pre><code class="language-python">class ResizingArrayStack(object):
    a = []
    N = 0

    def isEmpty(self):
        return N == 0

    def size(self):
        return N

    def resize(self, max):
        temp = []
        for i in range(N):
            temp[i] = a[i]
        a = temp

    def push(self, item):
        if N == len(self.a):
            self.resize(2*len(self.a))
        N += 1
        a[N] = item

    def pop(self):
        N -= 1
        item = a[N]
        a[N] = None
        if N &gt; 0 and N == len(self.a):
            self.resize(len(self.a)/2)

    def __iter__(self):
        return self

    def __next__(self):
        index = N - 1
        if index == 0:
            raise StopIteration
        else:
            index -= 1
            return a[index]
</code></pre>

<p>这份支持迭代的 Stack API 的实现是所有集合抽象数据类型实现的模板。它将所有元素保存在数组中，并动态调整数组大小以保持数组大小和栈大小之比小于一个常数。</p>

<h3 id="toc_15">1.3.3 链表</h3>

<blockquote>
<p>定义：链表是一种递归的数据结构，它为空（None），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</blockquote>

<p>在这个定义中，<code>结点</code>是一个可能含有任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。</p>

<h4 id="toc_16">1.3.3.1 结点记录</h4>

<pre><code class="language-python">class Node(object):
        def __init__(self, item):
             self.item = item
             self.next = None
             
        def get_item(self):
                return self.item
                
        def get_next(self):
                return self.next
                
        def set_item(self, item):
                self.item = item
                
        def set_next(self, next):
                self.next = next
</code></pre>

<h4 id="toc_17">1.3.3.8 栈的实现</h4>

<p>下压堆栈（链表实现）：</p>

<pre><code class="language-python">class Node(object):
    def __init__(self, item):
        self.item = item
        self.next = None

class Stack(object):
    def __init__(self):
        self.first = None
        self.N = 0
        
    def isEmpty(self):
        return self.N == 0
    
    def size(self):
        return self.N
    
    def push(self, item):
        oldfirst = self.first
        self.first = Node(item)
        self.first.next = oldfirst
        self.N += 1
        
    def pop(self):
        item = self.first.item
        self.first = self.first.next
        self.N -= 1
        return item
</code></pre>

<h4 id="toc_18">1.3.3.9 队列的实现</h4>

<p>基于链表数据结构实现 Queue API 也很简单。它将队列表示为一条从最早插入的元素到最近插入的元素的链表，实例变量 first 指向队列的开头，实例变量 last 指向 队列的结尾。这样，要讲一个元素入列（<code>enqueue()</code>），我们就将它添加到表尾（但是在链表为空时需要将 first 和 last 都指向新节点）；要将一个元素出列（<code>dequeue()</code>），我们就删除表头的结点（代码和 Stack 的 <code>pop()</code> 相同，只是当链表为空时需要更新 last 的值）。<code>size()</code> 和 <code>isEmpty()</code> 方法的实现和 Stack 相同。</p>

<p>和刚才一样，我们用链表达到了最优设计目标：<strong>它可以处理任意类型数据，所需的空间总是和集合大小成正比，操作所需时间总是和集合大小无关</strong>。</p>

<p>先进先出队列的实现：</p>

<pre><code class="language-python">class Queue(object):
    def __init__(self):
        self.first = None  # 指向最早添加的结点的链接
        self.last = None  # 指向最近添加的结点的链接
        self.N = 0
        
    def isEmpty(self):
        return self.N == 0
    
    def size(self):
        return self.N
    
    def enqueue(self, item):
        oldlast = self.last
        self.last = Node(item)
        self.last.next = None
        if self.isEmpty():
            self.first = self.last
        else:
            oldlast.next = self.last
        self.N += 1
        
    def dequeue(self):
        item = self.first.item
        self.first = self.first.next
        if self.isEmpty():
            self.last = None
        self.N -= 1
        return item
</code></pre>

<p>在结构化存储数据集时，<strong>链表是数组的一种重要的替代方式</strong>。事实上，编程语言历史上的一块里程碑就是 McCathy 在 20 世纪 50 年代发明的 LISP 语言，而链表则是这种语言组织程序和数据的主要结构。</p>

<h4 id="toc_19">1.3.3.10 背包的实现</h4>

<p>用链表数据结构实现我们的 Bag API 只需要将 Stack 中的 <code>push()</code> 方法改名为 <code>add()</code>，并去掉 <code>pop()</code> 的实现即可。</p>

<p>对于 Stack，链表的访问顺序是后进先出；对于 Queue，链表的访问顺序是先进先出；对于 Bag，它正好也是后进先出的顺序，但顺序并不重要。</p>

<p>背包的实现：</p>

<pre><code class="language-python">class Bag(object):
    def __init__(self):
        self.first = None
        self.N = 0
        
    def isEmpty(self):
        return self.first is None
    
    def add(self, item):
        oldfirst = self.first
        self.first = Node(item)
        self.first.next = oldfirst
        self.N += 1
        
    def __len__(self):
        return self.N
        
    def __iter__(self):
        return _BagIterator(self.first)

class _BagIterator(object):
    def __init__(self, listhead):
        self.current = listhead

    def __iter__(self):
        return self

    def __next__(self):
        if self.current is None:
            raise StopIteration
        item = self.current.item
        self.current = self.current.next
        return item
</code></pre>

<p>这份代码中实现了迭代器（可以使用 for-in 来遍历），Stack 和 Queue 可以使用同样的方法来实现。</p>

<h3 id="toc_20">1.3.4 综述</h3>

<p>基础数据结构：</p>

<table>
<thead>
<tr>
<th>数据结构</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>

<tbody>
<tr>
<td>数组</td>
<td>通过索引可以直接访问任意元素</td>
<td>在初始化时就需要知道元素的数量</td>
</tr>
<tr>
<td>链表</td>
<td>使用的空间大小和元素数量成正比</td>
<td>需要通过引用访问任意元素</td>
</tr>
</tbody>
</table>

<p>我们在本节中研究背包、队列和栈时描述数据结构和算法的方式是全书的原型。在研究一个新的应用领域时，我们将会按照以下步骤识别目标并使用数据抽象解决问题：</p>

<ol>
<li>定义 API</li>
<li>根据特定的应用场景开发用例代码</li>
<li>描述一种数据结构（一组值得表示），并在 API 所对应的抽象数据类型的实现中根据它定义类的实例变量</li>
<li>描述算法（实现一组操作的方式），并根据它实现类中的实例方法</li>
<li>分析算法的性能特点</li>
</ol>

<p>本书中所给出的数据结构举例：</p>

<table>
<thead>
<tr>
<th>数据结构</th>
<th>抽象数据类型</th>
<th>数据表示</th>
</tr>
</thead>

<tbody>
<tr>
<td>父链接数</td>
<td>UnionFind</td>
<td>整形数组</td>
</tr>
<tr>
<td>二分查找树</td>
<td>BST</td>
<td>含有两个链接的结点</td>
</tr>
<tr>
<td>字符串</td>
<td>String</td>
<td>数组、偏移量和长度</td>
</tr>
<tr>
<td>二插堆</td>
<td>PQ</td>
<td>对象数组</td>
</tr>
<tr>
<td>散列表（拉链法）</td>
<td>SeparateChainingHashST</td>
<td>链表数组</td>
</tr>
<tr>
<td>散列表（线性探测法）</td>
<td>LinerProbingHashST</td>
<td>两个对象数组</td>
</tr>
<tr>
<td>图的邻接链表</td>
<td>Graph</td>
<td>Bag 对象数组</td>
</tr>
<tr>
<td>单词查找树</td>
<td>TrieST</td>
<td>含有链接数组的结点</td>
</tr>
<tr>
<td>三向单词查找树</td>
<td>TST</td>
<td>含有三个链接的结点</td>
</tr>
</tbody>
</table>

<h2 id="toc_21">1.4 算法分析</h2>

<h3 id="toc_22">1.4.1 科学方法</h3>

<p>科学家用来理解自然世界的方法对于研究计算机程序的运行时间同样有效：</p>

<ul>
<li>细致地观察真实世界的特点，通常还要有精确的测量</li>
<li>根据观察结果提出假设模型</li>
<li>根据模型预测未来的事件</li>
<li>继续观察并核实预测的准确性</li>
<li>如此反复直到确认预测和观察一致</li>
</ul>

<h3 id="toc_23">1.4.3 数学模型</h3>

<p>一个程序运行的总时间主要和两点有关：</p>

<ul>
<li>执行每条语句的耗时</li>
<li>执行每条语句的频率</li>
</ul>

<h3 id="toc_24">1.4.4 增长数量级的分类</h3>

<p>对增长数量级常见假设的总结：</p>

<table>
<thead>
<tr>
<th>描述</th>
<th>增长的数量级</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>

<tbody>
<tr>
<td>常数级别</td>
<td>1</td>
<td>普通语句</td>
<td>将两个数相加</td>
</tr>
<tr>
<td>对数级别</td>
<td>\(logN\)</td>
<td>二分策略</td>
<td>二分查找</td>
</tr>
<tr>
<td>线性级别</td>
<td>\(N\)</td>
<td>循环</td>
<td>找出最大元素</td>
</tr>
<tr>
<td>线性对数级别</td>
<td>\(NlogN\)</td>
<td>分治</td>
<td>归并排序</td>
</tr>
<tr>
<td>平方级别</td>
<td>\(N^2\)</td>
<td>双层循环</td>
<td>检查所有元素对</td>
</tr>
<tr>
<td>立方级别</td>
<td>\(N^3\)</td>
<td>三层循环</td>
<td>检查所有三元组</td>
</tr>
<tr>
<td>指数级别</td>
<td>\(2^N\)</td>
<td>穷举查找</td>
<td>检查所有子集</td>
</tr>
</tbody>
</table>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-07-124852.jpg" alt=""/></p>

<h3 id="toc_25">1.4.5 设计更快的算法</h3>

<p>学习程序的增长数量级的一个重要动力就是为了帮助我们为同一个问题设计更快地算法。</p>

<h3 id="toc_26">1.4.7 注意事项</h3>

<h4 id="toc_27">1.4.7.1 大常数</h4>

<p>在首项近似中，我们一般会忽略低级项中的常数系数，但这可能是错的。例如，当我们取函数 \(2N^2+cN\) 的近似为 ~\(2N^2\) 时，我们的假设是 c 很小。如果事实不是这样（比如 c 可能是 \(10^6\)），该近似就是错误的。因此，我们要对可能的大常数保持敏感。</p>

<h4 id="toc_28">1.4.7.2 非决定性的内循环</h4>

<p>内循环是决定性因素的假设并不是总正确的。错误的成本模型可能无法得到真正的内循环，问题规模 \(N\) 也许没有大到对指令的执行频率的数学描述中的首项大大超过其他低级项并可以忽略它们的程度。有些程序在内循环之外也有大量指令需要考虑。</p>

<h4 id="toc_29">1.4.7.3 指令时间</h4>

<p>每条指令执行所需的时间总是相同的假设并不总是正确的。例如，大多数现在计算机系统都会使用缓存技术来组织内存，在这种情况下访问大数组中的若干个并不相邻元素所需的时间可能很长。</p>

<h3 id="toc_30">1.4.8 处理对于输入的依赖</h3>

<h4 id="toc_31">1.4.8.1 输入模型</h4>

<p>一种方法是更加小心地对我们所要解决的问题所处理的输入建模。使用这种方法的困难主要有两点：</p>

<ol>
<li>输入模型可能是不切实际的</li>
<li>对输入的分析可能极端困难</li>
</ol>

<h4 id="toc_32">1.4.8.3 随机化算法</h4>

<p>为性能提供保证的一种重要的方法是引入随机性。例如，快速排序算法在最坏情况系的性能是平方级别的，但通过随机打乱输入，根据概率我们能够保证它的性能是线性对数的。每次运行该算法，它所需的时间均不相同，但它的运行时间超过超过线性对数级别的可能性小到可以忽略。与此类似，用于符号表的散列算法在最坏情况下的性能是线性级别的，但根据概率我们可以保证它的运行时间是常数级别的。</p>

<h4 id="toc_33">1.4.8.5 均摊分析</h4>

<p>相应地，提供性能保证的另一种方法是通过记录所有操作的总成本并除以操作总数来将成本均摊。在这里，我们可以允许执行一些昂贵的操作，但保持所有操作的平均数成本较低。</p>

<h2 id="toc_34">1.5 案例研究：union-find 算法</h2>

<p>为了说明我们设计和分析算法的基本方法，我们现在来学习一个具体的例子。我们的目的是强调以下几点：</p>

<ul>
<li>优秀的算法因为能够解决实际问题而变得更为重要；</li>
<li>高效算法的代码也可以很简单；</li>
<li>理解某个实现的性能特地拿是一项有趣而令人满足的挑战；</li>
<li>在解决同一个问题的多种算法之间进行选择时，科学方法是一种重要的工具；</li>
<li>迭代式改进能够让算法的效率越来越高。</li>
</ul>

<h2 id="toc_35">2.1 初级排序算法</h2>

<h4 id="toc_36">2.1.1.3 额外的内存使用</h4>

<p>排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类：</p>

<ul>
<li>原地排序算法</li>
<li>需要额外内存空间来存储的其他排序算法</li>
</ul>

<h3 id="toc_37">2.1.2 选择排序</h3>

<p>选择排序两个鲜明的特点：</p>

<ol>
<li>运行时间和输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶地发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长。</li>
<li>数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——交换次数和数组的大小是线性关系。</li>
</ol>

<p>选择排序实现：</p>

<pre><code class="language-python">def selection_sort(a):
    N = len(a)
    for i in range(N):
        mi = i
        for j in range(i+1, N):
            if a[j] &lt; a[mi]:
                mi = j
        a[i], a[mi] = a[mi], a[i]
    return a
</code></pre>

<h3 id="toc_38">2.1.3 插入排序</h3>

<p>与选择排序一样，当前索引左边的所有元素都是有序的，但它们最终的最终位置还不确定，为了给更小元素腾出空间，它们可能会被移动。但是当前索引到达数组的右端时，数组排序就完成了。</p>

<p>与选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。</p>

<p>插入排序对于实际应用中常见的某些类型的非随机数组很有效。当插入排序对一个有序数组进行排序，运行时间是线性的。</p>

<pre><code class="language-python">def insertion_sort(a):
    for i in range(1, len(a)):
        for j in range(i, 0, -1):
            if a[j] &lt; a[j-1]:
                a[j], a[j-1] = a[j-1], a[j]
    return a
</code></pre>

<p>对于 1 到 N-1 之间的每一个 i，将 a[i] 与 a[0] 到 a[i-1] 中比它小的所有元素依次有序地交换。在索引 i 由左向右变化的过程中，它左侧的元素总是有序的，所以当 i 到达数组的右端时排序就完成了。</p>

<p>我们要考虑的更一般的情况是部分有序的数组。<strong>倒置</strong>指的是数组中的两个顺序颠倒的元素。比如 E X A M P L E 中有 11 对倒置：E-A X-A X-M X-P X-L X-E M-L M-E ... 如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。</p>

<p>下面是几种典型的部分有序的数组：</p>

<ul>
<li>数组中每个元素都距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>

<p>插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置数量很少时，插入排序很可能比本章中的其他任何算法都要快。</p>

<p>要大幅提高插入排序的速度并不难，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素。</p>

<h3 id="toc_39">2.1.6 希尔排序</h3>

<p>为了展示初级排序算法性质的价值，我们将学习一种基于插入排序的快速排序算法。对于大规模乱序数组插入排序很慢，因为它智慧交换相邻的元素，因此元素只能一点一点地从数组的一段移动到另一端。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终插入排序将局部有序的数组排序。</p>

<p>希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。换句话说，h 有序数组就是 h 个独立的有序数组编织在一起组成的一个数组，如下图所示。</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-09-115612.jpg" alt=""/></p>

<p>实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在 h-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希尔排序的实现就转化为了一个类似于插入排序但是用不同增量的过程。</p>

<p>希尔排序更高效的原因是它权衡了子数组的规模性和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。子数组部分有序的程度取决于递增序列的选择。</p>

<pre><code class="language-python">def shell_sort(a):
    h = 1
    while h &lt; len(a) / 3:
        h = 3 * h + 1
    while h &gt;= 1:
        for i in range(int(h), len(a)):
            for j in range(i, int(h)-1, -1):
                if a[j] &lt; a[j - int(h)]:
                    a[j], a[j - int(h)] = a[j - int(h)], a[j]
        h = h / 3
    return a
</code></pre>

<h2 id="toc_40">2.2 归并排序</h2>

<p>归并：即将两个有序数组归并成一个更大的有序数组。</p>

<h3 id="toc_41">2.2.1 原地归并的抽象方法</h3>

<p>实现归并的一种直截了当的方法是将两个不同的有序数组归并到第三个数组中。</p>

<p>但是，当用归并将一个很大的数组排序时，我们需要进行很多次归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题。我们更希望有一种能够在原地归并的方法，这样就可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。</p>

<p>原地归并的抽象方法：</p>

<pre><code class="language-python">
</code></pre>

                            
                        </div>
                    </div>
                </li>
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/3/4">2017/3/4</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14886163941964.html">March 2017</a></h2>
                        <div itemprop="description">
                            
                                <ul>
<li>
<a href="#toc_0">2017/03/04</a>
<ul>
<li>
<a href="#toc_1">How do I as a student start contributing to open source?</a>
</li>
<li>
<a href="#toc_2">How can a person get selected in Google Summer of Code?</a>
</li>
<li>
<a href="#toc_3">平台后端开发(Python)面试记录</a>
</li>
<li>
<a href="#toc_4">如何为你的 GitHub 开源项目写一份优秀的 README.md 文档？</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">2017/03/04</h2>

<h3 id="toc_1"><a href="https://www.quora.com/How-do-I-as-a-student-start-contributing-to-open-source">How do I as a student start contributing to open source?</a></h3>

<p>Nimit Shah:</p>

<ol>
<li>Start contributing to an open source project that you use in your day to day life</li>
<li>Select a project from Google Summer of Code or GNOME Outreach Program for Women</li>
</ol>

<h3 id="toc_2"><a href="https://www.quora.com/How-can-a-person-get-selected-in-Google-Summer-of-Code">How can a person get selected in Google Summer of Code?</a></h3>

<p>Ashwyn Sharma:</p>

<p><strong>Do not apply for GSoC if you are not an Open Source Enthusiast!</strong></p>

<p>Crucial steps involved in the process:</p>

<ol>
<li>Start with the list of accepted organisations in the past years and pick one of them.</li>
<li>Contact the organisation telling them about yourself (in most cases - that you are a software developer who is new to their products/applications/platforms etc.) and how you wish to contribute to their codebase.</li>
<li>Get yourself familiar with the codebase. A little perseverance at this stage may prove decisive of your future with both GSoC and Open Source in general. Pick up a simple bug/feature-request from the bug tracker of the given application and try to solve it. Not only this will increase your chances of acceptance dramatically, it will also help you get familiar with the developers and of course, the code itself. An important thing to remember is to make your presence felt amongst the developer community. This will help you at later stages of the application process.</li>
<li>Provided you manage to solve the bug or develop that feature, the next step will be to commit your code to the Trunk/Central Repository.</li>
<li>Next is the application period. As soon as Google announces the list of the accepted organisations, start looking for the prospective <strong>project ideas</strong>. Think over how you can go about executing these ideas. Talk to the prospective mentors about what you think of the idea and may be fetch more details about the ins and outs of project. Though Google allows you to submit your own original ideas as well, I have always believed that its better to choose from the list of the ideas provided by the organization. However, if the idea is truly meaningful and has a feasible implementation plan, there have been instances where original ideas have been accepted as well. If you haven&#39;t already, keep working on that bug and solve it, because if you haven&#39;t really proved your coding skills to the organisation yet, then  your chances of getting accepted gets even simmer, no matter how strong your application maybe.</li>
<li>Start writing the proposal as early as possible. Make sure that before submitting the proposal, you get your proposal reviewed by your mentors as much as possible. The main ingredients of a good proposal are that it should address two kinds of audiences - one which is completely familiar with the technical details of the project (that would be your mentors and organisation devs) and the second one is a neutral not-so-technical audience which is able to understand the deliverables of the project (in most cases that would be the user base). Start coding up your idea.</li>
</ol>

<h3 id="toc_3"><a href="http://blog.csdn.net/huangxiongbiao/article/details/50733303">平台后端开发(Python)面试记录</a></h3>

<ol>
<li>手写 Python 生成器（带 yield 的函数）</li>
<li>手写链表翻转</li>
<li>Tornado 框架中的异步实现原理</li>
<li>select, poll, epoll, epoll 改进了 select/poll 的什么地方</li>
<li>线程与进程的区别</li>
<li>进程间通信方式</li>
<li>数据库原理（索引，B 树）</li>
<li>TCP 四次握手过程</li>
<li>Nginx 的转发原理</li>
<li>Linux 文件系统</li>
</ol>

<h3 id="toc_4"><a href="https://www.diycode.cc/topics/498">如何为你的 GitHub 开源项目写一份优秀的 README.md 文档？</a></h3>

<ul>
<li>Project Title: one paragraph of description goes here.</li>
<li>Getting Started: These istructions will get you a copy of the project up and running on your local machine for development and testing purposes.</li>
<li>Prerequisties: what things you need to install the software and how to install them.</li>
<li>Installing: A step by step series of examples that you have to get a development env running.</li>
<li>Running the tests: Explain how to run the automated tests for this system.</li>
<li>Break down into end to end tests: explain what these tests test and why</li>
<li>And coding style tests: expalin what these tests test and why</li>
<li>Deployment: add additional notes about how to deploy this on a live system</li>
<li>Built with</li>
<li>Contributing: please read CONTRIBUTING.md for details on our code of conduct, and the process for submitting pull requests to us.</li>
<li>Authors</li>
<li>License</li>
<li>Acknowledgemets</li>
</ul>

<hr/>

<p>中英文 readme 各写一份。</p>

                            
                        </div>
                    </div>
                </li>
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/2/16">2017/2/16</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14872260244406.html">Python Cookbook</a></h2>
                        <div itemprop="description">
                            
                                <h2 id="toc_0">调用父类的方法</h2>

<p><code>super()</code> 的常见用法：</p>

<ol>
<li>在 <code>__init__()</code> 方法中确保父类被正确初始化了</li>
<li>另外一个常见用法出现在覆盖 Python 特殊方法的代码中</li>
</ol>

<p>Ex:</p>

<pre><code class="language-python">class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith(&#39;_&#39;):
            super().__setattr__(name, value) # Call original __setattr__
        else:
            setattr(self._obj, name, value)
</code></pre>

<p>在上面代码中，<code>__setattr__()</code> 的实现包含一个名字检查。如果某个属性名以 <code>_</code> 开头，就通过 <code>super()</code> 调用原始的 <code>__setattr__()</code>，否则的话就委派给类内部的代理对象 <code>self._obj</code> 去处理。这看上去有点意思，因为就算没有显式指明某个类的父类，<code>super()</code> 仍然可以有效地工作。</p>

<h2 id="toc_1">子类中扩展 Property</h2>

<p>在自雷中扩展一个 property 可能会引起很多不易察觉的问题，因为一个 property 其实是 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法的几何，而不是单个的方法。因此，当你扩展一个 property 的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中的一个。</p>

<h2 id="toc_2">创建新的类或实例属性</h2>

<p>描述器：一个实现了三个核心的属性访问操作（get, set, delete）的类，分别为 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code> 这三个特殊的方法。这些方法接受一个实例作为输入，之后相应的操作实例实例底层的字典。</p>

<p>为了使用一个描述器，需要将这个描述器的实例作为类属性放到一个类的定义中。</p>

<p>一个基于描述器的高级代码：</p>

<pre><code class="language-python"># Descriptor for a type-checked attribute
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(&#39;Expected &#39; + str(self.expected_type))
        instance.__dict__[self.name] = value
    def __delete__(self, instance):
        del instance.__dict__[self.name]

# Class decorator that applies it to selected attributes
def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            # Attach a Typed descriptor to the class
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
</code></pre>

                            
                        </div>
                    </div>
                </li>
                
            </ul>
            <p class="paging">
                 
            </p>
        </div>
    </div>
</div>  <footer id="footer" class="yue">
    <div class="wrapper">
        <p>© Copyright 2014 - 2017 by <a href="https://twitter.com/Tisoga">@Tisoga</a> and powered by <a href="http://zh.mweb.im/">Mweb</a></p>
    </div>
</footer>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>
