<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Wiki]]></title>
  <link href="http://forresthcang.com/wiki/atom.xml" rel="self"/>
  <link href="http://forresthcang.com/wiki/"/>
  <updated>2017-10-07T21:04:20+08:00</updated>
  <id>http://forresthcang.com/wiki/</id>
  <author>
    <name><![CDATA[]]></name>
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>
  
  <entry>
    <title type="html"><![CDATA[S-表达式]]></title>
    <link href="http://forresthcang.com/wiki/15075210302691.html"/>
    <updated>2017-10-09T11:50:30+08:00</updated>
    <id>http://forresthcang.com/wiki/15075210302691.html</id>
    <content type="html">
<![CDATA[<p>S-表达式（其中 S 代表「符号的」）是一种以人类可读的文本形式表达半结构化数据的约定。S-表达式可能以其在 Lisp 家族的编程语言中的使用而为人所知。语法细节和所支持的数据类型虽淫语言而异，但这些语言件最通用的特性则是使用 S-表达式 作为括号化的前缀表示法。</p>

<p><img src="media/15075210302691/15075213452393.jpg" alt=""/></p>

<h2 id="toc_0">数据类型和语法</h2>

<p>S-表达式格式有多种变体，支持不同数据类型的各种不同语法。最广泛支持的是：</p>

<ul>
<li>列表和点对</li>
<li>符号</li>
<li>字符串</li>
<li>整数</li>
<li>浮点数</li>
</ul>

<h2 id="toc_1">在 Lisp 编程中的使用</h2>

<p>S-表达式在 Lisp 中即用作代码，也用作数据。</p>

<p>S-表达式可以是如数字这样的单个对象，包括特殊原子<code>nil</code>和<code>t</code>在内的 Lisp 原子，或写作<code>(x . y)</code>的 cons pair。更长的列表则有嵌套的 cons pair 组成，例如<code>(1 . (2 . (3 . nil)))</code>（亦可以写作更易理解的 <code>(1 2 3)</code>）。</p>

<p>使用前缀表示方法，程序代码课写作 S-表达式。书写 Lisp 程序中额外的语法糖规则是，一般的表达式<code>(quote x)</code>可以省略为<code>&#39;x</code>。</p>

<h3 id="toc_2">S-表达式的源码示例</h3>

<pre><code class="language-scheme">(define (factorial x)
    (if (zero? x) 1
          (* x (factorial (- x 1)))))
</code></pre>

<h2 id="toc_3">解析</h2>

<p>S-表达式经常与 XML 进行比较，一个关键的区别是 S-表达式在语法上要简单的多，因此更容易解析。</p>

<pre><code class="language-python"># 一个简单的 S-表达式解析器
def parse_sexp(string):
    &quot;&quot;&quot;
    &gt;&gt;&gt; parse_sexp(&quot;(+ 5 (+ 3 5))&quot;)
    [[&#39;+&#39;, &#39;5&#39;, [&#39;+&#39;, &#39;3&#39;, &#39;5&#39;]]]
    &quot;&quot;&quot;
    sexp = [[]]
    word = &#39;&#39;
    in_str = False
    for char in string:
        if char == &#39;(&#39; and not in_str:
            sexp.append([])
        elif char == &#39;)&#39; and not in_str:
            if word:
                sexp[-1].append(word)
                word = &#39;&#39;
            temp = sexp.pop()
            sexp[-1].append(temp)
        elif char in (&#39; &#39;, &#39;\n&#39;, &#39;\t&#39;) and not in_str:
            if word:
                sexp[-1].append(word)
                word = &#39;&#39;
        elif char = &#39;\&quot;&#39;:
            in_str = not in_str
        else:
            word += char
    return sexp[0]
</code></pre>

<hr/>

<p>S-表达式是二叉树的一种线性编码。</p>

<pre><code>原子 -&gt; 数字|符号
S表达式 -&gt; 原子|(S表达式 . S表达式)
</code></pre>

<p>书写 S-表达式，还要同时写很多「.」号，因此，Lisp 语言定义了一套 S-表达式的化简规则：</p>

<ol>
<li>如果一个点号右邻一个左括号，那么就可以将这个点号，左括号以及匹配的右括号一起去掉：<code>(a . (b . c))</code> &lt;==&gt; <code>(a b . c)</code></li>
<li>如果一个点号右邻原子 nil，那么就可以把这个点号和原子 nil 一起去掉：<code>(a . (b . nil))</code> &lt;<mark>&gt; <code>(a b . nil)</code> &lt;</mark>&gt; <code>(a b)</code></li>
</ol>

<p>列表是一种特殊类型的 S-表达式，如果一个 S-表达式不是原子，而且经过化简可以把点号都去掉，就说这个 S-表达式是一个列表。</p>

<p>例如：<code>(a .(b .(c . nil)))</code> &lt;==&gt; <code>(a b c)</code>。</p>

<p>为了使用方便，还允许有空表，而且还定义空表等价于原子 nil，空表的记法，使 nil 身兼三职：</p>

<ol>
<li>nil 表示一个原子</li>
<li>nil 表示空表</li>
<li>nil 表示逻辑值「假」</li>
</ol>

<p>nil 成为了 Lisp 语言中唯一的既是原子又是列表的表达式。</p>

<p>在 Scheme 中，它没有 nil 的概念，只有空表 <code>()</code>。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scheme 解释器相关笔记]]></title>
    <link href="http://forresthcang.com/wiki/15073552964811.html"/>
    <updated>2017-10-07T13:48:16+08:00</updated>
    <id>http://forresthcang.com/wiki/15073552964811.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">Scheme 程序的语法和语义</h2>

<ul>
<li>语法（syntax）：指的是字母排列成正确表达式或声明的顺序；</li>
<li>语义（semantics）：指的是这些表达式或声明的意义。</li>
</ul>

<p>Scheme 的语法非常简单：</p>

<ul>
<li>Scheme 程序中只有表达式，表达式和声明之间并无区别；</li>
<li>数字（例如 10）和符号（例如 A）被称为原子表达式（atomic expression），它们无法被拆分成更小的表达式。</li>
<li>除此以外的一切都是列表表达式（list expression）：以 <code>(</code> 为首，以 <code>)</code> 为尾，中间包括这零个或更多表达式。列表的第一个元素决定了它的含义：

<ul>
<li>若第一个元素是关键字，例如 <code>(if ...)</code>，那么这个列表是一个特殊形式（special form）；特殊形式的意义取决于关键字；</li>
<li>若第一个元素并非关键字，例如<code>(fn ...)</code>，那这个列表则是函数调用。</li>
</ul></li>
</ul>

<h2 id="toc_1">语言解释器做些什么</h2>

<p>一个计算机语言的解释器分为两部分：</p>

<ol>
<li>分析（parse）：解释器的分析部分将程序以一串字符串形式读入，依照语法规则（syntactic rules）验证其正确性并将程序转换成一种内部表达形式。在一个简单的解释器中，内部表达形式是一个树形结构，人们一般将其称为抽象语法树（abstract syntax tree）。抽象语法树的结构和程序中层层嵌套的声明及表达式非常接近，几乎可以说是完美对应。在编译器之中万网存在多个内部表达式，一开始先转换成抽象语法树，随后再转换成可以直接被计算器执行的指令序列。</li>
<li>执行（execution）：内部表达式被按照语言的语法规则进行处理，以此来进行计算。</li>
</ol>

<pre><code>程序 --&gt; [parser] --&gt; 抽象语法树 --&gt; [eval] --&gt; 结果
</code></pre>

<h3 id="toc_2">分析：parser, tokenize, read_from_tokens</h3>

<p>依照传统，分析被分成两个部分：</p>

<ol>
<li>词法分析（lexical analysis）：在这一部分中，输入的字符串被拆分为一系列的 token；</li>
<li>语法分析（syntactic analysis）：将 token 汇编为抽象语法树。</li>
</ol>

<h2 id="toc_3">环境（Environments）</h2>

<p>eval 函数接收两个参数：一个我们想要求值的表达式 x，还有一个环境 env，x 将在这个环境中被求值。环境指的是变量名和它们值之间的映射。eval 默认会使用全局环境（global environment）进行求值，全局环境包含着一系列的标准函数（比如 sqrt, max, * 这类操作符）。这一环境可以用用户定义的变量扩展，语法为<code>(define variable value)</code>。我们可以用 Python 自带的字典来实现环境，字典中的键对为 <code>{变量: 值}</code> 的形式。</p>

<h2 id="toc_4">Scheme 的语法规则</h2>

<table>
<thead>
<tr>
<th>表达式（Expression）</th>
<th>语法（Syntax）</th>
<th>语义（Semantics）和范例</th>
</tr>
</thead>

<tbody>
<tr>
<td>变量引用（variable reference）</td>
<td>var</td>
<td>该符号被认为是变量名；它的值是变量的值。</td>
</tr>
<tr>
<td>字面常量（constant literal）</td>
<td>number</td>
<td>一个数字（number）求值得到它自身。</td>
</tr>
<tr>
<td>条件（conditional）</td>
<td>(if test conseq alt)</td>
<td>对 test 进行求值；如果结果为真，对 conseq 进行求值并返回结果；否则对 alt 进行求值并返回结果。</td>
</tr>
<tr>
<td>定义（definition）</td>
<td>(define var exp)</td>
<td>定义一个新的变量，将 var 的值定义为 exp 求值得到的结果。</td>
</tr>
<tr>
<td>过程调用（procedure call）</td>
<td>(proc arg...)</td>
<td>如果 proc 不是 if/define/quote 其中之一，那它就被认为是一个过程（procedure）。对 proc 和所有的 args 求值，然后将 proc 过程应用于所有的 args 之上。</td>
</tr>
<tr>
<td>引用（quotation）</td>
<td>(quote exp)</td>
<td>直接按字面返回 exp，不对其进行求值。范例：(quote (+ 1 2)) --&gt; (+ 1 2)</td>
</tr>
<tr>
<td>赋值（assignment）</td>
<td>(set! var exp)</td>
<td>对 exp 进行求值并将结果赋值给 var，exp 必须在之前定义过（被 define 定义过或者是包含 set! 表达式的过程中的一个参数）</td>
</tr>
<tr>
<td>过程（procedure）</td>
<td>(lambda (var...) (exp))</td>
<td>创造一个过程，参数为 var...，exp为过程的主体，范例：(lambda (r) (* pi (* r r)))</td>
</tr>
</tbody>
</table>

<p>lambda 特殊形式会创建一个过程（procedure）：</p>

<pre><code class="language-scheme">&gt;&gt;&gt; (define circle-area (lambda (r) (* pi (* r r))))
&gt;&gt;&gt; (circle-area 10)
314.159265359
</code></pre>

<p>过程调用 (circle-area 10) 使我们队过程的主体部分 (* pi (* r r)) 进行求值。求值所在的环境中 pi 与 r 的值同全局环境相同，而 r 的值为 10.事实上，解释器并不会简单地在全局环境之中将 r 的值设为 10。如果我们将 r 用于其他用途会怎么样？我们不希望对 circle-area 的调用改变 r 的值，因此我们希望讲一个局部变量 r 设为 10，这样就不会影响到其他同名的变量。因此，我们需要构建一种新的环境，允许同时创建局部和全局变量。</p>

<p>想法如下：在我们对 <code>(circle-area 10)</code> 求值时，首先提取过程主体部分 <code>(* pi (* r r))</code>，随后在仅有一个本地变量 r 的环境中求值，但该环境同时也能访问全局环境。下图演示了这种环境模型，局部环境（蓝色）嵌套在全局环境（红色）之中：</p>

<p><img src="media/15073552964811/15073755364588.jpg" alt=""/></p>

<p>当我们在一个被嵌套的环境中查找变量时，首先在本层查找，如果没有找到对应值的话就到外一层查找。</p>

<pre><code class="language-python">class Procedure(object):
    &quot;用户定义的Scheme过程。&quot;
    def __init__(self, parms, body, env):
        self.parms, self.body, self.env = parms, body, env
    def __call__(self, *args): 
        return eval(self.body, Env(self.parms, args, self.env))

class Env(dict):
    &quot;环境是以{&#39;var&#39;:val}为键对的字典，它还带着一个指向外层环境的引用。&quot;
    def __init__(self, parms=(), args=(), outer=None):
        self.update(zip(parms, args))
        self.outer = outer
    def find(self, var):
        &quot;寻找变量出现的最内层环境。&quot;
        return self if (var in self) else self.outer.find(var)

global_env = standard_env()
</code></pre>

<p>我们看到每个过程有 3 个组成部分：一个包含变量名的列表，一个主体表达式，以及一个外层环境。外层环境使得我们在局部环境中无法找到变量时有下一个地方可以寻找。</p>

<p>环境是 dict 的子类，因此它含有 dict 拥有的所有方法。除此之外还有两个额外的方法：</p>

<ol>
<li>构造器 <code>__init__</code> 接受一个变量名列表以及对应的变量值列表，构造一个新环境，内部形式为 {variable: value} 键对，并拥有一个纸箱外层环境的引用；</li>
<li>find 函数用于找到某个变量所在的正确环境，可能是内层环境也可能是更外层的环境。</li>
</ol>

<p>要想知道这部分的工作原理，我们首先来看看 eval 的定义。注意，现在我们需要调用 env.find(x) 来寻找变量处于哪一层环境之中；随后我们才能从那一层环境中提取 x（define 分支的定义没有改变，因为 define 总是向最内一层的环境添加变量）。同时我们还增加了两个判定分支：set! 分支中，我们寻找变量所处的环境并将其设为新的值；通过 lambda，我们可以传入参数列表、主体以及环境以创建一个新的过程。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《流利的 Python》笔记]]></title>
    <link href="http://forresthcang.com/wiki/15058857487655.html"/>
    <updated>2017-09-20T13:35:48+08:00</updated>
    <id>http://forresthcang.com/wiki/15058857487655.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">第 17 章：使用 futures 处理并发</h2>

<blockquote>
<p>抨击线程的往往是系统程序员，他们考虑的使用场景对一般的应用程序员来说，也许一生都不会遇到……应用程序员遇到的使用场景，99% 的情况下只需知道如何派生一堆独立的线程，然后用队列收集结果。—— Michele Simionato</p>
</blockquote>

<p>本章主要讨论 Python 3.2 引入的 concurrent.futures 模块，这个库封装了前面引文中 Michele 所述的模式，特别易于使用。</p>

<p>这一章还会介绍 futures 的概念，futures 指一种对象，表示异步执行的操作。这个概念的作用很大，是 corcurrent.futures 模块和 asyncio 包的基础。</p>

<h3 id="toc_1">示例：网络下载的三种风格</h3>

<p>为了高效处理网络 I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费 CPU 周期去等待，最好在收到网络相应之前做些其他事情。</p>

<p>为了通过代码说明这一点，我写了三个示例程序：从网上下载 20 个国家的国旗图像。第一个示例程序 flag.py 是依序下载的：下载完一个图像，并将其保存在硬盘中之后，才请求下载下一个图像；另外两个脚本是并发下载的：几乎同时请求所有图像，每下载完一个文件就保存一个文件。flags_threadpool.py 脚本使用 concurrent.futures 模块，而 flags_asyncio.py 脚本是会用 asyncio 包。</p>

<h4 id="toc_2">依序下载的脚本</h4>

<pre><code class="language-python"># flags.py：依序下载的脚本；另外两个脚本会重用其中几个函数

import os
import time
import sys

import requests

POP20_CC = (&#39;CN IN US ID BR PK NG BD RU JP &#39;
            &#39;MX PH VN ET EG DE IR TR CD FR&#39;).split()

BASE_URL = &#39;http://flupy.org/data/flags&#39;

DEST_DIR = &#39;/Users/jiayuan/Downloads/&#39;


def save_flag(img, filename):
    path = os.path.join(DEST_DIR, filename)
    with open(path, &#39;wb&#39;) as fp:
        fp.write(img)
        

def get_flag(cc):
    url = &#39;{}/{cc}/{cc}.gif&#39;.format(BASE_URL, cc=cc.lower())
    resp = requests.get(url)
    return resp.content


def show(text):
    print(text, end=&#39; &#39;)
    sys.stdout.flush()
    
    
def download_many(cc_list):
    for cc in sorted(cc_list):
        image = get_flag(cc)
        show(cc)
        save_flag(image, cc.lower() + &#39;.gif&#39;)
    return len(cc_list)


def main(download_many):
    t0 = time.time()
    count = download_many(POP20_CC)
    elapsed = time.time() - t0
    msg = &#39;\n{} flags downloads in {:.2f}s&#39;
    print(msg.format(count, elapsed))
</code></pre>

<p>测试结果：</p>

<pre><code class="language-python">&gt;&gt;&gt; main(download_many)
BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 
20 flags downloads in 30.90s
</code></pre>

<h4 id="toc_3">使用 concurrent.futures 模块下载</h4>

<p>concurrent.futures 模块的主要特色是 ThreadPoolExecutor 和 ProcessPollExecutor 类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个雷子啊内部维护这一个工作线程或进程池，以及要执行的任务队列。不过，这个接口抽象层级很高，像下载国旗这种简单的案例，无需关心任何实现细节。</p>

<pre><code class="language-python"># flags_threadpool.py: 使用 futures.ThreadPoolExecutor 类实现多线程下载的脚本
from concurrent import futures

MAX_WORKERS = 20


def download_one(cc):
    image = get_flag(cc)
    show(cc)
    save_flag(image, cc.lower() + &#39;.gif&#39;)
    return cc


def download_many(cc_list):
    workers = min(MAX_WORKERS, len(cc_list))
    with futures.ThreadPoolExecutor(workers) as executor:
        res = executor.map(download_one, sorted(cc_list)) # 1
        
    return len(list(res)) # 2
</code></pre>

<p>测试结果：</p>

<pre><code class="language-python">&gt;&gt;&gt; main(download_many)
IN VN BD FR DE JP CN ID BR PH EG NG ET MX IR RU US CD PK TR 
20 flags downloads in 70.05s
</code></pre>

<p>关于这个示例的一些注解：</p>

<ul>
<li>1）map 方法的作用与内置的 map 函数类似，不过 download_one 函数会在多个线程中并发调用；map 方法返回一个生成器，因此可以迭代，获取各个函数返回的值。</li>
<li>2）返回获取的结果数量；如果有线程抛出异常，异常会在这里抛出，这与隐式调用 next() 函数从迭代器中获取相应的返回值一样</li>
</ul>

<h4 id="toc_4">futures 在哪里</h4>

<p>futures 是 concurrent.futures 模块和 asyncio 包的重要组件，作为这两个库的用户，我们有时却见不到 Future。</p>

<p>从 Python 3.4 起，标准库中有两个名为 futures 的类：concurrent.futures.Future 和 asyncio.Future。这两个类的作用相同：<strong>两个 futures 类的实例都表示可能已经完成或者尚未完成的延迟计算</strong>。这与 Twisted 引擎中的 Deferred 类、Tornado 框架中的 Future 类，以及多个 JavaScript 库中的 Promise 对象类似。</p>

<p><strong>futures 封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果（或抛出异常），后可以获取结果（或异常）</strong>。</p>

<p>我们要记住一件事：通常情况下自己不应该创建 futures，而只能由并发框架（concurrent.futures 或 asyncio）实例化。原因很简单：futures 表示终将发生的事情，而<strong>确定某件事会发生的唯一方式是执行的时间已经排定</strong>。因此，只有排定把某事件交给 concurrent.futures.Executor 子类处理时，才会创建 concurrent.futures.Future 实例。例如，Executor.submit() 方法的参数时一个可调用的对象，调用这个方法后会为传入的可调用对象排期，并返回一个 future。</p>

<p>客户端代码不应该改变 futures 的状态，并发框架在 future 表示的延迟计算结束后会改变 futures 的状态，而我们无法控制计算何时结束。</p>

<p>这两种 future 都有 .done() 方法，这个方法不阻塞，返回值是布尔值，指明 future 链接的可调用对象是否已经执行。客户端代码通常不会询问 future 是否运行结束，而是会等待通知。因此，两个 future 类都有 .add_done_callback() 方法：这个方法只有一个参数，类型是可调用的对象，futures 运行结束后会调用指定的可调用对象。</p>

<p>此外，还有 .result() 方法。在 Future 运行结束后调用的话，这个方法在两个 Future 类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。</p>

<p>但是，如果 Future 没有运行结束，result 方法在两个 Future 类中的行为相差很大。对于 concurrenct.futures.Future 实例来说，调用 f.result() 方法会阻塞调用方所在的线程，直到有结果可返回。此时，result 方法可以接收可选的 timeout 参数，如果在指定的时间内 Future 没有运行完毕，会抛出 TimeoutError 异常。asyncio.Future.result 方法不支持设定超时时间，在那个库中获取 Future 的结果最好使用 yield from 结构。不过，对 concurrent.futures.Future 实例不能这么做。</p>

<p>这两个库中有几个函数会返回 Future，其他函数则使用 Future，以用户易于理解的方式实现自身。使用 Executor.map 方法属于后者：返回值是一个迭代器，迭代器的 <code>__next__</code> 方法调用各个 Future 的 result 方法，因此我们得到的是各个 Future 的结果，而非 Future 本身。</p>

<p>为了从使用的角度理解 Future，我们可以使用 concurrent.futures.as_completed 函数重写上节的示例，这个函数的参数是一个 Future 列表，返回值是一个迭代器，在 Future 运行结束后产出 Future。</p>

<p>为了使用 futures.as_completed 函数，只需修改 download_many 函数，把较抽象的 executor.map 调用换成两个 for 循环：一个用于创建并排定 Future，另一个用于获取 Future 的结果。同时，我们会添加几个 print 调用，显式运行结束前后的 Future。</p>

<pre><code class="language-python"># flags_threadpool_ac.py: 把 download_many 函数中的 executor.map 方法换成 executor.submit 方法和 futures.as_completed 函数

def download_many(cc_list):
    cc_list = cc_list[:5]
    with futures.ThreadPoolExecutor(max_workers=3) as executor:
        to_do = []
        for cc in sorted(cc_list):
            future = executor.submit(download_one, cc)
            to_do.append(future)
            msg = &#39;Scheduled for {}: {}&#39;
            print(msg.format(cc, future))
            
        results = []
        for future in futures.as_completed(to_do):
            res = future.result()
            msg = &#39;{} result: {!r}&#39;
            print(msg.format(future, res))
            results.append(res)
    return len(results)
</code></pre>

<p>测试结果：</p>

<pre><code class="language-python">&gt;&gt;&gt; main(download_many)
Scheduled for BR: &lt;Future at 0x109a12be0 state=running&gt;
Scheduled for CN: &lt;Future at 0x109a12da0 state=running&gt;
Scheduled for ID: &lt;Future at 0x109a620f0 state=running&gt;
Scheduled for IN: &lt;Future at 0x1099b9710 state=pending&gt;
Scheduled for US: &lt;Future at 0x106ac29e8 state=pending&gt;
IDCN BR  &lt;Future at 0x109a12da0 state=finished returned str&gt; result: &#39;CN&#39;
&lt;Future at 0x109a620f0 state=finished returned str&gt; result: &#39;ID&#39;
&lt;Future at 0x109a12be0 state=finished returned str&gt; result: &#39;BR&#39;
IN &lt;Future at 0x1099b9710 state=finished returned str&gt; result: &#39;IN&#39;
US &lt;Future at 0x106ac29e8 state=finished returned str&gt; result: &#39;US&#39;

5 flags downloads in 3.81s
</code></pre>

<p>注意，在这个示例中调用 future.result() 方法绝不会堵塞，因为 future 由 as_completed 函数产出。</p>

<p>严格来说，我们目前测试的并发脚本都不能并行下载，使用 concurrent.futures 库实现的两个示例收到 GIL 的限制。</p>

<p>有个问题：既然 Python 线程受 GIL 的限制，任何时候都只允许运行一个线程，那个为什么 flags_threadpool.py 脚本的下载速度会比 flags.py 脚本快 5 倍？</p>

<h3 id="toc_5">阻塞型 I/O 和 GIL</h3>

<p>CPython 解释器本身就不是线程安全的，因此有全局解释器锁，一次只允许使用一个线程执行 Python 字节码。因此，一个 Python 进程通常不能同时使用多个 CPU 核心（语言无关，解释器相关）。</p>

<p>编写 Python 代码时无法控制 GIL，不过，执行耗时的任务时，可以使用一个内置的函数或一个使用 C 语言编写的扩展释放 GIL。</p>

<p>然而，标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放 GIL。这意味着在 Python 语言这个层次上可以使用多线程，而 IO 密集型 Python 程序能从中受益：一个 Python 线程等待网络响应时，阻塞型 IO 函数会释放 GIL，再运行一个线程。</p>

<p>Python 标准库中所有阻塞型 IO 函数都会释放 GIL，允许其他线程运行。因此，尽管有 GIL，Python 线程还是能在 IO 密集型应用中发挥作用。</p>

<p>下面加单说明如何在 CPU 密集型作业中使用 concurrent.futures 模块轻松绕开 GIL。</p>

<h3 id="toc_6">使用 concurrent.futures 模块启动进程</h3>

<p>concurrent.futures 模块实现的是真正的并行计算，因为它使用 ProcessPoolExecutor 类把工作分配给多个 Python 进程处理，因此，如果需要做 CPU 密集型处理，使用这个模块能绕开 GIL，利用所有可用的 CPU 核心。</p>

<p>ProcessPoolExecutor 和 ThreadPoolExecutor 类都实现了通用的 Executor 接口，因此使用 concurrent.futures 模块能轻松地把基于线程的方案转换成基于进程的方案。</p>

<p>下载国旗的示例或其他 IO 密集型作业使用 ProcessPoolExecutor 类得不到任何好处，因为对于 CPU 密集型的处理来说，不吭呢要求使用超过 CPU 数量的进程，而对于 IO 密集型来说，可以在一个 ThreadPoolExecutor 实例中使用 10 个、100 个或 1000 个线程，最佳线程数取决于做的是什么事，以及可用内存是多少，因此要自习测试才能找到最佳的线程数。</p>

<p>ProcessPoolExecutor 的价值体现在 CPU 密集型作业上。有两个 CPU 密集型的脚本：</p>

<ul>
<li>arcfour_futures.py: 这个脚本纯粹使用 Python 实现 RC4 算法；</li>
<li>sha_futures.py: 这个脚本使用标准库中的 haslib 模块（使用 OpenSSL 库实现）实现 SHA-256 算法。</li>
</ul>

<p>这两个脚本除了显示汇总结果外，没有使用 IO，测试的结果如下：</p>

<p><img src="media/15058857487655/15063175994496.jpg" alt=""/></p>

<p>可以看出，对加密算法来说，使用 ProcessPoolExecutor 类派生 4 个工作进程后（如果有 4 个 CPU 核心的话），性能可能提高两倍。</p>

<p>如果使用 Python 处理 CPU 密集型工作，应该试试 PyPy，使用 PyPy 运行上面脚本，速度快乐 3.8~5.1 倍。</p>

<h3 id="toc_7">实现 Executor.map 方法</h3>

<p>下面通过一个演示程序来研究线程池的行为，这个程序会创建一个包含 3 个 worker 的线程池，运行 5 个可调用对象，输出带有时间戳的消息。</p>

<p>若想并发运行多个可调用对象，最简单的方式是使用 Executor.map 方法。Executor.map 函数易于使用，不过有个特性可能有用，也可能没用，具体情况取决于需求：这个函数返回结果的顺序与调用开始的顺序一致。如果第一个调用生成结果用时 10 秒，而其他调用只用 1 秒，代码会阻塞 10 秒，获取 map 方法返回的生成器产出的第一个结果。在此之后，获取后续结果时不会阻塞，因为后续的调用已经结束。如果必须等到获取所有结果后再处理，这种行为没有问题；不过，通常更可取的做法是，不管提交的顺序，只要有结果就获取。为此，要把 Executor.submit 方法和 futures.as_completed 函数结合起来使用。</p>

<p>executor.submit 和 futures.as_completed 这个组合比 executor.map 更灵活，因为 submit 方法能处理不同的可调用对象和参数，而 executor.map 只能处理参数不同的同一个可调用对象。此外，传给 futures.as_completed 函数的 futres 集合可以来自多个 Executor 实例，例如一些由 ThreadPoolExecutor 实例创建，另一些由 ProcessPoolExecutor 实例创建。</p>

<h3 id="toc_8">显示下载进度并处理错误</h3>

<p>之前的示例脚本中没有处理错误，这么做是为了便于阅读和比较三种方案（依序、多线程和异步）的结构。</p>

<p>这三个示例在负责下载一个文件的函数（download_one）中使用相同的策略处理 HTTP 404 错误，其他异常则向上冒泡，交给 download_many 函数处理。</p>

<pre><code class="language-python"># flags2_sequential.py: 负责下载的基本函数；flags2_threadpool.py 脚本重用了这两个函数

def get_flag(base_url, cc):
    url = &#39;{}/{cc}.gif&#39;.format(base_url, cc=cc.lower())
    resp = requests.get(url)
    if resp.status_code != 200:
        resp.raise_for_status()
    return resp.content


def download_one(cc, base_url, verbose=False):
    try:
        image = get_flag(base_url, cc)
    except requests.exceptions.HTTPError as exc:
        res = exc.response
        if res.status_code == 404:
            status = HTTPSatus.not_fount
            msg = &#39;not found&#39;
        else:
            raise
    else:
        save_flag(image, cc.lower() + &#39;.gif&#39;)
        status = HTTPStatus.ok
        msg = &#39;OK&#39;
        
    if verbose:
        print(cc, msg)
        
    return Result(status, cc)
</code></pre>

<p>Python 线程特别适合 IO 密集型应用，concurrent.futures 模块大大简化了某些使用场景下 Python 线程的用法。下面讨论不适合使用 ThreadPoolExecutor 或 ProcessPoolExecutor 类时，有哪些替代方案。</p>

<h3 id="toc_9">杂谈</h3>

<p>concurrent.futures 包把线程、进程和队列视作服务的基础设施，不用自己动手直接处理。当然，这个包针对的是简单的作业，也就是所谓的「高度并行」问题，编写应用（而非操作系统或数据库服务器）时，遇到的大部分并发问题都属于这一种。</p>

<p>GIL 简化了了 CPython 解释器和 C 语言扩展的实现，得益于 GIL，Python 有很多 C 语言扩展。GIL 并不会导致 Python 线程没有用武之地，因为标准库中每一个阻塞型 IO 函数都会释放 GIL，Python 线程特别适合在 IO 密集型系统中使用。</p>

<h2 id="toc_10">第 18 章：使用 asyncio 包处理并发</h2>

<blockquote>
<p>并发是指一次处理多件事；<br/>
并行是指一次做多件事；<br/>
二者不同，但是有联系；<br/>
一个关于结构，一个关于执行；<br/>
并发用于制定方案，用来解决可能并行的问题。<br/>
—— Rob Pike（Go 语言的创造者之一）</p>
</blockquote>

<p>真正的并行需要多个核心。现代的笔记本电脑有 4 个 CPU 核心，但是通常不经意间就有超过 100 个进程同时运行。因此，实际上大多数过程都是并发处理的，而不是并行处理。</p>

<p>本章介绍 asyncio 包，这个包使用事件循环驱动的协程实现并发。asyncio 大量使用 yield from 表达式，因此与 Python 旧版不兼容。</p>

<p>本章讨论以下话题：</p>

<ul>
<li>对比一个简单的多线程程序和对应的 asyncio 版，说明多线程和异步任务之间的关系</li>
<li>asyncio.Futures 类与 concurrent.futures.Future 类之间的区别</li>
<li>第 17 章中下载国旗的那些示例的异步版</li>
<li>摒弃线程或进程，如何使用异步编程管理网络应用中的高并发</li>
<li>在异步编程中，与回调相比，协程显著提升性能的方式</li>
<li>如何把阻塞的操作交给线程池处理，从而避免阻塞事件循环</li>
<li>使用 asyncio 编写服务器，重新审视 Web 应用对高并发的处理方式</li>
<li>为什么 asyncio 已经准备好了对 Python 生态系统产生重大影响</li>
</ul>

<h3 id="toc_11">线程与协程对比</h3>

<p>有一次讨论线程和 GIL 时，Michele Simionato 发布了一个简单但有趣的示例：在长时间计算的过程中，使用 multiprocessing 包在控制台中显示一个由 ASCII 字符「\/-\」构成的动画旋转指针。</p>

<p>我们改写了 Simionato 的示例，一个借由 threading 模块使用线程实现，一个借由 asyncio 包使用协程实现。我们这么做是为了让你对比两种实现，理解如何不使用线程来实现并发行为。</p>

<pre><code class="language-python"># spinner_thread.py: 通过线程以动画形式显示文本格式旋转指针
import threading
import itertools
import time
import sys


class Signal:
    go = True


def spin(msg, signal):
    write, flush = sys.stdout.write, sys.stdout.flush
    for char in itertools.cycle(&#39;|/-\\&#39;):
        status = char + &#39; &#39; + msg
        write(status)
        flush()
        write(&#39;\x08&#39; * len(status))  # 这是显示文本动画的诀窍所在：使用退格符（\x08）把光标移回来
        time.sleep(.1)
        if not signal.go:
            break
    write(&#39; &#39; * len(status) + &#39;\x08&#39; * len(status))  # 使用空格键清除状态信息，把光标移回开头


def slow_function():
    # 假装等待 I/O 一段时间
    time.sleep(3)  # 调用 sleep 函数会阻塞主线程，不过一定哟啊这么做，以便释放 GIL，创建从属线程
    return 42


def supervisor():
    signal = Signal()
    spinner = threading.Thread(
        target=spin,
        args=(&#39;thinking&#39;, signal)
    )
    print(&#39;spinner object: &#39;, spinner)
    spinner.start()
    result = slow_function()
    signal.go = False
    spinner.join()
    return result


def main():
    result = supervisor()
    print(&#39;Answer: &#39;, result)


if __name__ == &#39;__main__&#39;:
    main()

</code></pre>

<p>注意，Python 没有提供终止线程的 API，这是有意为之的。若想关闭线程，必须给线程发送消息。这里我们使用的是 signal.go 属性：在主线程中把它设置为 False 后，spinner 线程最终会注意到，然后干净地退出。</p>

<p>下面来看如何使用 @asyncio.coroutine 装饰器替代线程，实现相同的行为。asyncio 包使用的「协程」是较严格的定义。适合 asyncio API 的协程在定义体中必须使用 yield from，而不能使用 yield。此外，适合 asyncio 的协程要由调用方驱动，并由调用方通过 yield from 调用；或者把协程传给 asyncio 包中的某个函数，例如 asyncio.async(...) 和本章要介绍的其他函数，从而驱动协程。最后，@asyncio.coroutine 装饰器应该用在协程上，如下述示例所示。</p>

<pre><code class="language-python"># spinner_asyncio.py: 通过协程以动画形式显示文本式旋转指针
import asyncio
import itertools
import sys


@asyncio.coroutine
def spin(msg):
    write, flush = sys.stdout.write, sys.stdout.flush
    for char in itertools.cycle(&#39;|/-\\&#39;):
        status = char + &#39; &#39; + msg
        write(status)
        flush()
        write(&#39;\x08&#39; * len(status))
        try:
            yield from asyncio.sleep(.1)
        except asyncio.CancelledError:
            break
    write(&#39; &#39; * len(status) + &#39;\x08&#39; * len(status))


@asyncio.coroutine
def slow_function():
    # 假装等待 I/O 一段时间
    yield from asyncio.sleep(3)
    return 42


@asyncio.coroutine
def supervisor():
    spinner = asyncio.async(spin(&#39;thinking!&#39;))
    print(&#39;spinner object: &#39;, spinner)
    result = yield from slow_function()
    spinner.cancel()
    return result


def main():
    loop = asyncio.get_event_loop()
    result = loop.run_until_complete(supervisor())
    loop.close()
    print(&#39;Answer: &#39;, result)


if __name__ == &#39;__main__&#39;:
    main()

</code></pre>

<p>若非想阻塞主线程，从而冻结事件循环或整个应用，否则不要在 asyncio 协程中使用 time.sleep(...)。如果协程需要在一段时间内什么也不做，应该使用 yield from asyncio.sleep(DELAY)。</p>

<p>使用 @asyncio.coroutine 装饰器不是强制要求，但是强烈建议这么做，因为这样能在一众普通的函数中把协程凸显出来，也有助于调试：如果还没从中产出值，协程就被垃圾回收了（意味着有操作未完成，因此有可能是个缺陷），那就可以发出警告。<strong>这个装饰器不会预激协程。</strong></p>

<p>上面两个例子中的 supervisor 实现之间的主要区别概述如下：</p>

<ul>
<li>asyncio.Task 对象差不多与 threading.Thread 对象等效，「Task 对象像是实现协作式多任务库（如 gevent）中的绿色线程（green thread）」。</li>
<li>Task 对象用于驱动协程，Thread 对象用于调用可调用的对象。</li>
<li>Task 对象不由自己手动实例化，而是通过把协程传给 asyncio.async(...) 函数或 loop.create_task(...) 方法获取。</li>
<li>获取的 Task 对象已经排定了运行时间；Thread 实例则必须调用 start 方法，明确告知让它运行。</li>
<li>在线程版 supervisor 函数中，slow_function 函数是普通的函数，直接由线程调用。在异步版 supervisor 函数中，slow_function 函数时协程，由 yield from 驱动。</li>
<li>没有 API 能从外部终止线程，因为线程随时可能被终端，导致系统处于无效状态。如果想终止任务，可以使用 Task.cancel() 实例方法，在协程内部抛出 CancelledError 异常。协程可以在暂停的 yield 处捕获这个异常，处理终止请求。</li>
<li>supervisor 协程必须在 main 函数中由 loop.run_until_complete 方法执行。</li>
</ul>

<p>使用线程编程，因为调度程序任何时候都能终端线程，所以必须记住保留锁，去保护程序中的重要部分，防止多步操作在执行的过程中终端，防止数据处于无效状态。而协程默认会做好全方位保护，以防止中断。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 面试笔记]]></title>
    <link href="http://forresthcang.com/wiki/14892052747708.html"/>
    <updated>2017-03-11T12:07:54+08:00</updated>
    <id>http://forresthcang.com/wiki/14892052747708.html</id>
    <content type="html">
<![CDATA[<ul>
<li>
<a href="#toc_0">Python 语言特性</a>
<ul>
<li>
<a href="#toc_1">Python 的函数参数传递</a>
</li>
<li>
<a href="#toc_2">Python 中的元类</a>
</li>
<li>
<a href="#toc_3">@staticmethod 和 @classmethod</a>
</li>
<li>
<a href="#toc_4">类变量和实例变量</a>
</li>
<li>
<a href="#toc_5">Python 自省</a>
</li>
<li>
<a href="#toc_6">字典推导式</a>
</li>
<li>
<a href="#toc_7">Python 中单下划线与双下划线的区别</a>
</li>
<li>
<a href="#toc_8">迭代器和生成器</a>
</li>
<li>
<a href="#toc_9"><code>*args</code> 和 <code>**kwargs</code></a>
</li>
<li>
<a href="#toc_10">面向切面编程 AOP 和装饰器</a>
</li>
<li>
<a href="#toc_11">鸭子类型</a>
</li>
<li>
<a href="#toc_12">Python 中的重载</a>
</li>
<li>
<a href="#toc_13">新式类和旧式类</a>
</li>
<li>
<a href="#toc_14"><code>__new__</code> 和 <code>__init__</code></a>
</li>
<li>
<a href="#toc_15">单例模式</a>
<ul>
<li>
<a href="#toc_16">什么是单例模式</a>
</li>
<li>
<a href="#toc_17">1. 使用 <code>__new__</code> 方法</a>
</li>
<li>
<a href="#toc_18">2. 共享属性</a>
</li>
<li>
<a href="#toc_19">3. 装饰器版本</a>
</li>
<li>
<a href="#toc_20">4. import 方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">Python 中的作用域</a>
</li>
<li>
<a href="#toc_22">GIL 线程全局锁</a>
</li>
<li>
<a href="#toc_23">协程</a>
</li>
<li>
<a href="#toc_24">闭包</a>
</li>
<li>
<a href="#toc_25">lambda 函数</a>
</li>
<li>
<a href="#toc_26">Python 函数式编程</a>
</li>
<li>
<a href="#toc_27">Python 里的拷贝</a>
</li>
<li>
<a href="#toc_28">Python 垃圾回收机制</a>
<ul>
<li>
<a href="#toc_29">1. 引用计数</a>
</li>
<li>
<a href="#toc_30">2. 「标记-清除」机制</a>
</li>
<li>
<a href="#toc_31">3. 分代技术</a>
</li>
</ul>
</li>
<li>
<a href="#toc_32">Python 中 list 的实现</a>
</li>
<li>
<a href="#toc_33">Python 的 is</a>
</li>
<li>
<a href="#toc_34">read/readline/readlines</a>
</li>
<li>
<a href="#toc_35">Python 2 和 3 的区别</a>
</li>
</ul>
</li>
<li>
<a href="#toc_36">操作系统</a>
<ul>
<li>
<a href="#toc_37">select、poll 和 epoll</a>
</li>
<li>
<a href="#toc_38">调度算法</a>
</li>
<li>
<a href="#toc_39">死锁</a>
</li>
<li>
<a href="#toc_40">程序的编译和链接</a>
</li>
<li>
<a href="#toc_41">静态链接和动态链接</a>
</li>
<li>
<a href="#toc_42">虚拟内存技术</a>
</li>
<li>
<a href="#toc_43">分页和分段</a>
</li>
<li>
<a href="#toc_44">页面置换算法</a>
</li>
<li>
<a href="#toc_45">边缘触发和水平触发</a>
</li>
</ul>
</li>
<li>
<a href="#toc_46">数据库</a>
<ul>
<li>
<a href="#toc_47">事务</a>
</li>
<li>
<a href="#toc_48">数据库索引</a>
</li>
<li>
<a href="#toc_49">Redis 原理</a>
</li>
<li>
<a href="#toc_50">乐观锁和悲观锁</a>
</li>
</ul>
</li>
<li>
<a href="#toc_51">网络</a>
<ul>
<li>
<a href="#toc_52">ARP 协议</a>
</li>
<li>
<a href="#toc_53">POST 和 GET</a>
</li>
<li>
<a href="#toc_54">Cookie 和 Session</a>
</li>
<li>
<a href="#toc_55">Apache 和 Nginx 的区别</a>
</li>
<li>
<a href="#toc_56">网站用户密码保存</a>
</li>
<li>
<a href="#toc_57">HTTP 和 HTTPS</a>
</li>
<li>
<a href="#toc_58">XSRF 和 XSS</a>
</li>
<li>
<a href="#toc_59">CGI 和 WSGI</a>
</li>
<li>
<a href="#toc_60">中间人攻击</a>
</li>
<li>
<a href="#toc_61">CK10 问题</a>
</li>
<li>
<a href="#toc_62">Ajax</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">Python 语言特性</h2>

<h3 id="toc_1">Python 的函数参数传递</h3>

<p>所有的变量都可以理解为内存中一个对象的引用。</p>

<p>类型是属于对象的，而不是变量。而对象有两种，「可更改」（mutable） 与「不可更改」（inmutable） 对象。==在 Python 中，strings, tuples, numbers 是不可更改的对象，list, dict 则是可以更改的对象。</p>

<p>当一个引用传递给函数的时候，函数自动复制一份引用，这个函数里的引用就和外部的引用没有关系了。而在函数内的引用指向的是可变对象的时候，对它的操作就和定位了指针地址一样，可以直接在内存里进行修改。</p>

<p>参考阅读：<a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>

<h3 id="toc_2">Python 中的元类</h3>

<p>ORM 中会用到。</p>

<p>详细的解释：<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>

<h3 id="toc_3">@staticmethod 和 @classmethod</h3>

<p>Python 有三个方法：即静态方法（staticmethod）、类方法（classmethod）和实例方法。</p>

<pre><code class="language-python">def foo(x):
    print &quot;executing foo(%s)&quot;%(x)

class A(object):
    def foo(self,x):
        print &quot;executing foo(%s,%s)&quot;%(self,x)

    @classmethod
    def class_foo(cls,x):
        print &quot;executing class_foo(%s,%s)&quot;%(cls,x)

    @staticmethod
    def static_foo(x):
        print &quot;executing static_foo(%s)&quot;%x

a=A()
</code></pre>

<p><code>self</code> 和 <code>cls</code> 是对类或者实例的绑定。对于一般的函数我们可以这么调用 <code>foo(x)</code>，这个函数就是最常用的，它的工作和任何东西（类、实例）无关。对于实例方法，我们知道在类中每次定义方法都需要绑定这个实例，即 <code>foo(self, x)</code> ，因为实例方法的调用离不开实例，我们需要把实例自己传给函数，调用的时候是这样的 <code>a.foo(x)</code>（其实是 <code>foo(a, x)</code>）。类方法一样，只不过它传递的是类而不是实例，<code>A.class_foo(x)</code>。注意这里的 self 和 cls 可以替换成别的参数，但是 Python 的约定就是这两个，所以还是不要改比较好。</p>

<p>对于静态方法其实和普通方法一样，不需要对谁进行绑定，唯一的区别就是需要使用 <code>a.static_foo(x)</code> 或者 <code>A.static_foo(x)</code> 这样的方式来调用。</p>

<table>
<thead>
<tr>
<th></th>
<th>实例方法</th>
<th>类方法</th>
<th>静态方法</th>
</tr>
</thead>

<tbody>
<tr>
<td>a = A()</td>
<td>a.foo(x)</td>
<td>a.class_foo(x)</td>
<td>a.static_foo(x)</td>
</tr>
<tr>
<td>A</td>
<td>不可用</td>
<td>A.class_foo(x)</td>
<td>A.static_foo(x)</td>
</tr>
</tbody>
</table>

<p>详细讨论：<a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></p>

<h3 id="toc_4">类变量和实例变量</h3>

<pre><code class="language-python">class Person:
    name=&quot;aaa&quot;

p1=Person()
p2=Person()
p1.name=&quot;bbb&quot;
print p1.name  # bbb
print p2.name  # aaa
print Person.name  # aaa
</code></pre>

<p>类变量就是供类使用的变量，实例变量就是供实例使用的。</p>

<p>这里的 <code>p1.name=&quot;bbb&quot;</code> 是实例调用了类变量，这和上面的一个问题一样，就是函数传参的问题，<code>p1.name</code> 一开始指向的是类变量 <code>Person.name</code>，但在实例的作用域里把类变量的引用改变了，就变成了一个实例变量。</p>

<p>可以对比一下下面这个例子：</p>

<pre><code class="language-python">class Person:
    name=[]

p1=Person()
p2=Person()
p1.name.append(1)
print p1.name  # [1]
print p2.name  # [1]
print Person.name  # [1]
</code></pre>

<p>参考：<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>

<h3 id="toc_5">Python 自省</h3>

<p>自省就是面向对象的语言所写的程序在运行时，所能知道对象的类型。简单讲就是运行时能够获得对象的类型，比如 <code>type()</code>, <code>dir()</code>, <code>getattr()</code>, <code>hasattr()</code>, <code>isinstance()</code>。</p>

<h3 id="toc_6">字典推导式</h3>

<p>2.7 中加入的内容。</p>

<pre><code class="language-python">d = {key: value for (key, value) in iterable}
</code></pre>

<h3 id="toc_7">Python 中单下划线与双下划线的区别</h3>

<pre><code class="language-python">&gt;&gt;&gt; class MyClass():
...     def __init__(self):
...             self.__superprivate = &quot;Hello&quot;
...             self._semiprivate = &quot;, world!&quot;
...
&gt;&gt;&gt; mc = MyClass()
&gt;&gt;&gt; print mc.__superprivate
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: myClass instance has no attribute &#39;__superprivate&#39;
&gt;&gt;&gt; print mc._semiprivate
, world!
&gt;&gt;&gt; print mc.__dict__
{&#39;_MyClass__superprivate&#39;: &#39;Hello&#39;, &#39;_semiprivate&#39;: &#39;, world!&#39;}
</code></pre>

<ul>
<li><code>__foo__</code>：一种约定，Python 内部的名字，用来区别其他用户自定义的命名，以防冲突</li>
<li><code>_foo</code>：一种约定，用来指定变量是私有变量</li>
<li><code>__foo</code>：解析器用 <code>_classname__foo</code> 来代替这个名字，以区别和其他类相同的命名。</li>
</ul>

<p>参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></li>
<li><a href="http://www.zhihu.com/question/19754941">http://www.zhihu.com/question/19754941</a></li>
</ul>

<h3 id="toc_8">迭代器和生成器</h3>

<p>详细解释：<a href="https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html">https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p>

<h3 id="toc_9"><code>*args</code> 和 <code>**kwargs</code></h3>

<p>使用 <code>*args</code> 和 <code>**kwargs</code> 只是为了方便，并没有强制使用它们。</p>

<p>当你不确定函数中将要传入多少个参数时可以使用 <code>*args</code> ，它可以传递任意数量的参数。</p>

<p><code>**kwargs</code> 允许你使用事先未定义的参数名。</p>

<p>你也可混着使用，命名参数首先获得参数值，然后其他所有的参数都传给 <code>*args</code> 和 <code>**kwargs</code>。命名参数在列表的最前端：</p>

<pre><code class="language-python">def table_things(titlestring, **kwargs)
</code></pre>

<p><code>*args</code> 和 <code>**kwargs</code> 可以同时在函数的定义中，但是 <code>*args</code> 必须在 <code>**kwargs</code> 前面。</p>

<p>在调用函数时也可以使用 <code>*</code> 和 <code>**</code> 语法，例如：</p>

<pre><code class="language-python">&gt;&gt;&gt; def print_three_things(a, b, c):
...     print &#39;a = {0}, b = {1}, c = {2}&#39;.format(a,b,c)
...
&gt;&gt;&gt; mylist = [&#39;aardvark&#39;, &#39;baboon&#39;, &#39;cat&#39;]
&gt;&gt;&gt; print_three_things(*mylist)

a = aardvark, b = baboon, c = cat
</code></pre>

<p>它可以传递列表（或元组）并将它们解包。注意必须与它们在函数中的参数相吻合</p>

<p>参考：<a href="http://stackoverflow.com/questions/3394835/args-and-kwargs">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>

<h3 id="toc_10">面向切面编程 AOP 和装饰器</h3>

<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数本身无关的雷同代码并继续重用。概括来讲，<mark>装饰器的作用就是为已经存在的对象添加额外的功能</mark>。</p>

<p>详细参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></li>
<li><a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></li>
<li><a href="https://www.zhihu.com/question/24863332">https://www.zhihu.com/question/24863332</a></li>
</ul>

<p>什么是 AOP：</p>

<blockquote>
<p>面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。<br/><br/>
但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。<br/><br/>
也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<mark>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</mark><br/><br/>
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br/><br/>
AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。</p>
</blockquote>

<h3 id="toc_11">鸭子类型</h3>

<blockquote>
<p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p>
</blockquote>

<p>我们不关心对象是什么类型，到底是不是鸭子，只关心行为。</p>

<p>比如在 Python 中，有很多 file-like 的东西，StringIO/GzipFile/socket。它们有很多相同的方法，我们把它们都当做文件使用。</p>

<p>鸭子类型在动态语言中经常使用，非常灵活。使得 Python 不必像 Java 那样专门弄一堆设计模式。</p>

<h3 id="toc_12">Python 中的重载</h3>

<p><mark>Python 不支持函数重载</mark>。</p>

<p>函数重载主要是为了解决两个问题：</p>

<ul>
<li>可变参数类型</li>
<li>可变参数个数</li>
</ul>

<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数其实功能不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>

<p>对于情况 1，函数功能相同，但参数类型不同， 在 Python 中根本不需要处理，因为 Python 可以接受任何类型的参数，如果函数功能相同，那么不同的参数类型在 Python 中很可能是相同的代码，没有必要写成两个不同的函数。</p>

<p>对于情况 2，函数功能相同，但参数个数不同，Python 中处理的方式是使用缺省参数。对那些缺少的参数设定为缺省参数即可。</p>

<p>鉴于情况 1 和情况 2 Python 都有解决方案，所以就不需要重载了。</p>

<p>但是 Python 也可以实现重载的功能。</p>

<p>参考：<a href="http://www.zhihu.com/question/20053359">http://www.zhihu.com/question/20053359</a></p>

<h3 id="toc_13">新式类和旧式类</h3>

<p>详细参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python</a></li>
<li><a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></li>
</ul>

<h3 id="toc_14"><code>__new__</code> 和 <code>__init__</code></h3>

<ul>
<li><code>__new__</code> 是一个静态方法，而 <code>__init__</code> 是一个实例方法</li>
<li><code>__new__</code> 方法会返回一个创建的实例，而 <code>__init__</code> 什么都不返回</li>
<li>只有在 <code>__new__</code> 返回一个 cls 实例时后面的 <code>__init__</code> 才能被调用</li>
<li>当创建一个新实例时调用 <code>__new__</code>，初始化一个实例时用 <code>__init__</code></li>
</ul>

<p>参考：<a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init">http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init</a></p>

<h3 id="toc_15">单例模式</h3>

<p>Important！</p>

<h4 id="toc_16">什么是单例模式</h4>

<p>单例模式，也叫单子模式，是一种常用的软件设计模式。<mark>在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</mark>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>

<p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>

<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>

<h4 id="toc_17">1. 使用 <code>__new__</code> 方法</h4>

<pre><code class="language-python">class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, &#39;_instance&#39;):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1
</code></pre>

<h4 id="toc_18">2. 共享属性</h4>

<p>创建实例时把所有实例的 <code>__dict__</code> 指向同一个字典，这样它们具有相同的属性和方法。</p>

<pre><code class="language-python">class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1
</code></pre>

<h4 id="toc_19">3. 装饰器版本</h4>

<pre><code class="language-python">def singleton(cls, *args, **kw):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance

@singleton
class MyClass:
  ...
</code></pre>

<h4 id="toc_20">4. import 方法</h4>

<pre><code class="language-python"># mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()

# to use
from mysingleton import my_singleton

my_singleton.foo()
</code></pre>

<p>作为 Python 的模块是天然的单例方法。</p>

<h3 id="toc_21">Python 中的作用域</h3>

<p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>

<p>当 Python 遇到一个变量的话它会按照如下顺序进行搜索：</p>

<p>本地作用域（Local） -&gt; 当前作用域没嵌入的作用域（Enclosing locals） -&gt; 全局/模块作用域（Global） -&gt; 内置作用域（Built-in）</p>

<h3 id="toc_22">GIL 线程全局锁</h3>

<p>线程全局锁（Global Interpreter Lock），即 Python 为了保证线程安全而采取的独立线程运行的机制，说白了就是一个核只能在同一时间运行一个线程。</p>

<p>解决办法就是多进程和下面的协程（协程也只是单 CPU，但能减小切换代价提升性能）。</p>

<p>参考：<a href="http://www.oschina.net/translate/pythons-hardest-problem">http://www.oschina.net/translate/pythons-hardest-problem</a></p>

<h3 id="toc_23">协程</h3>

<p>待补充</p>

<h3 id="toc_24">闭包</h3>

<p>闭包（Closure）是函数式编程中的重要语法结构。</p>

<p><mark>当一个内嵌函数引用其外部作用域的变量，我们就会得到一个闭包。</mark> 创建一个闭包必须满足以下几点：</p>

<ul>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ul>

<h3 id="toc_25">lambda 函数</h3>

<p>Python 中的 lambda 函数即匿名函数。</p>

<p>参考：<a href="https://www.zhihu.com/question/20125256">https://www.zhihu.com/question/20125256</a></p>

<h3 id="toc_26">Python 函数式编程</h3>

<p>详细参考：<a href="http://coolshell.cn/articles/10822.html">http://coolshell.cn/articles/10822.html</a></p>

<h3 id="toc_27">Python 里的拷贝</h3>

<p>引用和 <code>copy()</code>, <code>deepcopy()</code> 的区别：</p>

<pre><code class="language-python">import copy
a = [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append(&#39;c&#39;)  #修改对象a中的[&#39;a&#39;, &#39;b&#39;]数组对象

print &#39;a = &#39;, a
print &#39;b = &#39;, b
print &#39;c = &#39;, c
print &#39;d = &#39;, d

输出结果：
a =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5]
b =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5]
c =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]
d =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]]
</code></pre>

<h3 id="toc_28">Python 垃圾回收机制</h3>

<p>Python GC 主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用基础上，通过「标记-清除」（mark and sweep）解决容器对象可能产生的循环引用问题，通过「分代回收」（generation collection）以空间换时间的方法提高垃圾回收效率。</p>

<h4 id="toc_29">1. 引用计数</h4>

<p>PyObject 是每个对象必有的内容，其中，<code>ob_refcnt</code> 就是作为引用计数。当一个对象有新的引用时，它的 <code>ob_refcnt</code> 就会增加，当引用它的对象呗删除，它的 <code>ob_refcnt</code> 就会减少。引用计数为 0 时，该对象的生命就结束了。</p>

<p>优点：</p>

<ul>
<li>简单</li>
<li>实时性</li>
</ul>

<p>缺点：</p>

<ul>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ul>

<h4 id="toc_30">2. 「标记-清除」机制</h4>

<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为结点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>

<h4 id="toc_31">3. 分代技术</h4>

<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个「代」，垃圾收集频率随着「代」存货时间的增大而减小，存货时间通常利用经过几次垃圾回收来度量。</p>

<p>Python 默认定义了三代对象集合，索引数越大，对象存货时间越长。</p>

<p>举例：当某些内存块 M 经过了 3 此垃圾收集的清洗之后还存活时，我们就将内存块 M 划分到一个集合 A 中去，而新分配的内存都划分到集合 B 中去。当垃圾收集开始工作时，大多数情况都只对集合 B 进行垃圾回收，而对集合 A 进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存减少了，效率自然就提高了。在这个过程中，集合 B 中的某些内存块由于存货时间长而会被转移到集合 A 中，当然，集合 A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代机制而被延迟。</p>

<h3 id="toc_32">Python 中 list 的实现</h3>

<p>详细参考：<a href="http://www.jianshu.com/p/J4U6rR">Python 中 List 的实现</a></p>

<h3 id="toc_33">Python 的 is</h3>

<p><code>is</code> 是对比地址，<code>==</code> 是对比值</p>

<h3 id="toc_34">read/readline/readlines</h3>

<ul>
<li>read 读取整个文件</li>
<li>readline 读取下一行，使用生成器的方式</li>
<li>readlines 读取整个文件到一个迭代器以供我们遍历</li>
</ul>

<h3 id="toc_35">Python 2 和 3 的区别</h3>

<p>详细参考：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/">http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/</a></p>

<h2 id="toc_36">操作系统</h2>

<h3 id="toc_37">select、poll 和 epoll</h3>

<p>待补充。</p>

<h3 id="toc_38">调度算法</h3>

<ol>
<li>先来先服务（FCFS, First Come First Server）</li>
<li>短作业优先（SJF, Shortest Job First）</li>
<li>最高优先权调度（Priority Scheduling）</li>
<li>时间片轮转（RR, Round Robin）</li>
<li>多级反馈队列调度（multilevel feedback queue scheduling）</li>
</ol>

<p>实时调度算法：</p>

<ol>
<li>最早截止时间优先 EDF</li>
<li>最低松弛度优先 LLF</li>
</ol>

<h3 id="toc_39">死锁</h3>

<p>原因：</p>

<ol>
<li>竞争资源</li>
<li>程序推进顺序不当</li>
</ol>

<p>必要条件：</p>

<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>

<p>处理死锁的基本方法：</p>

<ol>
<li>预防死锁</li>
<li>避免死锁（银行家算法）</li>
<li>检测死锁（资源分配图）</li>
<li>解除死锁

<ul>
<li>剥夺资源</li>
<li>撤销进程</li>
</ul></li>
</ol>

<h3 id="toc_40">程序的编译和链接</h3>

<p>待补充。</p>

<h3 id="toc_41">静态链接和动态链接</h3>

<p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来，静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库。</p>

<p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算（被调用的那部分）动态代码的逻辑地址，然后等到某个时候，程序有需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以这种方式使程序初始化的时间较短，但运行期间的性能比不上静态链接的程序。</p>

<h3 id="toc_42">虚拟内存技术</h3>

<p>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储系统。</p>

<h3 id="toc_43">分页和分段</h3>

<p>分页：用户程序的地址空间被划分为若干个固定大小的区域，称为「页」，相应的，内存空间分成若干个物理块，页和块的大小相等，可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>

<p>分段：将用户程序的地址空间分成若干个大小不等的「段」，每段可以定义一组相对完整的逻辑信息。存储分配时，以段位单位，段与段在内存中可以不相邻接，也实现了离散分配。</p>

<p>分页与分段的主要区别：</p>

<ol>
<li>页的信息是物理单位，分页是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要，段是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了更好得实现共享，满足用户的需要。</li>
<li>页的大小固定，由系统决定，将逻辑地址划分为页号和页内地址是由及其硬件实现的。而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分。</li>
<li>分页的作业地址空间是一维的，分段的地址空间是二维的。</li>
</ol>

<h3 id="toc_44">页面置换算法</h3>

<ol>
<li>最先置换算法 OPT：不可能实现</li>
<li>先进先出 FIFO</li>
<li>最近最久未使用算法 LRU：最近一段时间里最久没有使用过的页面予以置换</li>
<li>clock 算法</li>
</ol>

<h3 id="toc_45">边缘触发和水平触发</h3>

<p>边缘触发是指每当状态发生变化时发生一个 IO 事件，条件触发是只要满足条件就发生一个 IO 事件。</p>

<h2 id="toc_46">数据库</h2>

<h3 id="toc_47">事务</h3>

<p>数据库事务（Database Transaction），是指作为单个逻辑工作单元执行的一系列操作，要么完全得执行，要么完全得不执行。</p>

<h3 id="toc_48">数据库索引</h3>

<p>参考资料：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>

<h3 id="toc_49">Redis 原理</h3>

<p>待补充。</p>

<h3 id="toc_50">乐观锁和悲观锁</h3>

<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>
<li>乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性</li>
</ul>

<h2 id="toc_51">网络</h2>

<h3 id="toc_52">ARP 协议</h3>

<p>地址解析协议（Address Resolution Protocol），其基本功能为透过目标设备的 IP 地址，查询目标的 Mac 地址，以保证通信的顺利进行。它是 IPv4 网络层必不可少的协议，不过在 IPv6 中已不再适用，并被邻居发现协议（NDP）替代。</p>

<h3 id="toc_53">POST 和 GET</h3>

<p>参考阅读：</p>

<ul>
<li><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html">GET和POST有什么区别？及为什么网上的多数答案都是错的</a></li>
<li><a href="https://www.zhihu.com/question/31640769?rf=37401322">post 相比get 有很多优点，为什么现在的HTTP通信中大多数请求还是使用get？</a></li>
</ul>

<h3 id="toc_54">Cookie 和 Session</h3>

<table>
<thead>
<tr>
<th></th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>

<tbody>
<tr>
<td>存储位置</td>
<td>客户端</td>
<td>服务器端</td>
</tr>
<tr>
<td>目的</td>
<td>跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td>跟踪会话</td>
</tr>
<tr>
<td>安全性</td>
<td>不安全</td>
<td>安全</td>
</tr>
</tbody>
</table>

<p>Session 技术是要使用到 Cookie 的，之所以出现 Session 技术，主要是为了安全。</p>

<h3 id="toc_55">Apache 和 Nginx 的区别</h3>

<p>Nginx 相对于 Apache 的优点：</p>

<ul>
<li>轻量级：同样的 Web 服务，比 Apache 占用更少的内存及资源</li>
<li>抗并发：Nginx 处理请求时异步非阻塞的，支持更多的并发连接，而 Apache 则是阻塞型的，在高并发下 Nginx 能保持低资源低消耗高性能</li>
<li>配置简洁</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>

<p>Apache 相对 Nginx 的优点：</p>

<ul>
<li>rewrite 比 Nginx 的 rewrite 强大</li>
<li>模块很多，基本可以想到的都能找到</li>
<li>bug 少，Nginx bug 多</li>
<li>很稳定</li>
</ul>

<h3 id="toc_56">网站用户密码保存</h3>

<ul>
<li>明文保存</li>
<li>明文 hash 后保存，如 md5</li>
<li>MD5 + salt 方式，这个 salt 可以随机</li>
<li>知乎使用了 Bcrypy 加密（待考）</li>
</ul>

<h3 id="toc_57">HTTP 和 HTTPS</h3>

<p>待补充。</p>

<h3 id="toc_58">XSRF 和 XSS</h3>

<p>参考 <a href="14889309726832.html">计算机网络</a></p>

<h3 id="toc_59">CGI 和 WSGI</h3>

<p>CGI 是通用网关接口，是连接 web 服务器和应用程序的接口，用户通过 CGI 来获取动态数据或文件等。CGI 程序是一个独立的程序，它可以用几乎所有语言来写。</p>

<p>WSGI（Web Server Gateway Interface），是 Python 应用程序或 Web 框架与服务器之间的一种接口，WSGI 的其中一个目的就是让用户可以用统一的语言（Python）来编写前后端。</p>

<h3 id="toc_60">中间人攻击</h3>

<p>中间人攻击（Man in the middle attack, MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为它们正在通过一个私密的连接与对方直接对话，但事实上整个对话都被攻击者完全控制。</p>

<h3 id="toc_61">CK10 问题</h3>

<p>指的是服务器同时支持成千上万个客户端的问题。</p>

<p>参考阅读：<a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></p>

<h3 id="toc_62">Ajax</h3>

<p>Ajax（Asynchronous JavaScript and Xml，异步的 JavaScript 和 XML），是指在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算机网络]]></title>
    <link href="http://forresthcang.com/wiki/14889309726832.html"/>
    <updated>2017-03-08T07:56:12+08:00</updated>
    <id>http://forresthcang.com/wiki/14889309726832.html</id>
    <content type="html">
<![CDATA[<ul>
<li>
<a href="#toc_0">HTTP 协议</a>
<ul>
<li>
<a href="#toc_1">HTTP 的特性</a>
</li>
<li>
<a href="#toc_2">HTTP 报文</a>
<ul>
<li>
<a href="#toc_3">请求报文</a>
</li>
<li>
<a href="#toc_4">响应报文</a>
</li>
<li>
<a href="#toc_5">条件 GET</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">持久连接</a>
</li>
<li>
<a href="#toc_7">HTTP Pipelining（HTTP 管线化）</a>
</li>
<li>
<a href="#toc_8">会话跟踪</a>
</li>
<li>
<a href="#toc_9">跨站攻击</a>
<ul>
<li>
<a href="#toc_10">如何防范 CSRF 攻击？</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">XSS（Cross Site Scripting，跨站脚本攻击）</a>
<ul>
<li>
<a href="#toc_12">如何防御 XSS 攻击？</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_13">TCP 协议</a>
<ul>
<li>
<a href="#toc_14">TCP 协议的特性</a>
</li>
<li>
<a href="#toc_15">三次握手与四次握手</a>
</li>
<li>
<a href="#toc_16">SYN 攻击</a>
<ul>
<li>
<a href="#toc_17">什么是 SYN 攻击（SYN Flood）？</a>
</li>
<li>
<a href="#toc_18">如何检测 SYN 攻击？</a>
</li>
<li>
<a href="#toc_19">如何防御 SYN 攻击？</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_20">IP 协议</a>
<ul>
<li>
<a href="#toc_21">广播与多播</a>
<ul>
<li>
<a href="#toc_22">广播</a>
</li>
<li>
<a href="#toc_23">多播</a>
</li>
</ul>
</li>
<li>
<a href="#toc_24">BGP</a>
</li>
</ul>
</li>
<li>
<a href="#toc_25">Socket 编程</a>
</li>
</ul>


<h2 id="toc_0">HTTP 协议</h2>

<h3 id="toc_1">HTTP 的特性</h3>

<ul>
<li>HTTP 构建于 TCP/IP 协议之上</li>
<li>HTTP 是无连接状态的</li>
</ul>

<h3 id="toc_2">HTTP 报文</h3>

<h4 id="toc_3">请求报文</h4>

<p>HTTP 定义了与服务器交互的不同方法，最基本的方法有 4 种，分别是 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>. <code>URL</code> 全称是资源描述符，我们可以这样任务，一个 URL 地址，它用于描述一个网络上的资源，而 HTTP 中的 GET、POST、PUT、DELETE 就对应着对这个资源的差、改、增、删 4 个操作。</p>

<ol>
<li><p>GET 用于信息获取，而且应该是<strong>安全的</strong>和<strong>幂等的</strong></p>

<p>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用，不会影响资源的状态。</p>

<p>幂等的意味着对同一 URL 的多个请求应该返回同样的结果。</p>

<p>GET 请求报文示例：</p>

<pre><code>GET /books/?sex=man&amp;name=Professional HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
</code></pre></li>
<li><p>POST 表示可能修改服务器上的资源</p>

<pre><code>POST / HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive

sex=man&amp;name=Professional
</code></pre></li>
<li><p>注意</p>

<ul>
<li>GET 可提交的数据量受 URL 长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器对它的限制</li>
<li>理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，处于安全考虑，服务器软件在实现时会做一定限制</li>
<li>参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里</li>
</ul></li>
</ol>

<h4 id="toc_4">响应报文</h4>

<p>HTTP 响应与 HTTP 请求相似，HTTP 响应也由 3 个部分构成，分别是：</p>

<ul>
<li>状态行</li>
<li>响应头（Response Header）</li>
<li>响应正文</li>
</ul>

<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>

<p>常见的状态码有如下几种：</p>

<ul>
<li>200 OK：客户端请求成功</li>
<li>302 Moved Temporirily：请求重定向</li>
<li>304 Not Modified：文件未修改，可以直接使用缓存文件</li>
<li>400 Bad Request：由于客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthonzed：请求未经授权。这个状态码必须和 WWW-Authenticate 报头域一起使用</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li>404 Not Found：请求的资源不存在，例如输入了错误的 URL</li>
<li>500 Internal Server Error：服务器发生不可预期的错误，导致无法完成客户端的请求</li>
<li>503 Service Unavailable：服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会回复正常</li>
</ul>

<p>下面是一个 HTTP 响应的例子：</p>

<pre><code>HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Data: Mon,60ct2003 13:23:52 GMT
Content-Length:112

&lt;html&gt;...
</code></pre>

<h4 id="toc_5">条件 GET</h4>

<p>HTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。详见：RFC2616</p>

<ol>
<li><p>HTTP 条件 GET 使用的时机</p>

<p>客户端之前已经访问过某网站，并打算再次访问该网站</p></li>
<li><p>HTTP 条件 GET 使用的方法</p>

<p>客户端想服务器发送一个包询问是否在上一次访问网站的时间后更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p></li>
</ol>

<p>下面是一个具体的发送接收报文的示例：</p>

<p>客户端发送请求：</p>

<pre><code>GET / HTTP/1.1
Host: www.sina.com.cn:80
If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT
Connection: Close
</code></pre>

<p>第一次请求时，服务器端发送请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified 响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。</p>

<pre><code>HTTP/1.0 304 Not Modified
Date: Thu, 04 Feb 2010 12:38:41 GMT
Content-Type: text/html
Expires: Thu, 04 Feb 2010 12:39:41 GMT
Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT
Age: 28
X-Cache: HIT from sy32-21.sina.com.cn
Connection: close
</code></pre>

<p>如果服务器端资源已经更新的话，就返回正常的响应。</p>

<h3 id="toc_6">持久连接</h3>

<p>我们知道 HTTP 协议采用 「请求-应答」模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连击，完成之后立即断开连接（HTTP 协议为无连接协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接。</p>

<p>在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际它是被附加到 HTTP 1.0 协议上，如如过客户端浏览器支持 Keep-Alive，那么就在 HTTP 请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开，当客户端发送另外一个请求时，就是用这条已经建立的连接。</p>

<p>在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 Connection: close 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。</p>

<p>注意：</p>

<ul>
<li>HTTP Keep-Alive 简单说就是保持当前 TCP 连接，避免了重新建立连击</li>
<li>HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100, 表示这个 TCP 通道可以保持 5 秒，max=100 表示这个长连接最多接受 100 次请求就断开</li>
<li>HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。另外，Keep-Alive 也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP 1.1 也是如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于 Keep-Alive 的保持连击特性</li>
<li>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1）判断传输数据是否达到了 Content-Length 指示的大小；2）动态生成的文件没有 Content-Length，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后又一个空 chunked 块，表明本次传输数据结束。</li>
</ul>

<h3 id="toc_7">HTTP Pipelining（HTTP 管线化）</h3>

<p>默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于「请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 —&gt; 响应3」。</p>

<p>HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需要等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样：「请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3」。</p>

<p>注意下面几点：</p>

<ul>
<li>管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0 不支持）</li>
<li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制</li>
<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议</li>
<li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>
<li>HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
<li>由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持</li>
</ul>

<h3 id="toc_8">会话跟踪</h3>

<ul>
<li><p>什么是会话？</p>

<p>客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</p></li>
<li><p>什么是会话跟踪？</p>

<p>会话跟踪指的是对一个用户对服务器的连续的请求和接受响应的监视。</p></li>
<li><p>为什么需要会话跟踪？</p>

<p>浏览器与服务器之间的通信是通过 HTTP 协议进行通信的，而 HTTP 协议是「无状态」的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才会有会话跟踪技术来实现这种要求。</p>

<ol>
<li><p>会话跟踪的常用方法</p>

<ul>
<li>URL 重写。URL 是 Web 上特定页面的地址，URL 重写的技术就是在 URL 结尾添加一个附加数据以标识该会话，把会话 ID 通过 URL 的信息传递过去，以便在服务器端进行识别不同的用户</li>
</ul></li>
<li><p>隐藏表单域</p>

<ul>
<li>将会话 ID 添加到 HTML 表单元素中提交到服务器，此标案元素并不在客户端显示</li>
</ul></li>
<li><p>Cookie</p>

<ul>
<li>Cookie 是 Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端，在客户端可以进行保存，以便下次使用。</li>
<li>客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称之为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。</li>
<li>Cookie 是可以被禁止的。</li>
</ul></li>
<li><p>Session</p>

<ul>
<li>每一个用户都有一个不同的 Session，各个用户之间是不能共享的，是每个用户所独享的，在 Session 中可以存放信息</li>
<li>在服务器端会创建一个 session 对象，产生一个 session ID 来标识这个 session 对象，然后将这个 session ID 放到 Cookie 中发送到客户端，下一次访问时，session ID 会发送到服务器，在服务器端进行标识不同的用户</li>
<li>session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效</li>
</ul></li>
</ol></li>
</ul>

<h3 id="toc_9">跨站攻击</h3>

<p>CSRF（Cross-site request forgery，跨站请求伪造）</p>

<p>CSRF（XSRF）顾名思义，是伪造请求，冒充用户在站内的正常操作。</p>

<p>例如，一论坛网站的发帖是通过 GET 请求访问，点击发帖之后 JS 把发帖内容拼接成目标 URL 并访问：</p>

<pre><code>http://example.com/bbs/create_post.php?title=标题&amp;content=内容
</code></pre>

<p>那么，我们紫瑶在论坛中发一贴，包含一链接：</p>

<pre><code>http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈
</code></pre>

<p>只要有用户点击了这个连接，那么他们的账户就会在不知情的情况下发不了这一帖子。既然发帖的请求可以伪造，那么删帖、转账、改密码、发邮件全部可以伪造。</p>

<h4 id="toc_10">如何防范 CSRF 攻击？</h4>

<p>可以注意以下几点：</p>

<ul>
<li>关键操作只接受 POST 请求</li>
<li>验证码。CSRF 攻击的过程中，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效地防御了 CSRF 攻击。但是如果你在一个网站做出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时使用</li>
<li>检测 Referer

<ul>
<li>常见的互联网页面与页面之间是存在联系的</li>
<li>通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击</li>
</ul></li>
<li>Token

<ul>
<li>目前主流的做法是使用 Token 抵御 CSRF 攻击</li>
<li>CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击</li>
<li>另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的，这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击</li>
</ul></li>
</ul>

<p>Token 使用原则：</p>

<ul>
<li>Token 要足够随机（只有这样才算不可预测）</li>
<li>Token 是一次性的，即每次请求成功后要更新 Token（这样可以增加攻击难度，增加预测难度）</li>
<li>Token 要注意保密性（敏感操作使用 POST，防止操作出现在 URL）中</li>
</ul>

<h3 id="toc_11">XSS（Cross Site Scripting，跨站脚本攻击）</h3>

<p>XSS 全称「跨站脚本」，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到页面上，其他用户访问这个页面的时候就会运行这个脚本。</p>

<p>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p>

<h4 id="toc_12">如何防御 XSS 攻击？</h4>

<p>理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害却绝育攻击代码的威力，攻击代码也不限于 script。防御 XSS 攻击最简单的方法，就是过滤用户的输入。</p>

<p>如果不需要用户输入 HTML，可以直接对用户输入进行 HTML escape。</p>

<p>当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法的 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿去。</p>

<h2 id="toc_13">TCP 协议</h2>

<h3 id="toc_14">TCP 协议的特性</h3>

<ul>
<li>TCP 提供一种面向连接的、可考的字节流服务</li>
<li>在一个 TCP 连接中，仅有两方进行彼此的通信。广播和多播不能用于 TCP</li>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 使用累积确认</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>

<h3 id="toc_15">三次握手与四次握手</h3>

<p>所谓三次握手（Three-way Handshake），是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。</p>

<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connec()</code> 时，将触发三次握手。</p>

<ul>
<li>第一次握手（SYN=1, seq=x）

<ul>
<li>客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器端口，以及初始序列号 X，保存在包头的序列号（Sequence Number）字段里。</li>
<li>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态</li>
</ul></li>
<li>第二次握手（SYN=1, ACK=1, seq=y, ACKnum=x+1）

<ul>
<li>服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序列号（Acknowledgement Number） 设置为客户的 ISN 加 1，即 x+1</li>
<li>发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态</li>
</ul></li>
<li><p>第三次握手（ACK=1, ACKnum=y+1）</p>

<ul>
<li>客户端再次发送确认包（ACK），SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序列号字段 +1，放在确定字段中发送给对方，并且在数据段放写 ISN 的 +1</li>
<li>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>
</ul>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-08-060918.jpg" alt=""/></p></li>
</ul>

<p>TCP 的连接的拆除需要发送四个包，因此成为四次握手（Four-way handshake），也叫做改进的三次握手。客户端或服务器均可主动法切握手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生握手动作。</p>

<ul>
<li>第一次握手（FIN=1, seq=x）

<ul>
<li>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据</li>
<li>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态</li>
</ul></li>
<li>第二次握手（ACK=1, ACKnum=x+1）

<ul>
<li>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接</li>
<li>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接受到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接</li>
</ul></li>
<li>第三次握手（FIN=1, seq=y）

<ul>
<li>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN 置为 1</li>
<li>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个 ACK</li>
</ul></li>
<li><p>第四次握手（ACK=1, ACKnum=y+1）</p>

<ul>
<li>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code> 状态，等待可能出现的要求重传的 ACK 包</li>
<li>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态</li>
<li>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime） 之后，没有收到服务器端的 ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，计入 <code>CLOSED</code> 状态</li>
</ul>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-08-060951.jpg" alt=""/></p></li>
</ul>

<h3 id="toc_16">SYN 攻击</h3>

<h4 id="toc_17">什么是 SYN 攻击（SYN Flood）？</h4>

<p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接成为半连接（half-open connect）。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态</p>

<p>SYN 攻击指的是，攻击客户端在段时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求会被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>

<p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>

<h4 id="toc_18">如何检测 SYN 攻击？</h4>

<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats  命令来检测 SYN 攻击。</p>

<h4 id="toc_19">如何防御 SYN 攻击？</h4>

<p>SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 SYN 攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p>

<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN Cookie 技术</li>
</ul>

<h2 id="toc_20">IP 协议</h2>

<h3 id="toc_21">广播与多播</h3>

<p>广播和多播仅用于 UDP（TCP是面向连接的）。</p>

<h4 id="toc_22">广播</h4>

<p>一共有四种广播地址：</p>

<ol>
<li><p>受限的广播</p>

<p>受限的广播地址为 255.255.255.255。该地址用于珠玑配置过程中 IP 数据报的目的地址，在任何情况下，router 不转发目的地址为 255.255.255.255 的数据报，这样的数据报近出现在本地网络中。</p></li>
<li><p>指向网络的广播</p>

<ul>
<li>指向网络的广播地址是主机号为全 1 的地址。A 类网络广播地址为 netid.255.255.255，其中 netid 为 A 类网络的网络号。</li>
<li>一个 router 必须转发指向网络的广播，但它也必须有一个不进行转发的选择</li>
</ul></li>
<li><p>指向子网的广播</p>

<p>指向子网的广播地址为主机号为全 1 且有特定子网号的地址。作为子网直接广播地址的 IP 地址需要了解子网的掩码。例如，router 收到 128.1.2.255 的数据报，当 B 类网路 128.1 的子网掩码为 255.255.255.0 时，该地址就是指向子网的广播地址；但是如果子网掩码为 255.255.254.0，该地址就不是指向子网的广播地址。</p></li>
<li><p>指向所有子网的广播</p>

<p>指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开来。指向所有子网的广播地址的子网号和主机号为全 1. 例如，如果子网掩码为 255.255.255.0，那么 128.1.255.255 就是一个指向所有子网的广播地址。</p>

<p>当前看法是这种广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。</p></li>
</ol>

<p>广播示例：</p>

<pre><code>PING 192.168.0.255 (192.168.0.255): 56 data bytes 64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.199 ms 64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=45.357 ms 64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.203 ms 64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=269.475 ms
64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=189.881 ms
</code></pre>

<p>可以看到的确受到了来自两个主机的答复，其中 192.168.0.107 是本机地址。</p>

<h4 id="toc_23">多播</h4>

<p>多播又叫组播，使用 D 类地址，D 类地址分配的 28bit 均用作多播组号而不再表示其他。</p>

<p>多播组地址包括 1110 的最高 4 bit 和多播组号。它们通常可以表示为点分十进制数，范围从 224.0.0.0 到 239.255.255.255.</p>

<p>多播的出现减少了对应用不感兴趣主机的处理负荷。</p>

<p>多播的特点：</p>

<ul>
<li>允许一个或多个发送者（组播源）发送单一的数据包到多个接收者（一次的、同时的）的网络技术</li>
<li>可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包</li>
<li>多播技术的核心就是针对如何节约网络资源的前提下保证服务质量</li>
</ul>

<p>多播示例：</p>

<pre><code>PING 224.0.0.1 (224.0.0.1): 56 data bytes
64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.081 ms
64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=123.081 ms
64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.122 ms
64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=67.312 ms
64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.132 ms
64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=447.073 ms
64 bytes from 192.168.0.107: icmp_seq=3 ttl=64 time=0.132 ms
64 bytes from 192.168.0.106: icmp_seq=3 ttl=64 time=188.800 ms
</code></pre>

<h3 id="toc_24">BGP</h3>

<ul>
<li>边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议</li>
<li>BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不想管路由域间的多路连接的协议</li>
<li>BGP 是一种外部网关协议（Exterior Gateway Protocol, EGP），与 OSPF、RIP 等 内部网关协议（Interior Gateway Protocol, IGP） 不同，BGP 不在于发现和计算路由，而在于控制路由的传播和选择最佳路由</li>
<li>BGP 使用 TCP 作为其传输层协议（端口号 179），提高了协议的可靠性</li>
<li>BGP 支持 CIDR（Classless Inter-Domain Routing，无类别域间路由）</li>
<li>路由更新时，BGP 只发送更新的路由，大大减少了 BGP 传播路由所占用的贷款，适用于在 Internet 上传播大量的路由信息</li>
<li>BGP 路由通过携带 AS 路径信息彻底解决路由环路问题</li>
<li>BGP 提供了丰富的路由策略，能够对路由实现灵活的过滤和选择</li>
<li>BGP 易于扩展，能够实行网络新的发展</li>
</ul>

<h2 id="toc_25">Socket 编程</h2>

<p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与 TCP/IP 协议族通信的中间软件抽象层。从设计模式的角度来看，Socket 其实是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</p>

<p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip 地址、协议、端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其他进程进行交互。</p>

<p>Socket 起源于 Unix，Unix 基本哲学之一就是「一切皆文件」，都可以用「open -&gt; read/write -&gt; close」 模式来进行操作。因此，Socket 也被处理为一种特殊的文件。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《算法》笔记]]></title>
    <link href="http://forresthcang.com/wiki/14887608416607.html"/>
    <updated>2017-03-06T08:40:41+08:00</updated>
    <id>http://forresthcang.com/wiki/14887608416607.html</id>
    <content type="html">
<![CDATA[<ul>
<li>
<a href="#toc_0">1.3 背包、队列和栈</a>
<ul>
<li>
<a href="#toc_1">1.3.1 API</a>
<ul>
<li>
<a href="#toc_2">1.3.1.1 泛型</a>
</li>
<li>
<a href="#toc_3">1.3.1.2 自动装箱</a>
</li>
<li>
<a href="#toc_4">1.3.1.3 可迭代的几何类型</a>
</li>
<li>
<a href="#toc_5">1.3.1.4 背包</a>
</li>
<li>
<a href="#toc_6">1.3.1.5 先进先出队列</a>
</li>
<li>
<a href="#toc_7">1.3.1.6 下压栈</a>
</li>
<li>
<a href="#toc_8">1.3.1.7 算数表达式求值</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">1.3.2 集合数据类型的实现</a>
<ul>
<li>
<a href="#toc_10">1.3.2.1 定容栈</a>
</li>
<li>
<a href="#toc_11">1.3.2.2 泛型</a>
</li>
<li>
<a href="#toc_12">1.3.2.3 调整数组的大小</a>
</li>
<li>
<a href="#toc_13">1.3.2.4 对象游离</a>
</li>
<li>
<a href="#toc_14">1.3.2.5 迭代</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">1.3.3 链表</a>
<ul>
<li>
<a href="#toc_16">1.3.3.1 结点记录</a>
</li>
<li>
<a href="#toc_17">1.3.3.8 栈的实现</a>
</li>
<li>
<a href="#toc_18">1.3.3.9 队列的实现</a>
</li>
<li>
<a href="#toc_19">1.3.3.10 背包的实现</a>
</li>
</ul>
</li>
<li>
<a href="#toc_20">1.3.4 综述</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">1.4 算法分析</a>
<ul>
<li>
<a href="#toc_22">1.4.1 科学方法</a>
</li>
<li>
<a href="#toc_23">1.4.3 数学模型</a>
</li>
<li>
<a href="#toc_24">1.4.4 增长数量级的分类</a>
</li>
<li>
<a href="#toc_25">1.4.5 设计更快的算法</a>
</li>
<li>
<a href="#toc_26">1.4.7 注意事项</a>
<ul>
<li>
<a href="#toc_27">1.4.7.1 大常数</a>
</li>
<li>
<a href="#toc_28">1.4.7.2 非决定性的内循环</a>
</li>
<li>
<a href="#toc_29">1.4.7.3 指令时间</a>
</li>
</ul>
</li>
<li>
<a href="#toc_30">1.4.8 处理对于输入的依赖</a>
<ul>
<li>
<a href="#toc_31">1.4.8.1 输入模型</a>
</li>
<li>
<a href="#toc_32">1.4.8.3 随机化算法</a>
</li>
<li>
<a href="#toc_33">1.4.8.5 均摊分析</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_34">1.5 案例研究：union-find 算法</a>
</li>
<li>
<a href="#toc_35">2.1 初级排序算法</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_36">2.1.1.3 额外的内存使用</a>
</li>
</ul>
</li>
<li>
<a href="#toc_37">2.1.2 选择排序</a>
</li>
<li>
<a href="#toc_38">2.1.3 插入排序</a>
</li>
<li>
<a href="#toc_39">2.1.6 希尔排序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_40">2.2 归并排序</a>
<ul>
<li>
<a href="#toc_41">2.2.1 原地归并的抽象方法</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1.3 背包、队列和栈</h2>

<p>研究方法：1）学习其 API 和用例；2）讨论数据类型的值和所有可能的表示方法；3）各种操作的实现。</p>

<h3 id="toc_1">1.3.1 API</h3>

<p>每份 API 都含有一个无参数的构造函数、一个向集合中添加单个元素的方法、一个测试集合是否为空的方法和一个返回集合大小的方法。Stack 和 Queue 都含有一个能够删除集合中的特定元素的方法。</p>

<p>背包：</p>

<table>
<thead>
<tr>
<th></th>
<th>Bag()</th>
<th>创建一个空背包</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>add(item)</td>
<td>添加一个空元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>背包是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>背包中元素的数量</td>
</tr>
</tbody>
</table>

<p>先进先出（FIFO）队列:</p>

<table>
<thead>
<tr>
<th></th>
<th>Queue()</th>
<th>创建空队列</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>enqueue(item)</td>
<td>添加一个元素</td>
</tr>
<tr>
<td>Item</td>
<td>dequeue()</td>
<td>删除最早添加的元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>队列是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>队列中元素数量</td>
</tr>
</tbody>
</table>

<p>下压（后进先出，LIFO）栈：</p>

<table>
<thead>
<tr>
<th></th>
<th>Stack()</th>
<th>创建一个空栈</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>push(item)</td>
<td>添加一个元素</td>
</tr>
<tr>
<td>Item</td>
<td>pop()</td>
<td>删除最近添加的元素</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>栈是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>栈中的元素数量</td>
</tr>
</tbody>
</table>

<h4 id="toc_2">1.3.1.1 泛型</h4>

<p>因为这里使用的 Python 语言来实现书中的代码，所以不存在泛型的问题，Python 是鸭子类型。</p>

<h4 id="toc_3">1.3.1.2 自动装箱</h4>

<p>自动讲一个原始数据类型转换为一个封装类型被称为自动装箱，自动将一个封装类型转换为原始数据类型被称为自动拆箱。</p>

<h4 id="toc_4">1.3.1.3 可迭代的几何类型</h4>

<p>对应 Python 中的 Iterable 类型。</p>

<h4 id="toc_5">1.3.1.4 背包</h4>

<p>背包是一种不支持从中删除元素的几何数据类型——它的目的就是帮助用例收集元素并迭代遍历所有收集到的元素。迭代的顺序不确定且与用例无关。</p>

<h4 id="toc_6">1.3.1.5 先进先出队列</h4>

<p>先进先出队列（简称队列）是一种基于先进先出（FIFO）策略的集合类型。</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-06-011739.jpg" alt=""/></p>

<h4 id="toc_7">1.3.1.6 下压栈</h4>

<p>下压栈（简称栈）是一种基于后进先出（LIFO）策略的几何类型。典型例子：1）邮件系统；2）浏览器。</p>

<h4 id="toc_8">1.3.1.7 算数表达式求值</h4>

<p>递归定义：<em>算数表达式</em>可能是一个数、或者是一个由左括号、一个算数表达式、一个运算符、另一个算数表达式和一个右括号组成的表达式。（简单起见，这里定义的是未省略括号的算数表达式）。</p>

<p>E.W.Dijkstra 在 20 世纪 60 年代发明了一个非常简单的算法，用两个栈（一个用于保存运算符，一个用于保存操作数）完成了这个任务。</p>

<p>我们根据以下 4 种情况从左到右逐个将这些实体送入栈处理：</p>

<ol>
<li>将操作数压入操作数栈；</li>
<li>将运算符压入运算符栈；</li>
<li>忽略左括号；</li>
<li>在遇到右括号时，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈。</li>
</ol>

<p>一个用栈实现的简单解释器例子：</p>

<pre><code class="language-python">def evaluate(expression):
    ops = Stack()
    vals = Stack()
    
    for s in expression:
        if s == &#39;(&#39;:
            continue
        elif s == &#39;+&#39;:
            ops.push(s)
        elif s == &#39;-&#39;:
            ops.push(s)
        elif s == &#39;*&#39;:
            ops.push(s)
        elif s == &#39;/&#39;:
            ops.push(s)
        elif s == &#39;)&#39;:
            op = ops.pop()
            v = vals.pop()
            if op == &#39;+&#39;:
                v = vals.pop() + v
            elif op == &#39;-&#39;:
                v = vals.pop() - v
            elif op == &#39;*&#39;:
                v = vals.pop() * v
            elif op == &#39;/&#39;:
                v = vals.pop() / v
            vals.push(v)
        else:
            vals.push(s)
    return vals[0]
</code></pre>

<h3 id="toc_9">1.3.2 集合数据类型的实现</h3>

<h4 id="toc_10">1.3.2.1 定容栈</h4>

<p>定容栈是一种表示容量固定的字符串栈的抽象数据类型，它的 API 和 Stack 的 API 有所不同：它只能处理 String 值，它要求用例制定一个容量且不支持迭代。实现一份 API 的第一步就是选择数据的表示方式，对于 <code>FixedCapacityStackOfStrings</code>，我们可以选用数组。</p>

<p>API:</p>

<table>
<thead>
<tr>
<th></th>
<th>FixedCapacityStackOfStrings(size)</th>
<th>创建一个容量为 size 的空栈</th>
</tr>
</thead>

<tbody>
<tr>
<td>void</td>
<td>push(item:str)</td>
<td>添加一个字符串</td>
</tr>
<tr>
<td>str</td>
<td>pop()</td>
<td>删除最近添加的字符串</td>
</tr>
<tr>
<td>bool</td>
<td>isEmpty()</td>
<td>栈是否为空</td>
</tr>
<tr>
<td>int</td>
<td>size()</td>
<td>栈中字符串数量</td>
</tr>
</tbody>
</table>

<p>数据类型的实现：</p>

<pre><code class="language-python">class FixedCapacityStackOfStrings:
    def __init__(self, size):
        _a = []     # stack entries
        _size = size
        N = 0      # stack index
        

    def isEmpty(self):
        return N == 0

    def size(self):
        return N
    
    def push(self, item):
        N += 1
        _a[N] = item

    def pop(self):
        N -= 1
        return _a[N]
</code></pre>

<ul>
<li>数组中的元素顺序和它们被插入的顺序相同</li>
<li>当 N 为 0 时栈为空</li>
<li>栈的顶部位于 <code>_a[N-1]</code></li>
</ul>

<h4 id="toc_11">1.3.2.2 泛型</h4>

<p>如果上面代码是用 Java 写的话，确实只能处理 String 对象，但是 Python 是动态类型的语言，不存在泛型的问题。</p>

<h4 id="toc_12">1.3.2.3 调整数组的大小</h4>

<p>选择用数组表示栈内容意味着用例必须预先估计栈的最大容量（在 Python 中数组是动态变化的，所以不需要，这里为了模拟）。在 Java 中，数组一旦创建，其大小是无法改变的，因此栈使用的空间只能是这个最大容量的一部分。选择大容量的用例在栈为空或几乎为空时会浪费大量的内存。<code>push()</code> 方法需要在代码中检测栈是否已满，我们的 API 中也应该含有一个 <code>isFull()</code> 的方法来允许用例检测栈是否已满。我们在此省略了它实现的代码，因为我们希望用例从处理栈已满的问题中解脱出来，如我们原始的 Stack API 所示。因此，我们修改了数组的实现，动态调整数组的大小，使得它既足以保存所有元素，又不至于浪费过多的空间。</p>

<p>首先，实现一个方法将栈移动到另一个大小不同的数组中：</p>

<pre><code class="language-python">def resize(self, max):
   temp = []
   _size = max
   for i in range(N):
       temp[i] = _a[i]
   a = temp
</code></pre>

<p>现在，在 <code>push()</code> 中，检查数组是否太小。具体来说，我们会通过检查栈代销 N 和数组大小 <code>_size</code> 是否相等来检查数组是否能容纳新的元素。如果没有多余的空间，我们会将数组的长度加倍，然后既可以和之前一样用 <code>a[N++] = item</code> 插入新元素了：</p>

<pre><code class="language-python">def push(self, item):
   if N == _size:
       self.resize(2*_size)
   N += 1
   _a[N] = item
</code></pre>

<p>类似，在 <code>pop()</code> 中，首先删除栈顶的元素，然后如果数组太大我们就将它的长度减半。只要稍加思考，技能明白正确的检测条件是栈大小是否小鱼数组的四分之一。在数组长度被减半之后，它的状态为半满，在下次需要改变数组大小之前人能够进行多次 <code>push()</code> 和 <code>pop()</code> 操作。</p>

<pre><code class="language-python">def pop(self):
   N -= 1
   item = _a[N]
   _a[N] = None
   if N &gt; 0 and N == _size/4:
       resize(_size/2)
   return item
</code></pre>

<p>在这个实现中，栈永远都不会溢出，使用率也永远不会低于四分之一。</p>

<h4 id="toc_13">1.3.2.4 对象游离</h4>

<p>Java 的垃圾收集策略是回收所有无法被访问的对象的内存。在我们队 <code>pop()</code> 的实现中，被弹出的元素引用仍然存在于数组中。这个元素实际上已经是一个孤儿了——它永远不会被再访问了，但 Java 的垃圾收集器没法知道这一点，除非该引用被覆盖。即使用例已经不再需要这个元素了，数组中的引用仍然可以让它继续存在，这种情况（保存一个不需要的对象的引用）成为<strong>游离</strong>。</p>

<h4 id="toc_14">1.3.2.5 迭代</h4>

<p>集合类数据类型的基本操作之一就是，能够使用 Python 的 for-in 语句通过迭代遍历并处理集合中的每个元素。这种方式的代码既清晰又简介，且不依赖与集合数据类型的具体实现。</p>

<p>好处：1）我们无需改变任何用例代码就可以随意切换不同的表示方法；2）更重要的是，从用例的角度来说，无需知晓类的实现细节用例也能使用迭代。</p>

<p>在 Python 中，需要在类中实现 <code>__iter__()</code> 和 <code>__next__()</code> 。</p>

<pre><code class="language-python">def __iter__(self):
     return self

def __next__(self):
     index = 0
     if index &gt; _size:
         raise StopIteration
     else:
         index += 1
         return self._a[index-1]
</code></pre>

<p>例如，我们在实现 Queue 的 API 时，可以使用两个实例变量作为索引，一个变量 head 指向队列的开头，一个变量 tail 指向队列的结尾。在删除一个元素时，使用 head 访问它并将 head 加 1；在插入一个元素时，使用 tail 保存它并将 tail 加 1.如果某个索引在增加之后越过了数组的边界则将它重置为 0.</p>

<p>下压（LIFO）栈（能够动态调整数组大小的实现）：</p>

<pre><code class="language-python">class ResizingArrayStack(object):
    a = []
    N = 0

    def isEmpty(self):
        return N == 0

    def size(self):
        return N

    def resize(self, max):
        temp = []
        for i in range(N):
            temp[i] = a[i]
        a = temp

    def push(self, item):
        if N == len(self.a):
            self.resize(2*len(self.a))
        N += 1
        a[N] = item

    def pop(self):
        N -= 1
        item = a[N]
        a[N] = None
        if N &gt; 0 and N == len(self.a):
            self.resize(len(self.a)/2)

    def __iter__(self):
        return self

    def __next__(self):
        index = N - 1
        if index == 0:
            raise StopIteration
        else:
            index -= 1
            return a[index]
</code></pre>

<p>这份支持迭代的 Stack API 的实现是所有集合抽象数据类型实现的模板。它将所有元素保存在数组中，并动态调整数组大小以保持数组大小和栈大小之比小于一个常数。</p>

<h3 id="toc_15">1.3.3 链表</h3>

<blockquote>
<p>定义：链表是一种递归的数据结构，它为空（None），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</blockquote>

<p>在这个定义中，<code>结点</code>是一个可能含有任意类型数据的抽象实体，它所包含的指向结点的应用显示了它在构造链表之中的作用。</p>

<h4 id="toc_16">1.3.3.1 结点记录</h4>

<pre><code class="language-python">class Node(object):
        def __init__(self, item):
             self.item = item
             self.next = None
             
        def get_item(self):
                return self.item
                
        def get_next(self):
                return self.next
                
        def set_item(self, item):
                self.item = item
                
        def set_next(self, next):
                self.next = next
</code></pre>

<h4 id="toc_17">1.3.3.8 栈的实现</h4>

<p>下压堆栈（链表实现）：</p>

<pre><code class="language-python">class Node(object):
    def __init__(self, item):
        self.item = item
        self.next = None

class Stack(object):
    def __init__(self):
        self.first = None
        self.N = 0
        
    def isEmpty(self):
        return self.N == 0
    
    def size(self):
        return self.N
    
    def push(self, item):
        oldfirst = self.first
        self.first = Node(item)
        self.first.next = oldfirst
        self.N += 1
        
    def pop(self):
        item = self.first.item
        self.first = self.first.next
        self.N -= 1
        return item
</code></pre>

<h4 id="toc_18">1.3.3.9 队列的实现</h4>

<p>基于链表数据结构实现 Queue API 也很简单。它将队列表示为一条从最早插入的元素到最近插入的元素的链表，实例变量 first 指向队列的开头，实例变量 last 指向 队列的结尾。这样，要讲一个元素入列（<code>enqueue()</code>），我们就将它添加到表尾（但是在链表为空时需要将 first 和 last 都指向新节点）；要将一个元素出列（<code>dequeue()</code>），我们就删除表头的结点（代码和 Stack 的 <code>pop()</code> 相同，只是当链表为空时需要更新 last 的值）。<code>size()</code> 和 <code>isEmpty()</code> 方法的实现和 Stack 相同。</p>

<p>和刚才一样，我们用链表达到了最优设计目标：<strong>它可以处理任意类型数据，所需的空间总是和集合大小成正比，操作所需时间总是和集合大小无关</strong>。</p>

<p>先进先出队列的实现：</p>

<pre><code class="language-python">class Queue(object):
    def __init__(self):
        self.first = None  # 指向最早添加的结点的链接
        self.last = None  # 指向最近添加的结点的链接
        self.N = 0
        
    def isEmpty(self):
        return self.N == 0
    
    def size(self):
        return self.N
    
    def enqueue(self, item):
        oldlast = self.last
        self.last = Node(item)
        self.last.next = None
        if self.isEmpty():
            self.first = self.last
        else:
            oldlast.next = self.last
        self.N += 1
        
    def dequeue(self):
        item = self.first.item
        self.first = self.first.next
        if self.isEmpty():
            self.last = None
        self.N -= 1
        return item
</code></pre>

<p>在结构化存储数据集时，<strong>链表是数组的一种重要的替代方式</strong>。事实上，编程语言历史上的一块里程碑就是 McCathy 在 20 世纪 50 年代发明的 LISP 语言，而链表则是这种语言组织程序和数据的主要结构。</p>

<h4 id="toc_19">1.3.3.10 背包的实现</h4>

<p>用链表数据结构实现我们的 Bag API 只需要将 Stack 中的 <code>push()</code> 方法改名为 <code>add()</code>，并去掉 <code>pop()</code> 的实现即可。</p>

<p>对于 Stack，链表的访问顺序是后进先出；对于 Queue，链表的访问顺序是先进先出；对于 Bag，它正好也是后进先出的顺序，但顺序并不重要。</p>

<p>背包的实现：</p>

<pre><code class="language-python">class Bag(object):
    def __init__(self):
        self.first = None
        self.N = 0
        
    def isEmpty(self):
        return self.first is None
    
    def add(self, item):
        oldfirst = self.first
        self.first = Node(item)
        self.first.next = oldfirst
        self.N += 1
        
    def __len__(self):
        return self.N
        
    def __iter__(self):
        return _BagIterator(self.first)

class _BagIterator(object):
    def __init__(self, listhead):
        self.current = listhead

    def __iter__(self):
        return self

    def __next__(self):
        if self.current is None:
            raise StopIteration
        item = self.current.item
        self.current = self.current.next
        return item
</code></pre>

<p>这份代码中实现了迭代器（可以使用 for-in 来遍历），Stack 和 Queue 可以使用同样的方法来实现。</p>

<h3 id="toc_20">1.3.4 综述</h3>

<p>基础数据结构：</p>

<table>
<thead>
<tr>
<th>数据结构</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>

<tbody>
<tr>
<td>数组</td>
<td>通过索引可以直接访问任意元素</td>
<td>在初始化时就需要知道元素的数量</td>
</tr>
<tr>
<td>链表</td>
<td>使用的空间大小和元素数量成正比</td>
<td>需要通过引用访问任意元素</td>
</tr>
</tbody>
</table>

<p>我们在本节中研究背包、队列和栈时描述数据结构和算法的方式是全书的原型。在研究一个新的应用领域时，我们将会按照以下步骤识别目标并使用数据抽象解决问题：</p>

<ol>
<li>定义 API</li>
<li>根据特定的应用场景开发用例代码</li>
<li>描述一种数据结构（一组值得表示），并在 API 所对应的抽象数据类型的实现中根据它定义类的实例变量</li>
<li>描述算法（实现一组操作的方式），并根据它实现类中的实例方法</li>
<li>分析算法的性能特点</li>
</ol>

<p>本书中所给出的数据结构举例：</p>

<table>
<thead>
<tr>
<th>数据结构</th>
<th>抽象数据类型</th>
<th>数据表示</th>
</tr>
</thead>

<tbody>
<tr>
<td>父链接数</td>
<td>UnionFind</td>
<td>整形数组</td>
</tr>
<tr>
<td>二分查找树</td>
<td>BST</td>
<td>含有两个链接的结点</td>
</tr>
<tr>
<td>字符串</td>
<td>String</td>
<td>数组、偏移量和长度</td>
</tr>
<tr>
<td>二插堆</td>
<td>PQ</td>
<td>对象数组</td>
</tr>
<tr>
<td>散列表（拉链法）</td>
<td>SeparateChainingHashST</td>
<td>链表数组</td>
</tr>
<tr>
<td>散列表（线性探测法）</td>
<td>LinerProbingHashST</td>
<td>两个对象数组</td>
</tr>
<tr>
<td>图的邻接链表</td>
<td>Graph</td>
<td>Bag 对象数组</td>
</tr>
<tr>
<td>单词查找树</td>
<td>TrieST</td>
<td>含有链接数组的结点</td>
</tr>
<tr>
<td>三向单词查找树</td>
<td>TST</td>
<td>含有三个链接的结点</td>
</tr>
</tbody>
</table>

<h2 id="toc_21">1.4 算法分析</h2>

<h3 id="toc_22">1.4.1 科学方法</h3>

<p>科学家用来理解自然世界的方法对于研究计算机程序的运行时间同样有效：</p>

<ul>
<li>细致地观察真实世界的特点，通常还要有精确的测量</li>
<li>根据观察结果提出假设模型</li>
<li>根据模型预测未来的事件</li>
<li>继续观察并核实预测的准确性</li>
<li>如此反复直到确认预测和观察一致</li>
</ul>

<h3 id="toc_23">1.4.3 数学模型</h3>

<p>一个程序运行的总时间主要和两点有关：</p>

<ul>
<li>执行每条语句的耗时</li>
<li>执行每条语句的频率</li>
</ul>

<h3 id="toc_24">1.4.4 增长数量级的分类</h3>

<p>对增长数量级常见假设的总结：</p>

<table>
<thead>
<tr>
<th>描述</th>
<th>增长的数量级</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>

<tbody>
<tr>
<td>常数级别</td>
<td>1</td>
<td>普通语句</td>
<td>将两个数相加</td>
</tr>
<tr>
<td>对数级别</td>
<td>\(logN\)</td>
<td>二分策略</td>
<td>二分查找</td>
</tr>
<tr>
<td>线性级别</td>
<td>\(N\)</td>
<td>循环</td>
<td>找出最大元素</td>
</tr>
<tr>
<td>线性对数级别</td>
<td>\(NlogN\)</td>
<td>分治</td>
<td>归并排序</td>
</tr>
<tr>
<td>平方级别</td>
<td>\(N^2\)</td>
<td>双层循环</td>
<td>检查所有元素对</td>
</tr>
<tr>
<td>立方级别</td>
<td>\(N^3\)</td>
<td>三层循环</td>
<td>检查所有三元组</td>
</tr>
<tr>
<td>指数级别</td>
<td>\(2^N\)</td>
<td>穷举查找</td>
<td>检查所有子集</td>
</tr>
</tbody>
</table>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-07-124852.jpg" alt=""/></p>

<h3 id="toc_25">1.4.5 设计更快的算法</h3>

<p>学习程序的增长数量级的一个重要动力就是为了帮助我们为同一个问题设计更快地算法。</p>

<h3 id="toc_26">1.4.7 注意事项</h3>

<h4 id="toc_27">1.4.7.1 大常数</h4>

<p>在首项近似中，我们一般会忽略低级项中的常数系数，但这可能是错的。例如，当我们取函数 \(2N^2+cN\) 的近似为 ~\(2N^2\) 时，我们的假设是 c 很小。如果事实不是这样（比如 c 可能是 \(10^6\)），该近似就是错误的。因此，我们要对可能的大常数保持敏感。</p>

<h4 id="toc_28">1.4.7.2 非决定性的内循环</h4>

<p>内循环是决定性因素的假设并不是总正确的。错误的成本模型可能无法得到真正的内循环，问题规模 \(N\) 也许没有大到对指令的执行频率的数学描述中的首项大大超过其他低级项并可以忽略它们的程度。有些程序在内循环之外也有大量指令需要考虑。</p>

<h4 id="toc_29">1.4.7.3 指令时间</h4>

<p>每条指令执行所需的时间总是相同的假设并不总是正确的。例如，大多数现在计算机系统都会使用缓存技术来组织内存，在这种情况下访问大数组中的若干个并不相邻元素所需的时间可能很长。</p>

<h3 id="toc_30">1.4.8 处理对于输入的依赖</h3>

<h4 id="toc_31">1.4.8.1 输入模型</h4>

<p>一种方法是更加小心地对我们所要解决的问题所处理的输入建模。使用这种方法的困难主要有两点：</p>

<ol>
<li>输入模型可能是不切实际的</li>
<li>对输入的分析可能极端困难</li>
</ol>

<h4 id="toc_32">1.4.8.3 随机化算法</h4>

<p>为性能提供保证的一种重要的方法是引入随机性。例如，快速排序算法在最坏情况系的性能是平方级别的，但通过随机打乱输入，根据概率我们能够保证它的性能是线性对数的。每次运行该算法，它所需的时间均不相同，但它的运行时间超过超过线性对数级别的可能性小到可以忽略。与此类似，用于符号表的散列算法在最坏情况下的性能是线性级别的，但根据概率我们可以保证它的运行时间是常数级别的。</p>

<h4 id="toc_33">1.4.8.5 均摊分析</h4>

<p>相应地，提供性能保证的另一种方法是通过记录所有操作的总成本并除以操作总数来将成本均摊。在这里，我们可以允许执行一些昂贵的操作，但保持所有操作的平均数成本较低。</p>

<h2 id="toc_34">1.5 案例研究：union-find 算法</h2>

<p>为了说明我们设计和分析算法的基本方法，我们现在来学习一个具体的例子。我们的目的是强调以下几点：</p>

<ul>
<li>优秀的算法因为能够解决实际问题而变得更为重要；</li>
<li>高效算法的代码也可以很简单；</li>
<li>理解某个实现的性能特地拿是一项有趣而令人满足的挑战；</li>
<li>在解决同一个问题的多种算法之间进行选择时，科学方法是一种重要的工具；</li>
<li>迭代式改进能够让算法的效率越来越高。</li>
</ul>

<h2 id="toc_35">2.1 初级排序算法</h2>

<h4 id="toc_36">2.1.1.3 额外的内存使用</h4>

<p>排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类：</p>

<ul>
<li>原地排序算法</li>
<li>需要额外内存空间来存储的其他排序算法</li>
</ul>

<h3 id="toc_37">2.1.2 选择排序</h3>

<p>选择排序两个鲜明的特点：</p>

<ol>
<li>运行时间和输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶地发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长。</li>
<li>数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——交换次数和数组的大小是线性关系。</li>
</ol>

<p>选择排序实现：</p>

<pre><code class="language-python">def selection_sort(a):
    N = len(a)
    for i in range(N):
        mi = i
        for j in range(i+1, N):
            if a[j] &lt; a[mi]:
                mi = j
        a[i], a[mi] = a[mi], a[i]
    return a
</code></pre>

<h3 id="toc_38">2.1.3 插入排序</h3>

<p>与选择排序一样，当前索引左边的所有元素都是有序的，但它们最终的最终位置还不确定，为了给更小元素腾出空间，它们可能会被移动。但是当前索引到达数组的右端时，数组排序就完成了。</p>

<p>与选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快得多。</p>

<p>插入排序对于实际应用中常见的某些类型的非随机数组很有效。当插入排序对一个有序数组进行排序，运行时间是线性的。</p>

<pre><code class="language-python">def insertion_sort(a):
    for i in range(1, len(a)):
        for j in range(i, 0, -1):
            if a[j] &lt; a[j-1]:
                a[j], a[j-1] = a[j-1], a[j]
    return a
</code></pre>

<p>对于 1 到 N-1 之间的每一个 i，将 a[i] 与 a[0] 到 a[i-1] 中比它小的所有元素依次有序地交换。在索引 i 由左向右变化的过程中，它左侧的元素总是有序的，所以当 i 到达数组的右端时排序就完成了。</p>

<p>我们要考虑的更一般的情况是部分有序的数组。<strong>倒置</strong>指的是数组中的两个顺序颠倒的元素。比如 E X A M P L E 中有 11 对倒置：E-A X-A X-M X-P X-L X-E M-L M-E ... 如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。</p>

<p>下面是几种典型的部分有序的数组：</p>

<ul>
<li>数组中每个元素都距离它的最终位置都不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>

<p>插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置数量很少时，插入排序很可能比本章中的其他任何算法都要快。</p>

<p>要大幅提高插入排序的速度并不难，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素。</p>

<h3 id="toc_39">2.1.6 希尔排序</h3>

<p>为了展示初级排序算法性质的价值，我们将学习一种基于插入排序的快速排序算法。对于大规模乱序数组插入排序很慢，因为它智慧交换相邻的元素，因此元素只能一点一点地从数组的一段移动到另一端。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终插入排序将局部有序的数组排序。</p>

<p>希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。换句话说，h 有序数组就是 h 个独立的有序数组编织在一起组成的一个数组，如下图所示。</p>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-09-115612.jpg" alt=""/></p>

<p>实现希尔排序的一种方法是对于每个 h，用插入排序将 h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在 h-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可。这样，希尔排序的实现就转化为了一个类似于插入排序但是用不同增量的过程。</p>

<p>希尔排序更高效的原因是它权衡了子数组的规模性和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。子数组部分有序的程度取决于递增序列的选择。</p>

<pre><code class="language-python">def shell_sort(a):
    h = 1
    while h &lt; len(a) / 3:
        h = 3 * h + 1
    while h &gt;= 1:
        for i in range(int(h), len(a)):
            for j in range(i, int(h)-1, -1):
                if a[j] &lt; a[j - int(h)]:
                    a[j], a[j - int(h)] = a[j - int(h)], a[j]
        h = h / 3
    return a
</code></pre>

<h2 id="toc_40">2.2 归并排序</h2>

<p>归并：即将两个有序数组归并成一个更大的有序数组。</p>

<h3 id="toc_41">2.2.1 原地归并的抽象方法</h3>

<p>实现归并的一种直截了当的方法是将两个不同的有序数组归并到第三个数组中。</p>

<p>但是，当用归并将一个很大的数组排序时，我们需要进行很多次归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题。我们更希望有一种能够在原地归并的方法，这样就可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。</p>

<p>原地归并的抽象方法：</p>

<pre><code class="language-python">
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python Cookbook]]></title>
    <link href="http://forresthcang.com/wiki/14872260244406.html"/>
    <updated>2017-02-16T14:20:24+08:00</updated>
    <id>http://forresthcang.com/wiki/14872260244406.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">调用父类的方法</h2>

<p><code>super()</code> 的常见用法：</p>

<ol>
<li>在 <code>__init__()</code> 方法中确保父类被正确初始化了</li>
<li>另外一个常见用法出现在覆盖 Python 特殊方法的代码中</li>
</ol>

<p>Ex:</p>

<pre><code class="language-python">class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith(&#39;_&#39;):
            super().__setattr__(name, value) # Call original __setattr__
        else:
            setattr(self._obj, name, value)
</code></pre>

<p>在上面代码中，<code>__setattr__()</code> 的实现包含一个名字检查。如果某个属性名以 <code>_</code> 开头，就通过 <code>super()</code> 调用原始的 <code>__setattr__()</code>，否则的话就委派给类内部的代理对象 <code>self._obj</code> 去处理。这看上去有点意思，因为就算没有显式指明某个类的父类，<code>super()</code> 仍然可以有效地工作。</p>

<h2 id="toc_1">子类中扩展 Property</h2>

<p>在自雷中扩展一个 property 可能会引起很多不易察觉的问题，因为一个 property 其实是 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法的几何，而不是单个的方法。因此，当你扩展一个 property 的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中的一个。</p>

<h2 id="toc_2">创建新的类或实例属性</h2>

<p>描述器：一个实现了三个核心的属性访问操作（get, set, delete）的类，分别为 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code> 这三个特殊的方法。这些方法接受一个实例作为输入，之后相应的操作实例实例底层的字典。</p>

<p>为了使用一个描述器，需要将这个描述器的实例作为类属性放到一个类的定义中。</p>

<p>一个基于描述器的高级代码：</p>

<pre><code class="language-python"># Descriptor for a type-checked attribute
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(&#39;Expected &#39; + str(self.expected_type))
        instance.__dict__[self.name] = value
    def __delete__(self, instance):
        del instance.__dict__[self.name]

# Class decorator that applies it to selected attributes
def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            # Attach a Typed descriptor to the class
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 风格指南笔记]]></title>
    <link href="http://forresthcang.com/wiki/14871569977647.html"/>
    <updated>2017-02-15T19:09:57+08:00</updated>
    <id>http://forresthcang.com/wiki/14871569977647.html</id>
    <content type="html">
<![CDATA[<ul>
<li>
<a href="#toc_0">函数与方法装饰器</a>
</li>
<li>
<a href="#toc_1">线程</a>
</li>
<li>
<a href="#toc_2">威力过大的特性</a>
</li>
<li>
<a href="#toc_3">注释</a>
<ul>
<li>
<a href="#toc_4">模块</a>
</li>
<li>
<a href="#toc_5">函数和方法</a>
</li>
<li>
<a href="#toc_6">类</a>
</li>
<li>
<a href="#toc_7">块注释和行注释</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">类</a>
</li>
<li>
<a href="#toc_9">TODO 注释</a>
</li>
<li>
<a href="#toc_10">导入格式</a>
</li>
<li>
<a href="#toc_11">访问控制</a>
</li>
<li>
<a href="#toc_12">命名</a>
</li>
</ul>


<h2 id="toc_0">函数与方法装饰器</h2>

<ul>
<li>优点：优雅的在函数上指定一些转换，该转换可能减少一些重复代码，保持已有函数不变（enforce invariants）</li>
<li>缺点：装饰器可以在函数的参数或返回值上执行任何操作，这可能导致让人惊异的隐藏行为。而且，装饰器在导入时执行。从装饰器代码的失败中恢复更加不可能。</li>
<li>结论：如果好处很显然，就明智而谨慎的使用装饰器。装饰器应该遵守和函数一样的导入和命名规则。装饰器的 Python 文档应该清晰的说明函数是一个装饰器。请为装饰器编写单元测试。<strong>避免装饰器自身对外界的依赖（即不要依赖于文件、socket、数据库连接等）</strong>。</li>
</ul>

<h2 id="toc_1">线程</h2>

<p>优先使用 Queue 模块的 <code>Queue</code> 数据类型作为线程间的数据通信方式。另外，使用 threading 模块及其锁原语（locking primitives）。了解条件变量的合适使用方式，这样你就可以使用 <code>threading.Condition</code> 来取代低级级别的锁了。</p>

<h2 id="toc_2">威力过大的特性</h2>

<ul>
<li>Tip：避免使用这些特性</li>
<li>优点：强大的语言特性，能让你的代码更紧凑</li>
<li>缺点：使用这些很 cool 的特性十分诱人，但不是绝对必要。使用奇技淫巧的代码将更加难以阅读和调试。开始可能还好，但当你回顾代码，它们可能比那些稍长一点但是更直接的代码更加难以理解。</li>
<li>结论：在你的代码中避免使用这些特性。</li>
</ul>

<h2 id="toc_3">注释</h2>

<p>Python 有一种独一无二的注释方式：使用文档字符串。文档字符串是包、模块、类或函数的第一个语句。这些字符串可以通过对象的 <code>__doc__</code> 成员被自动提取，并且被 <code>pydoc</code> 所用。</p>

<p>组织方式：</p>

<ul>
<li>第一行以句号、问号或惊叹号结尾的概述（或者改文档字符串只有单纯的一行）</li>
<li>接着是一个空行</li>
<li>接着是文档字符串的剩余部分，它应当与文档字符串的第一行的第一个引号对齐</li>
</ul>

<h3 id="toc_4">模块</h3>

<p>每个文件应该包含一个许可样板。根据项目使用的许可（例如：Apache 2.0、BSD、LGPL、GPL）选择合适的样板。</p>

<h3 id="toc_5">函数和方法</h3>

<p>一个函数必须要有文档字符串，除非它满足以下条件：</p>

<ol>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ol>

<p>文档字符串应该包含函数做什么，以及输入和输出的详细描述。通常，<strong>不应该描述「怎么做」，除非是一些复杂的算法</strong>。文档字符串应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。<strong>对于复杂的代码，在代码旁边加注释胡比使用文档字符串更有意义</strong>。</p>

<p>关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面入下文所示，每节应该以一个标题行开始。标题行以冒号结尾，除标题行外，节的其他内容应被缩进 2 个空格。</p>

<ul>
<li>Args：列出每个每个参数的名字，并在名字后面使用一个冒号和空格，分隔对该参数的描述。如果描述太长超过了单行 80 个字符，使用 2 或者 4 个空格的悬挂缩进。<strong>描述应该包括所需的类型和含义</strong>。如果一个函数接受<code>可变长参数列表</code>或者<code>任意关键字参数</code>，应该详细列出这两者。</li>
<li>Returns（或者 Yields，用于生成器）：描述返回值的类型和语义，如果函数返回 None，这一部分可以省略。</li>
<li>Raises：列出与接口有关的所有异常。</li>
</ul>

<p>例子：</p>

<pre><code class="language-python">def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):
    &quot;&quot;&quot;Fetches rows from a Bigtable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by big_table.  Silly things may happen if
    other_silly_variable is not None.

    Args:
        big_table: An open Bigtable Table instance.
        keys: A sequence of strings representing the key of each table row
            to fetch.
        other_silly_variable: Another optional variable, that has a much
            longer name than the other args, and which does nothing.

    Returns:
        A dict mapping keys to the corresponding table row data
        fetched. Each row is represented as a tuple of strings. For
        example:

        {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),
         &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),
         &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}

        If a key from the keys argument is missing from the dictionary,
        then that row was not found in the table.

    Raises:
        IOError: An error occurred accessing the bigtable.Table object.
    &quot;&quot;&quot;
    pass
</code></pre>

<h3 id="toc_6">类</h3>

<p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公有属性，那么文档中应该有一个属性段，并且应该遵守和函数参数相同的格式。</p>

<pre><code class="language-python">class SampleClass(object):
    &quot;&quot;&quot;Summary of class here.

    Longer class information....
    Longer class information....

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
    &quot;&quot;&quot;

    def __init__(self, likes_spam=False):
        &quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;
        self.likes_spam = likes_spam
        self.eggs = 0

    def public_method(self):
        &quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;
</code></pre>

<h3 id="toc_7">块注释和行注释</h3>

<p><strong>最需要些注释的是代码中那些技巧性的部分</strong>。对于复杂的操作，应该在其操作开始前写上若干行注释，对于不是一幕了然的代码，应该在其行尾添加注释。</p>

<p>为了提高可读性，注释至少应该离开代码 2 个空格。</p>

<p><strong>绝对不要描述代码</strong>，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么。</p>

<h2 id="toc_8">类</h2>

<p>如果一个类不继承自其它类，就显式的从 object 继承，嵌套类也一样。</p>

<h2 id="toc_9">TODO 注释</h2>

<p>TODO 注释应该在所有开头处包含「TODO」字符串，紧跟着的是用括号括起来的你的名字，email 地址或者其他标识符。接着必须有一行注释，解释要做什么。</p>

<p>Example：</p>

<pre><code class="language-python"># TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.
# TODO(Zeke) Change this to use relations.
</code></pre>

<p>如果你的 TODO 是「将来做某事」的形式，那么请确保你包含了一个指定的日期或者一个特定的时间。</p>

<h2 id="toc_10">导入格式</h2>

<p>每个导入应该独占一行。导入总应该放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前，导入应该按照从最通用到最不通用的顺序分组：</p>

<ol>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序制定导入</li>
</ol>

<p>每种分组中，应该根据每个模块的完整包路径按字典顺序排序，忽略大小写。</p>

<h2 id="toc_11">访问控制</h2>

<p>字啊 Python 中，对于琐碎又不太重要的访问函数，你应该直接使用公有变量来取代它们，这样可以避免额外的函数调用开销。当添加更多的功能时，你可以用属性（property）来保持语法的一致性。</p>

<p>另一方面，如果访问更复杂，或者变量的访问开销很显著，那么你应该使用像 <code>get_foo()</code> 和 <code>set_foo()</code> 这样的函数调用。如果之前的代码行为允许通过属性（property）访问，那么久不要井新的访问函数与属性绑定。这样，任何试图通过老方法访问变量的代码就没法运行，使用者也就会意识到复杂性发生了变化。</p>

<h2 id="toc_12">命名</h2>

<p>Python 之父 Guido 推荐的规范：</p>

<p><img src="media/14871569977647/14872190162425.jpg" alt=""/></p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Python Tutorial Reading Notes]]></title>
    <link href="http://forresthcang.com/wiki/14824095038232.html"/>
    <updated>2016-12-22T20:25:03+08:00</updated>
    <id>http://forresthcang.com/wiki/14824095038232.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">Data Structures</h2>

<h3 id="toc_1">More on Lists</h3>

<ul>
<li><code>list.append(x)</code>: Equivalent to <code>a[len(a):] = [x]</code></li>
<li><code>list.extend(L)</code>: Extend the list by appending all the items in the given list. Equivalent to <code>a[len(a):] = L</code></li>
<li><code>list.insert(i, x)</code>: The first argument is the index of the element before which to insert. <code>a.insert(len(a), x)</code> == <code>a.append(x)</code>.</li>
<li><code>list.remove(x)</code>: Remove the first item form the list whose value is x.</li>
<li><code>list.pop([i])</code>: Remove the item at the given position in the list, and return it. If no index is specified, <code>a.pop()</code> removes and returns the last item in the list.（parameters with square brackets are optional）</li>
<li><code>list.clear()</code>: Remove all item from the list. Equivalent to <code>del a[:]</code></li>
<li><code>list.index(x)</code>: Return the index in the list of the first item whose value is x.</li>
<li><code>list.count(x)</code>: Return the number of times x appears in the list.</li>
<li><code>list.sort(key=None, reverse=False)</code>: Sort the items of the list in place.</li>
<li><code>list.reverse()</code>: Reverse the elements of the list in place.</li>
<li><code>list.copy()</code>: Return a shallow copy of the list. Equivalent to <code>a[:]</code>.</li>
</ul>

<h4 id="toc_2">Using Lists as Stacks</h4>

<p>Use <code>append</code> and <code>pop</code>.</p>

<h4 id="toc_3">Using Lists as Queues</h4>

<p>Lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from beginning of a list is slow.</p>

<p>Better to use <code>collections.deque</code>.</p>

<h4 id="toc_4">List Comprehensions</h4>

<ul>
<li><code>x = [item for item in series]</code></li>
<li><code>x = [do_something(item) for item in series if expression]</code></li>
</ul>

<h4 id="toc_5">Nested List Comprehensions</h4>

<p>The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension.</p>

<p>Example: <code>[[row[i] for row in matrix] for i in range(4)]</code>.</p>

<h4 id="toc_6">The <code>del</code> statement</h4>

<p>Remove an item from a list given its index. (Do not return a value) It can also remove slices from a list.</p>

<p><code>del</code> can also be used to delete entire variables: <code>del a</code>.</p>

<h3 id="toc_7">Tuples and Sequences</h3>

<p>Tuples are <code>immutable</code>, and usually contain a heterogeneous sequence of elements that are accessed via unpacking or indexing. List are <code>mutable</code>, and their element are usually homogeneous and are accessed by iterating over the list.</p>

<ul>
<li>Empty tuples are constructed by and empty pair of parentheses: <code>empty = ()</code></li>
<li>A tuple with one item is constructed by following a value with a comma:     <code>sigleton = &#39;hello&#39;,</code></li>
</ul>

<p>The statement <code>t = 1, 2, &#39;hello&#39;</code> is an example of <code>tuple packing</code>: the values are packed together in a tuple. The reverse operation is also possible: <code>x, y, z = t</code>.</p>

<h3 id="toc_8">Sets</h3>

<p><code>{}</code> or <code>set()</code> function can be used to create sets. Note: to create an empty set you have to use <code>set()</code>, not <code>{}</code>; the latter creates an empty dictionary.</p>

<p>Example: </p>

<pre><code class="language-python">a = set(&#39;abracadabra&#39;)
b = set(&#39;alacazam&#39;)
</code></pre>

<ul>
<li><code>a - b</code>: letters in a but not in b</li>
<li><code>a | b</code>: letters in either a or b</li>
<li><code>a &amp; b</code>: letters in both a and b</li>
<li><code>a ^ b</code>: letters in a or b but not both</li>
</ul>

<p>Similaryly to list comprehensions, set comprehensions are also supported.</p>

<h3 id="toc_9">Dictionaries</h3>

<p>Dictionaries are indexed by keys, which can be any immutable type; strings and numbers can slways be keys. Tuples can be used as keys if they contain only one kind of item. You can&#39;t use use lists as keys, since lists can be modified in place using index assignments, slice assignments, or method like append() and extend().</p>

<p>It is best to think of a dictionary as an unordered set of <code>key: value</code> pairs.</p>

<ul>
<li><code>del</code> can delete a <code>key: value</code></li>
<li><code>list(d.keys())</code> on a dictionary returns a list of all the keys used in the dictionary, in arbitrary order (if you want it sorted, use <code>sortted(d.keys())</code> instead).</li>
<li>To check whether a single key is in the dictionary, use the <code>in</code> keyword. (<code>in</code> or <code>not in</code>)</li>
<li>Dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: <code>{x: x**2 for x in range(10)}</code></li>
<li>When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments: <code>dic(sape=1, guido=2, jack=3)</code> =&gt; <code>{&#39;sape&#39;: 1, &#39;jack&#39;: 3, &#39;guido&#39;: 2}</code></li>
</ul>

<h3 id="toc_10">Looping Techniques</h3>

<p>When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the items() method.</p>

<pre><code class="language-python">knights = {&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;}
for k, v in knights.items():
    print(k, v)
</code></pre>

<p>When looping through a sequence, the position index and correspoding value can be retrieved at the same time using the <code>enumerate()</code> function.</p>

<pre><code class="language-python">for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):
    print(i, v)
</code></pre>

<p>To loop over two or more sequences at the same time, the entries can be paired with the <code>zip()</code> function.</p>

<pre><code class="language-python">numbers = [1, 2, 3]
names = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
for number, name in zip(numbers, names):
    print(&#39;Number: {0}, Name: {1}&#39;.format(number, name))
</code></pre>

<p>To loop over a sequence in sorted order, use the <code>sorted()</code> function which return a new sorted list while leaving the source unaltered. <code>for item in soted(list)</code></p>

<p>It is sometimes tempting to change a list while you are looping over it; however, it is often simple and safer to create a new list instead.</p>

<h3 id="toc_11">More on Conditions</h3>

<ul>
<li><code>in</code> and <code>not in</code>: check whether a value occurs (or not) in a sequence.</li>
<li><code>is</code> and <code>is not</code>: compare whether two objects are really the same object; this only matters for mutable objcts like lists.</li>
<li>Comparisons can be chained. <code>a &lt; b == c</code></li>
<li><code>and</code> and <code>or</code> are <code>short-circuit</code> operators</li>
</ul>

<h3 id="toc_12">Comparing Sequences and Other Types</h3>

<p>The comparison uses lexicographical ordering.</p>

<h2 id="toc_13">Modules</h2>

<p>A module is a file containing Python definitions and statements. The file name is the module name with the suffix <code>.py</code> appended. Within a module, the module&#39;s name (as a string) is available as the value of the global variable <code>__name__</code>.</p>

<h3 id="toc_14">More on Modules</h3>

<p>Note that in general the practice of importing <code>*</code> from a module is frowned upon, since it often causes poorly readable code. (It ok to use in interactive sessions.)</p>

<p>It&#39;s one module you want to test interactively, use <code>importlib.reload()</code>.</p>

<pre><code class="language-python">import importlib
importlib.reload(modulename)
</code></pre>

<h4 id="toc_15">Executing modules as scripts</h4>

<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    code
</code></pre>

<p>This is often used either to provide a convenient user interface to a module, or for testing purposes (running the module as a script executes a test suite).</p>

<h4 id="toc_16">The Module Search Path</h4>

<p>When a module named <em>spam</em> is imported, the interpreter first searches for a built-in module with that name. If not found, it then searches for a file named <code>spam.py</code> in a list of directories given by the variable <code>sys.path</code>, it is initialized from these locations:</p>

<ul>
<li>The directory containing the input script (or the current directory when no file is specified).</li>
<li><code>PYTHONPATH</code> (a list of directory names, with the same syntax as the shell variable <em>PATH</em>).</li>
<li>The installation-dependent default.</li>
</ul>

<p>After initialization, Python programs can modify <code>sys.path</code>. The directory containing the script being run is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in that directory will be loaded instead of modules of the same name in the library directory.</p>

<h4 id="toc_17">&quot;Compiled&quot; Python files</h4>

<p>Python caches the compiled version of each module in the <code>__pycache__</code> directory. It generally contains the Python version number. This naming convention allows compiled modules from dirrerent release and different version of Python to coexist. (Example: <code>__pycache__/fib.python-27.pyc</code>)</p>

<p>Python check the modification date of the source against the compiled version to see if it&#39;s out of date and needs to be recompiled.</p>

<h3 id="toc_18">Standard Modules</h3>

<pre><code class="language-python">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
&#39;&gt;&gt;&gt; &#39;
&gt;&gt;&gt; sys.ps2
&#39;... &#39;
&gt;&gt;&gt; sys.ps1 = &#39;C&gt; &#39;
C&gt; print(&#39;Yuck!&#39;)
Yuck!
</code></pre>

<p>The variable <code>sys.path</code> is a list of strings that determines the interpreter&#39;s search path for modules. You can modify it using standard list operations.</p>

<h3 id="toc_19">The <code>dir()</code> Function</h3>

<p>The built-in function <code>dir()</code> is used to find out which names a module defines.</p>

<p>Without arguments, <code>dir()</code> lists the names you have defined currently.</p>

<p>It list all types of names: variable, modules, functions, etc.</p>

<h2 id="toc_20">Input and Output</h2>

<h3 id="toc_21">Methods of File Objects</h3>

<p>It is good practice to use the <code>with</code> keyword when dealing with file objects. This has the advantage that the file is properly closed after its suite finishes, even if an exceptiohn is raissed on the way. It is also much shorter thatn writing equivalent <code>try-finally</code> blocks:</p>

<pre><code class="language-python">with open(&#39;workfile&#39;, &#39;r&#39;) as f:
    read_data = f.read()
</code></pre>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift学习笔记：控制流]]></title>
    <link href="http://forresthcang.com/wiki/14635617646524.html"/>
    <updated>2016-05-18T16:56:04+08:00</updated>
    <id>http://forresthcang.com/wiki/14635617646524.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">Repeat-While</h2>

<p><code>repeat-while</code> 在 <code>while</code> 判断循环条件之前，先执行一次循环的代码块，和其他语言中的 <code>do-while</code> 是类似的。</p>

<pre><code class="language-swift">repeat {
    statements
} while condition
</code></pre>

<h2 id="toc_1">Switch</h2>

<p><code>switch</code> 语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，<code>switch</code>语句会执行对应的代码。当有可能的情况较多时，通常用 <code>switch</code> 语句替换 <code>if</code> 语句。</p>

<p><code>switch</code> 语句必须是完备的，每一个可能的值都必须至少有一个 case 分支与之对应。在某些不可能涵盖所有值得情况下，你可以使用默认（<code>default</code>）分支满足该要求，这个默认分支必须在 <code>switch</code> 语句的最后面。</p>

<h3 id="toc_2">不存在隐式的贯穿（No Implicit Fallthrouth）</h3>

<p>和其他语言的 Switch 不同，在 Swift 中，当匹配的 case 分支中的代码执行完毕后，程序会终止 <code>switch</code> 语句，而不会继续执行下一个 case 分支。所以，不需要再 case 分支中显式地使用 <code>break</code> 语句。</p>

<p>如果想要贯穿到特定的 case 分支中，请使用 <code>fallthrough</code> 语句。</p>

<h3 id="toc_3">区间匹配</h3>

<p>case 分支的模式也可以是一个值得区间。</p>

<h3 id="toc_4">元组</h3>

<p>可以只用元组在同一个 <code>switch</code> 语句中测试多个值，元组中的元素可以是值，也可以是区间，使用下划线 <code>_</code> 来匹配所有可能的值。</p>

<h3 id="toc_5">值绑定</h3>

<p>case 分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了。</p>

<p>case 分支的模式可以使用 <code>where</code> 语句来判断额外的条件。</p>

<h2 id="toc_6">控制转移语句</h2>

<h3 id="toc_7">continue</h3>

<p><code>continue</code> 语句告诉一个循环体立刻停止本次循环迭代，重现开始下次循环迭代。</p>

<h3 id="toc_8">break</h3>

<p><code>break</code> 语句会立即结束整个控制流的执行。</p>

<h2 id="toc_9">带标签的语句</h2>

<p>在 Swift 中，你可以在循环体和 <code>switch</code> 代码块中嵌套循环体和 <code>switch</code> 代码块来创造复杂的控制流结构。然而，循环体和 <code>switch</code> 代码块亮着都可以使用 <code>break</code> 语句来提前结束整个方法。因此，显式地指明 <code>break</code> 语句想要终止是哪个循环体或者 <code>switch</code> 代码块，会很有用。</p>

<p>为了实现这个目的，可以使用标签来标记一个循环体或者 <code>switch</code> 代码块，当使用 <code>break</code> 或者 <code>continue</code> 时，带上这个标签，可以控制该标签代表对象的中断或者执行。</p>

<p>语法：</p>

<pre><code class="language-swift">label name: while condition { statements }
</code></pre>

<h2 id="toc_10">提前退出</h2>

<p>像 <code>if</code> 语句一样， <code>guard</code> 的执行取决于一个表达式的布尔值。我们可以使用 <code>guard</code> 语句来要求条件必须为真时，以执行 <code>guard</code> 语句后的代码。不同于 <code>if</code> 语句，一个 <code>guard</code> 语句总是有一个 <code>else</code> 分句，如果条件不为真则执行 <code>else</code> 分句中的代码。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：字符串和字符]]></title>
    <link href="http://forresthcang.com/wiki/14634546001476.html"/>
    <updated>2016-05-17T11:10:00+08:00</updated>
    <id>http://forresthcang.com/wiki/14634546001476.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">字符串是值类型</h2>

<p>使用字符串会进行值拷贝。</p>

<p>在实际的编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着将字符串作为值类型的同时可以获得极高的性能。</p>

<h2 id="toc_1">Working with Characters</h2>

<p>可以使用 <code>for-in</code> 循环来遍历字符串中的 <code>characters</code> 属性来获取每一个字符的值。</p>

<p>字符串可以通过传递一个值类型为 <code>Character</code> 的数组作为自变量来初始化。</p>

<h2 id="toc_2">连接字符串和字符</h2>

<p>字符串可以通过加法运算符相加在一起创建一个新的字符串。</p>

<p><code>append()</code> 方法可以将一个字符附加到一个字符串变量的尾部。</p>

<h2 id="toc_3">Unicode</h2>

<h3 id="toc_4">Unicode Scalars（Unicode 标量）</h3>

<p>Swift 的 <code>String</code> 类型是基于 Unicode 标量建立的。Unicode 标量是对应字符或者修饰符的唯一的 21 位数字。</p>

<p>Unicode 码位（code poing）的范围是 <code>U+0000</code> 到 <code>U+1F425</code> 或者 <code>U+E000</code> 到 <code>U+10FFFF</code>。Unicode 标量不包括 Unicode 代理项（surrogate pair）码位，其码位范围是 <code>U+D800</code> 到 <code>U+DFFF</code>。</p>

<p>注意，并不是所有的 21 位 Unicode 标量都表示一个字符，因为有一些标量是留作未来分配的。</p>

<h3 id="toc_5">字符串字面量的特殊字符（Special Character in String Literals）</h3>

<p><img src="media/14634546001476/14634553799193.jpg" alt=""/></p>

<h3 id="toc_6">可扩展的字形群集（Extended Grapheme Clusters）</h3>

<p>每一个 Swift 的 Character 类型代表一个可扩展的字形群。一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。</p>

<h3 id="toc_7">计算字符数量</h3>

<p>如果想要获得一个字符串中的 <code>Character</code> 值得数量，可以使用字符串的 <code>characters</code> 属性的 <code>count</code> 属性。</p>

<p>注意在 Swift 中，使用可拓展的字符群集作为 <code>Character</code> 值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>

<h2 id="toc_8">访问和修改字符串</h2>

<h3 id="toc_9">字符串索引</h3>

<p>使用 <code>startIndex</code> 属性可以获取一个 <code>String</code> 的第一个 <code>Character</code> 的索引。使用 <code>endIndex</code> 属性可以获取最后一个 <code>Character</code> 的后一个位置的索引，所以 <code>endIndex</code> 属性不能作为一个字符串的有效下标。如果 <code>String</code> 是空串，两者是相等的。</p>

<p><code>String.Index.predecessor()</code> 获得前一个索引，<code>successor()</code> 获得后一个索引。</p>

<p><code>Characters</code> 属性的 <code>indices</code> 属性会创建一个包含全部索引的范围（<code>Range</code>），用来在一个字符串中访问单个字符。</p>

<h3 id="toc_10">插入和删除</h3>

<ul>
<li><code>insert(_:atIndex:)</code>：在一个字符串的制定索引插入一个字符</li>
<li><code>insertContentsOf(_:at:)</code>：在一个字符串的指定索引插入一个字符串</li>
<li>`removeAtIndex(_:)：在一个字符串的指定索引删除一个字符</li>
<li><code>removeRange(_:)</code>：在一个字符串的指定索引删除一个子字符串</li>
</ul>

<h2 id="toc_11">比较字符串</h2>

<h3 id="toc_12">字符串/字符相等</h3>

<p>使用 <code>==</code> 和 <code>!=</code> 来比较两个字符/字符串是否相等/不等。</p>

<h3 id="toc_13">前缀/后缀相等</h3>

<ul>
<li><code>hasPrefix(_:)</code></li>
<li><code>hasSuffix(_:)</code></li>
</ul>

<h2 id="toc_14">字符串的 Unicode 表示形式（Unicode Representations of Strings）</h2>

<p>当一个 Unicode 字符串被写进文本文件或其他存储时，字符串中的 Unicode 标量会用 Unicode 定义的几种编码格式（encoding forms）编码。每一个字符串中的小块编码都被称为 <code>code units</code>。这些包括 UTF-8,UTF-16,UTF-32 编码格式。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：属性]]></title>
    <link href="http://forresthcang.com/wiki/14631242333306.html"/>
    <updated>2016-05-13T15:23:53+08:00</updated>
    <id>http://forresthcang.com/wiki/14631242333306.html</id>
    <content type="html">
<![CDATA[<p>属性将值跟特定的类、结构或枚举关联。存储常量或变量作为实例的一部分，而计算属性（不是存储）一个值。</p>

<ul>
<li>计算属性：类、结构体、枚举</li>
<li>存储属性：类、结构体</li>
</ul>

<h2 id="toc_0">存储属性</h2>

<h3 id="toc_1">延迟存储属性</h3>

<p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 <code>lazy</code> 来标记一个延迟存储属性。</p>

<p>必须将延迟存储属性声明称变量，因为属性的初始值可能在实例构造完成之后才会得到。<strong>而常量属性在构造过程完成之前必须要有初始值，因此无法声明称延迟属性。</strong></p>

<p>延迟属性很有用，当属性的值依赖于在实例的构造过程结束后才会知道影响值得外部因素时，或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它。</p>

<h2 id="toc_2">计算属性</h2>

<p>计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>

<h3 id="toc_3">便捷 setter 声明</h3>

<p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>。</p>

<h3 id="toc_4">只读计算属性</h3>

<p>只有 getter 没有 setter 的计算属性就是<strong>只读计算属性</strong>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</p>

<h2 id="toc_5">属性观察器</h2>

<p>属性观察器监控和响应属性值的变化，每次属性被设置新的值都会调用属性观察器，即使新值和当前值相同的时候也不例外。</p>

<p>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值得变化。</p>

<ul>
<li><code>willSet</code> 在新的值被设置之前调用</li>
<li><code>didSet</code> 在新的值被设置之后立即调用</li>
</ul>

<p><code>willSet</code> 观察器会将新的属性值作为常量参数传入，在 <code>willSet</code> 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 <code>newValue</code> 表示。</p>

<p><code>didSet</code> 观察器会将旧的属性值作为参数传入，可以为该参数名或者使用默认参数名 <code>oldValue</code>。如果在 <code>didSet</code> 方法中再次对该属性赋值，那么新值会覆盖旧的值。</p>

<p>父类的属性在子类的构造器中被赋值时，它在父类中的 <code>willSet</code> 和 <code>didSet</code> 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。</p>

<p>如果将属性通过 in-out 方式传入函数， <code>willSet</code> 和 <code>didSet</code> 也会被调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。</p>

<h2 id="toc_6">全局变量和局部变量</h2>

<p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</p>

<p>全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记 <code>lazy</code>   修饰符。</p>

<p>局部范围的常量或变量从不延迟计算。</p>

<h2 id="toc_7">类型属性</h2>

<p>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 <code>lazy</code> 修饰符。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：集合类型]]></title>
    <link href="http://forresthcang.com/wiki/14627836147810.html"/>
    <updated>2016-05-09T16:46:54+08:00</updated>
    <id>http://forresthcang.com/wiki/14627836147810.html</id>
    <content type="html">
<![CDATA[<p>Swift 语言提供 Arrays、Sets 和 Dictionaries 三种基本的集合类型来存储数据合集。数组（Array）是有序数据的集；集合（Sets）是无序无重复数据的集；字典（Dictionaries）是无序的键值对的集。</p>

<p><img src="media/14627836147810/14627837494241.jpg" alt=""/></p>

<h2 id="toc_0">集合的可变性</h2>

<p>在我们不需要改变集合的时候创建不可变集合是很好的实践（使用 <code>let</code>），如此 Swift 编译器可以优化我们创建的集合。</p>

<h2 id="toc_1">数组</h2>

<h3 id="toc_2">创建一个带有默认值的数组</h3>

<p>Swift 中的 Array 类型提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（count）和适当类型的初始值（repeatedValue）传入数组构造函数：</p>

<pre><code class="language-swift">var threeDoubles = [Double](count: 3, repeatedValue: 0.0)
</code></pre>

<h3 id="toc_3">通过两个数组相加创建一个数组</h3>

<p>我们可以使用加法操作符来组合两种已经存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来。</p>

<h3 id="toc_4">访问和修改数组</h3>

<p><code>isEmpty</code> 检查数组是否为空。</p>

<p>使用加法赋值运算符（<code>+=</code>）可以直接在数组后面添加一个或多个拥有相同类型的数据项。</p>

<p>调用数组的 <code>insert(_:atIndex:)</code>方法来在某个具体的索引值之前添加数据项。</p>

<h3 id="toc_5">数组的遍历</h3>

<p>如果我们同事需要每个数据项的值和索引值，可以使用 <code>enumerate()</code> 方法来进行数组遍历。<code>enumerate()</code> 返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历。</p>

<h2 id="toc_6">集合（Sets）</h2>

<p>集合用来存储相同类型且没有确定顺序的值。</p>

<p>Swift 中的 <code>Set</code> 类型被桥接到 <code>Foundation</code> 中的 <code>NSset</code> 类。</p>

<h3 id="toc_7">集合类型的哈希值</h3>

<p>一个类型为了存储在集合中，该类型必须是可哈希化得——也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如<code>a=b</code>，因此必须是<code>a.hashValue = b.hashValue</code>。</p>

<p>Swift 的所有基本类型默认都是可哈希化的，可以作为集合的值类型或者字典的键类型。没有关联值的枚举成员值默认也是可哈希化的。</p>

<p>你可以使用你自定义的类型作为集合的值类型或者是字典的键的类型，但你需要使你的自定义类型符合 Swift 标准库中的 <code>Hashable</code> 协议。符合 <code>Hashable</code> 协议的类型需要提供一个类型为 <code>Int</code> 的可读属性 <code>hashValue</code>。由类型的 <code>hashValue</code> 属性返回的值不需要再同一程序的不同执行周期或者不同程序之间保持相同。</p>

<p>因为 <code>hashValue</code> 协议符合 <code>Equatable</code> 协议，所以符合该协的类型也必须停工一个 <code>==</code> 运算符的实现。这个 <code>Equatable</code> 协议要求任何符合 <code>==</code> 实现的实例间都是一种相等的关系，也就是说，对于 a, b, c 三个值来说，必须满足下面三种情况：</p>

<ul>
<li>自反性：a == a</li>
<li>对称性：a == b, b == a</li>
<li>传递性：a == b &amp;&amp; b == c, a == c</li>
</ul>

<h3 id="toc_8">遍历一个集合</h3>

<p>Swift 中的 <code>Set</code> 类型没有确定的顺序，为了按照特定顺序来遍历一个 <code>Set</code> 中的值可以使用 <code>sort()</code> 方法，它将根据提供的序列返回一个有序集合。</p>

<pre><code class="language-swift">for genre in favoriteGenres.sort() {...}
</code></pre>

<h3 id="toc_9">集合操作</h3>

<p><img src="media/14627836147810/14627853736261.jpg" alt=""/></p>

<p><img src="media/14627836147810/14627854301808.jpg" alt=""/></p>

<p><img src="media/14627836147810/14627854415802.jpg" alt=""/></p>

<h2 id="toc_10">字典</h2>

<p>字典中的数据项并没有具体顺序。</p>

<p>Swift 中 Dictionary 类型被桥接到 Foundation 中的 NSDictionary 类。</p>

<h3 id="toc_11">字典遍历</h3>

<ol>
<li>元组方式</li>
<li>dic.keys</li>
<li>dic.values</li>
</ol>

<p>如果我们只是需要某个字典的键值集合来作为某个接受 Array 实例的 API 的参数，可以直接使用 keys 或 values 属性构造一个新数组。</p>

<pre><code class="language-swift">let airportCodes = [String](airports.keys)
let airportNames = [String](airports.values)
</code></pre>

<p>Swift 的字典类型书无序集合类型。为了以特定的顺序便利字典的键或值，可以对字典的 keys 或 values 属性使用 <code>sort()</code> 方法。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：基本运算符]]></title>
    <link href="http://forresthcang.com/wiki/14627831551017.html"/>
    <updated>2016-05-09T16:39:15+08:00</updated>
    <id>http://forresthcang.com/wiki/14627831551017.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">空合运算符（NIl Coalescing Operator）</h2>

<p>空合运算符（<code>a ?? b</code>）将对可选类型 <code>a</code> 进行空判断，如果 <code>a</code> 包含一个值就进行解封，否则就返回一个默认值 <code>b</code>。表达式 <code>a</code> 必须是 Optional 类型。默认值 <code>b</code> 的类型必须要和 <code>a</code> 存储值的类型保持一致。</p>

<p>空合运算符是对以下代码的简短表达方法：</p>

<pre><code class="language-swift">a != nil ? a! : b
</code></pre>

<p>如果 <code>a</code> 为非空值（non-nil），那么 <code>b</code> 值将不会被计算，这也就是所谓的短路求值。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：高级运算符]]></title>
    <link href="http://forresthcang.com/wiki/14623593987548.html"/>
    <updated>2016-05-04T18:56:38+08:00</updated>
    <id>http://forresthcang.com/wiki/14623593987548.html</id>
    <content type="html">
<![CDATA[<p>与 C 语言中的算术运算符不同，Swift 中的算数运算符默认是不会溢出的。所有溢出行为都会被捕获并报告错误。</p>

<p>如果想让系统允许溢出行为，可以选择使用 Swift 中另一套默认支持溢出的运算符，所有的这些溢出运算符都是以<code>&amp;</code>开头的。</p>

<p>在 Swift 中可以自由地定义中缀、前缀、后缀和赋值运算符，以及相应的优先级与结合性。这些运算符在代码中可以像预定义的运算符一样使用，我们甚至可以扩展已有的类型以支持自定义的运算符。</p>

<h2 id="toc_0">位运算符</h2>

<p>位运算符可以操作数据结构中每个独立的比特位。它们通常被用在底层开发中，比如图形编程和创建设备驱动。位运算符在处理外部资源的原始数据时也十分有用，比如对自定义通信协议传输的数据进行编码和解码。</p>

<h2 id="toc_1">按位取反运算符</h2>

<p>按位取反运算符 <code>~</code> 可以对一个数值的全部比特位进行取反：</p>

<p><img src="media/14623593987548/14623598448776.jpg" alt=""/></p>

<p>按位取反运算符是一个前缀运算符，需要直接放在运算的数之前，并且它们之间不能添加任何空格。</p>

<h2 id="toc_2">按位与运算符</h2>

<p>按位与运算符 <code>&amp;</code> 可以对两个数的比特位进行合并。</p>

<p><img src="media/14623593987548/14623599594230.jpg" alt=""/></p>

<h2 id="toc_3">按位或运算符</h2>

<p>按位或运算符 <code>|</code> 可以对两个数的比特位进行比较。</p>

<p><img src="media/14623593987548/14623600296926.jpg" alt=""/></p>

<h2 id="toc_4">按位异或运算符</h2>

<p>按位异或运算符 <code>^</code> 可以对两个数的比特位进行比较。</p>

<p><img src="media/14623593987548/14623601009498.jpg" alt=""/></p>

<h2 id="toc_5">按位左移、右移运算符</h2>

<p>按位左移运算符 <code>&lt;&lt;</code> 和按位右移运算符 <code>&gt;&gt;</code> 可以对一个数的所有位进行制定位数的左移和右移，但是需要遵守下面定义的规则。</p>

<p>对一个数进行按位左移或按位右移，相当于对这个数进行乘以2或除以2的运算。</p>

<h3 id="toc_6">无符号整数的移位运算</h3>

<p>规则：</p>

<ol>
<li>已经存在的位按制定的位数进行左移和右移</li>
<li>任何因移位而超出整型存储范围的位都会被丢弃</li>
<li>用 <code>0</code> 来填充移位后产生的空白位</li>
</ol>

<p>这种方法称为<code>逻辑移位</code>。</p>

<p><img src="media/14623593987548/14623603707110.jpg" alt=""/></p>

<h3 id="toc_7">有符号整数的移位运算</h3>

<p>对比无符号整数，有符号整数的移位运算相对复杂得多，这种复杂性源于有符号整数的二进制表现形式。（为了简单起见，以下的示例都是基于 8 比特位的有符号整数的，但是其中的原理对于任何位数的有符号整数都是通用的。）</p>

<p>有符号整数使用第 1 个比特位（通常被称为符号位）来表示这个数的正负。符号位为 <code>0</code> 代表正数，为 <code>1</code> 代表负数。</p>

<p>其余的比特位（通常被称为数值位）存储了实际的值。有符号正整数和无符号数的存储方式是一样的，都是从 <code>0</code> 开始算起。</p>

<p>负数的存储方式略有不同。它存储的值得绝对值等于 <code>2</code> 的 <code>n</code> 次方减去它的实际值（也就是数值位表示的值），这里的 <code>n</code> 是数值位的比特位。一个 8 比特位的数有 7 个比特位是数值位，所以是 <code>2</code> 的 <code>7</code> 次方，即 <code>128</code>。</p>

<p><img src="media/14623593987548/14623612131011.jpg" alt=""/></p>

<p>负数的表示通常被称为二进制的补码表示。用这种表示方法来表示负数乍看起来有点奇怪，但它有几个优点。</p>

<p>首先，如果想对 <code>-1</code> 和 <code>-4</code> 进行加法运算，我们只需要将这两个数的全部 8 个比特位进行相加，并将计算结果中超出 8 位的数值丢弃：</p>

<p><img src="media/14623593987548/14623613337905.jpg" alt=""/></p>

<p>其次，使用二进制补码可以使负数的按位左移和右移运算得到跟正数相同的结果，即每向左移一位就将自身的数值乘以 2，每向右移一位就将自身除以 2。要达到此目的，对有符号整数的右移有一个额外的规则：</p>

<p><img src="media/14623593987548/14623615004005.jpg" alt=""/></p>

<p>这个行为可以确保有符号整数的符号位不会因为右移运算而改变，这通常被称为<code>算数移位</code>。</p>

<h2 id="toc_8">溢出运算符</h2>

<p>在默认情况下，当向一个整数赋予超过它容量的值时，Swift 默认会报错，而不是生成一个无效的数。这个行为为我们在运算过大或者过小的数的时候提供了额外的安全性。</p>

<p>当然，也可以选择让系统在数值溢出的时候采取截断处理，而非报错。可以使用 Swift 提供的三个溢出运算符来让系统支持整数溢出运算。这些运算符都是以 <code>&amp;</code> 开头的：</p>

<ul>
<li>溢出加法 <code>&amp;+</code></li>
<li>溢出减法 <code>&amp;-</code></li>
<li>溢出乘法 <code>&amp;*</code></li>
</ul>

<h2 id="toc_9">数值溢出</h2>

<p>数值有可能出现上溢或者下溢。</p>

<p><img src="media/14623593987548/14623618680616.jpg" alt=""/></p>

<p><img src="media/14623593987548/14623618951341.jpg" alt=""/></p>

<p>溢出也会发生在有符号整型数值上。在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也要参与计算，正如按位移位运算符所描述的。</p>

<p><img src="media/14623593987548/14623621538611.jpg" alt=""/></p>

<p>对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数编程最小的数。同样的，当发生下溢时，它们会从所能容纳的最小数编程最大的数。</p>

<h2 id="toc_10">优先级和结合性</h2>

<p>运算符的优先级使得一些运算符优先于其他运算符，高优先级的运算符会先被计算。</p>

<p>结合性定义了相同优先级的运算符是如何结合的，也就是说，是与左边结合为一组，还是与右边结合为一组。</p>

<h2 id="toc_11">运算符函数</h2>

<p>类和结构体可以为现有的运算符提供自定义的实现，这通常被称为运算符重载。</p>

<h2 id="toc_12">前缀和后缀运算符</h2>

<p>类与结构体也能提供标准单目运算符的实现。单目运算符只运算一个值。当运算符出现在值之前时，它就是前缀的，而当它出现在值之后时，它就是后缀的。</p>

<p>要实现前缀或者后缀运算符，需要在声明运算符函数的时候在 <code>func</code> 关键字之前制定 <code>prefix</code> 或者 <code>postfix</code> 修饰符。</p>

<h2 id="toc_13">符合赋值运算符</h2>

<p>符合赋值运算符将赋值运算符 <code>=</code> 与其他运算符进行结合。在实现的时候，需要把运算符的左参数设置成 <code>inout</code> 类型，因为这个参数的值会在运算符函数内被直接修改。</p>

<p>还可以将赋值与 <code>prefix</code> 或 <code>postfix</code> 修饰符结合起来，例如实现自增运算符 <code>++</code>。</p>

<p>注：不能对默认的赋值运算符 <code>=</code> 进行重载。只有组合赋值运算符可以被重载。同样地，也无法对三目条件运算符 <code>a ? b : c</code> 进行重载。</p>

<h2 id="toc_14">等价运算符</h2>

<p>自定义的类和结构体没有对等价运算符进行默认实现，等价运算符通常被称为相等运算符 <code>==</code> 与不等运算符 <code>!=</code>。对于自定义类型，Swift 无法判断其是否相等，因为「相等」的含义取决于这些自定义类型在你的代码中所扮演的角色。</p>

<p>为了使等价运算符能对自定义的类型进行判等运算，需要为其提供自定义的实现，实现的方法与其他中缀运算符一样。</p>

<h2 id="toc_15">自定义运算符</h2>

<p>除了实现标准运算符，在 Swift 中还可以声明和实现自定义运算符。</p>

<p>新的运算符要使用 <code>operato</code> 关键字在全局作用域内进行定义，同时还要指定 <code>prefi</code>、<code>infix</code>或者<code>postfix</code>修饰符：</p>

<pre><code class="language-swift">prefix operator +++ {}
</code></pre>

<h2 id="toc_16">自定义中缀运算符的优先级和结合性</h2>

<p>自定义的中缀运算符也可以指定优先级和结合性。</p>

<p>结合性可取的值有 <code>left</code>、<code>right</code>和<code>none</code>。当做结合运算符跟其他相同优先级的左结合运算符写在一起时，会跟左边的值进行结合。同理，当右结合运算符跟其他相同优先级的右优先级运算符写在一起时，会跟右边的值进行结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。</p>

<p>结合性的默认值是 <code>none</code>，优先级的默认值是 <code>100</code>。</p>

<p>下面的例子定义了一个新的中缀运算符 <code>+-</code>，此运算符的结合性为 <code>left</code>，并且它的优先级为 <code>140</code>：</p>

<pre><code class="language-swift">infix operator +- { associativity left precedence 140 }
</code></pre>

<p>注：当定义前缀与后缀运算符的时候，我们并没有制定优先级。然而，如果对同一个值同时使用前缀和后缀运算符，则后缀运算符会先参与运算。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：构造过程]]></title>
    <link href="http://forresthcang.com/wiki/14617168482919.html"/>
    <updated>2016-04-27T08:27:28+08:00</updated>
    <id>http://forresthcang.com/wiki/14617168482919.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">存储属性的初始赋值</h2>

<p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储属性的值不能处于一个未知的状态。</p>

<p>当你为存储属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者（property observers）。</p>

<h2 id="toc_1">默认属性值</h2>

<p>如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更加紧密。</p>

<h2 id="toc_2">参数的内部名称和外部名称</h2>

<p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字。</p>

<p>因为构造器并不像函数和方法那样在括号前有一个可辨别的名字。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。</p>

<h2 id="toc_3">不带外部名的构造器参数</h2>

<p>如果你不希望构造器的某个参数提供外部名字，你可以使用下划线（<code>_</code>）来显式描述它的外部名。</p>

<h2 id="toc_4">可选属性类型</h2>

<p>可选类型的属性将自动化初始为 <code>nil</code>，表示这个属性是有意在初始化时设置为空的。</p>

<h2 id="toc_5">构造过程中常量属性的修改</h2>

<p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。</p>

<h2 id="toc_6">默认构造器</h2>

<p>如果结构体或类的所有属性都有默认值，同时没有定义的构造器，那么 Swift 将会给这些结构体或类提供一个默认构造器。这个默认构造器将简单创建一个所有属性都设置为默认值得实例。</p>

<h2 id="toc_7">结构体的逐一成员构造器</h2>

<p>如果<strong>结构体</strong>没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储属性没有默认值。</p>

<p>注：类类型没有逐一成员构造器。</p>

<h2 id="toc_8">值类型的构造器代理</h2>

<p>构造器可以通过调用其他构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重用。</p>

<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其他构造器。类则不同，它可以继承自其他类，这意味着类有责任保证其所有继承的存储属性在构造时也能正确的初始化。</p>

<p>对于值类型，可以使用 <code>self.init</code> 在自定义的构造器中引用类型中的其他构造器。并且你只能在构造器内部调用 <code>self.init</code>。</p>

<p>如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器。</p>

<p>加入你希望默认构造器、逐一成员构造器以及你自己的定义的构造器都能用来创建实例，可以将自定义的构造器写到 extension 中，而不是写在值类型的原始定义中。</p>

<h2 id="toc_9">类的继承和构造过程</h2>

<p>类里面的所有存储属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。</p>

<h2 id="toc_10">制定构造器和便利构造器</h2>

<p>制定构造器（designated initializers）是类中最主要的构造器。一个制定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。</p>

<p>便利构造器（convenience initializers）是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并未其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值得实例。</p>

<h2 id="toc_11">制定构造器和便利构造器的语法</h2>

<p>类的制定构造器的写法和值类型的简单构造器一样。</p>

<p>便利构造器也采用相同样式的写法，但需要在 <code>init</code> 关键字之前放置 <code>convenience</code> 关键字。</p>

<h2 id="toc_12">类的构造器代理规则</h2>

<p>为了简化制定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>

<ol>
<li>指定构造器必须调用其直接分类的指定构造器。</li>
<li>便利构造器必须调用同一类中定义的其他构造器。</li>
<li>便利构造器必须最终导致一个制定构造器被调用。</li>
</ol>

<blockquote>
<p>制定构造器必须总是向上代理<br/>
便利构造器必须总是横向代理</p>
</blockquote>

<p><img src="media/14617168482919/14617189856135.jpg" alt=""/></p>

<h2 id="toc_13">两段式构造过程</h2>

<p>Swift 中类的构造过程包含两个阶段。</p>

<ol>
<li>每个存储属被引用它们类指定的一个初始值；</li>
<li>当每个存储属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储属性。</li>
</ol>

<p>两段式构造过程让构造器更加安全，同时在整个类层级结构中给与了每个类完全的灵活性。两段式构造可以防止属性在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>

<p>Swift 编译器将执行4中有效的安全检查，以确保两段式构造能不错地完成：</p>

<ol>
<li>制定构造器必须保证它坐在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。</li>
<li>制定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没有这么做，制定构造器赋予的新值将被父类中的构造器覆盖。</li>
<li>便利构造器必须先代理调用同一类中的其他构造器，然后再为任意属性赋新值。如果没有这么做，便利构造器赋予的新值将被同一类中的其他制定构造器所覆盖。</li>
<li>构造器在第一阶段完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 <code>self</code> 作为一个值。</li>
</ol>

<h2 id="toc_14">构造器的继承和重写</h2>

<p>Swift 中的子类默认情况下不会继承父类的构造器，这种机制可以防止一个父类的简单构造器被一个更专业的类继承，并被错误地用来创建子类实例。</p>

<p>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 <code>override</code> 修饰符。</p>

<p>当你重写一个父类的指定构造器时，你总是需要写 <code>override</code> 修饰符，即使你的子类将父类的制定构造器重写为便利构造器。</p>

<p>相反，如果你编写了一个和父类便利构造器想匹配的子类构造器，由于子类不能直接调用父类的便利构造器，因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中「重写」一个父类便利构造器时，不需要加 <code>override</code> 前缀。</p>

<p>子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。</p>

<h2 id="toc_15">构造器的自动继承</h2>

<p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>

<h2 id="toc_16">可失败构造器</h2>

<p>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。</p>

<p>为了妥善处理这种构造过程中可能会失败的情况，你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器，其语法为在 <code>init</code> 关键字后面添加问好 <code>init?</code>。</p>

<p>可失败构造器的参数名和参数类型，不能与其他非可失败构造器的参数名、及参数类型相同。</p>

<p>可失败构造器会创建一个类型为自身类型的可选类型对象。你通过 <code>return nil</code> 语句来表明可失败构造器在何种情况下应该失败。</p>

<p>注：严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用 <code>return nil</code> 表明可失败构造器失败，而不要用关键字 <code>return</code> 来表明构造器成功。</p>

<h2 id="toc_17">枚举类型的可失败构造器</h2>

<p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>

<h2 id="toc_18">带原始值的枚举类型的可失败构造器</h2>

<p>带原始值的枚举类型会自带一个可失败构造器 <code>init?(rawValue:)</code>，该可失败构造器有一个名为 <code>rawValue</code> 的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能和某个枚举成员的原始值匹配，则该构造器会构成相应的枚举成员，否则构造失败。</p>

<h2 id="toc_19">构造失败的传递</h2>

<p>类、结构体、枚举的可失败构造器可以横向代理到乐熊中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>

<p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p>

<h2 id="toc_20">重写一个可失败构造器</h2>

<p>如果其他的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>

<h2 id="toc_21">必要构造器</h2>

<p>在类的构造器前添加 <code>required</code> 修饰符表明所有该类的子类都必须实现该构造器。</p>

<p>在重写父类中必要的指定构造器时，不需要添加 <code>override</code> 修饰符。</p>

<h2 id="toc_22">通过闭包或函数设置属性的默认值</h2>

<p>如果某个存储属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数就会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>

<p>这种类型的闭包或函数通常会创建一个跟属性相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>

<pre><code class="language-swift">class SomeClass {
    let someProperty: SomeType = {
        // 在这个闭包中给 someProperty 创建一个默认值
        // someValue 必须和 SomeType 类型相同
        return someValue
    }()
}
</code></pre>

<p>闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包，如果忽略了这对括号，相当于闭包本身作为值赋给了属性，而不是将闭包的返回值赋值给属性。</p>

<p>注：如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其他部分还没有初始化。这意味着你不能再闭包里访问其他属性，即使这些属性有默认值，同样，你也不能使用隐式的 <code>self</code> 属性，或者调用任何实例方法。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：访问控制]]></title>
    <link href="http://forresthcang.com/wiki/14616582990381.html"/>
    <updated>2016-04-26T16:11:39+08:00</updated>
    <id>http://forresthcang.com/wiki/14616582990381.html</id>
    <content type="html">
<![CDATA[<p>访问控制可以限定其他源文件或者模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。</p>

<h2 id="toc_0">模块和源文件</h2>

<p>Swift 中的访问控制模型基于模块和源文件这两个概念。</p>

<p>模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。一个模块可以使用 <code>import</code> 关键字导入另一个模块。</p>

<p>在 Swift 中，Xcode 的每个 target（例如框架或应用程序）都被当做独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。</p>

<p>源文件就是 Swift 中的代码源文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>

<h2 id="toc_1">访问级别</h2>

<ul>
<li><code>public</code>：可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为 <code>public</code> 级别。</li>
<li><code>internal</code>：可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为 <code>internal</code> 级别。</li>
<li><code>private</code>：限制实体只能在所在的源文件内部使用。使用 <code>private</code> 级别可以隐藏某些功能的实现细节。</li>
</ul>

<p>Swift 中的 <code>private</code> 访问级别不同于其他语言，它的范围限于源文件，而不是声明范围内。这就意味着，一个类型可以访问其所在源文件中的所有 <code>private</code> 实体，但是如果它的扩展定义在其他源文件中，那么它的扩展就不能访问它在这个源文件中定义的 <code>private</code> 实体。</p>

<h2 id="toc_2">访问级别的基本原则</h2>

<p>Swift 中的访问级别遵循一个基本原则：不可以在某个实体定义访问级别更高的实体。</p>

<h2 id="toc_3">默认访问级别</h2>

<p>不显式制定，默认为 <code>internal</code> 级别，有一些例外。</p>

<h2 id="toc_4">单 target 应用程序的访问级别</h2>

<p>当你编写一个单 target 应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 <code>internal</code> 即可。但是，你也可以使用 <code>private</code> 级别，用于隐藏一些功能的实现细节。</p>

<h2 id="toc_5">框架的访问级别</h2>

<p>当你开发框架时，就需要把一些对外的接口定义为 <code>public</code> 级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为 <code>public</code> 的接口，就是这个框架的 API。</p>

<h2 id="toc_6">单元测试 target 的访问级别</h2>

<p>当你的应用程序包含单元测试 target 时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有 <code>public</code> 级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 <code>@testable</code> 特性，然后在允许测试的编译设置（Build Options -&gt; Enable Testability）下编译这个应用程序模块，单元测试 target 就可以访问应用程序模块中所有 <code>internal</code> 级别的实体。</p>

<h2 id="toc_7">元组类型</h2>

<p>元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为 <code>private</code> 类型，那么这个元组的访问级别为 <code>private</code>。</p>

<h2 id="toc_8">函数类型</h2>

<p>函数的访问级别根据访问级别最严格的参数类型或返回值类型的访问级别来决定。</p>

<h2 id="toc_9">枚举类型</h2>

<p>枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。</p>

<p>枚举定义中的任何原始值或关联值得类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 <code>internal</code> 访问级别的枚举中定义 <code>private</code> 级别的原始值类型。</p>

<h2 id="toc_10">子类</h2>

<p>子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 <code>internal</code>，子类的访问级别就不能是 <code>public</code>。</p>

<p>可以通过重写为继承来的类成员提供更高的访问级别。</p>

<h2 id="toc_11">Getter 和 Setter</h2>

<p>常量、变量、属性、下标的 <code>Getters</code> 和 <code>Setters</code> 的访问级别和它们所属类型的访问级别相同。</p>

<p><code>Setter</code> 的访问级别可以低于对应的 <code>Getter</code> 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 <code>var</code> 或 <code>subscript</code> 关键字之前，你可以通过 <code>privat(set)</code> 或 <code>internal(set)</code> 为它们的写入权限制定更低的访问级别。</p>

<h2 id="toc_12">构造器</h2>

<p>自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一例外的是必要构造器，它的访问级别必须和所属类型的访问级别相同。</p>

<p>如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。</p>

<h2 id="toc_13">默认构造器</h2>

<p>默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 <code>public</code>。如果一个类型被指定为 <code>public</code> 级别，那么默认构造器的访问级别将为 <code>internal</code>。如果你希望一个 <code>public</code> 级别的参数类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 <code>public</code> 访问级别的无参构造器。</p>

<h2 id="toc_14">结构体默认的成员逐一构造器</h2>

<p>如果结构体中任意存储型的访问级别为 <code>private</code>，那么该结构体默认的成员逐一构造器的访问级别就是 <code>private</code>。否则，这种构造器的访问级别依然是 <code>internal</code>。</p>

<h2 id="toc_15">协议</h2>

<p>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。</p>

<p>如果你定义了一个 <code>public</code> 访问级别的协议，那么该协议的所有实现也会是 <code>public</code> 访问级别。这一点不同于其他类型，例如，当类类型是 <code>public</code> 访问级别时，其成员的访问级别却只是 <code>internal</code>。</p>

<h2 id="toc_16">协议继承</h2>

<p>如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：错误处理]]></title>
    <link href="http://forresthcang.com/wiki/14616560170869.html"/>
    <updated>2016-04-26T15:33:37+08:00</updated>
    <id>http://forresthcang.com/wiki/14616560170869.html</id>
    <content type="html">
<![CDATA[<h2 id="toc_0">表示并抛出错误</h2>

<p>Swift 中的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。</p>

<p>抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用 <code>throws</code> 关键字。</p>

<h2 id="toc_1">处理错误</h2>

<p>当某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。</p>

<p>当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上 <code>try</code> 关键字，或者 <code>try?</code> 或 <code>try!</code> 这种变体。</p>

<p>和其他语言中的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，<code>throw</code> 语句的性能特性是可以和 <code>return</code> 语句媲美的。</p>

<h2 id="toc_2">用 throwing 函数传递错误</h2>

<p>为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表后面加上 <code>throws</code> 关键字。一个标有 <code>throws</code> 关键字的函数被称作 throwing 函数。</p>

<p>一个 throwing 函数可以在其 nebula 抛出错误，并将错误传递到函数被调用时的作用域。</p>

<h2 id="toc_3">用 Do-Catch 处理错误</h2>

<p>可以使用一个 <code>do-catch</code> 语句运行一段闭包代码来处理错误。如果在 <code>do</code> 子句中的代码抛出了一个错误，这个错误会与 <code>catch</code> 子句做匹配，从而决定哪条子句能处理它。</p>

<h2 id="toc_4">将错误转换成可选值</h2>

<p>可以使用 <code>try?</code> 通过将错误转换成一个可选值来处理错误。如果在评估 <code>try?</code> 表达式时一个错误被抛出，那么表达式的值就是 <code>nil</code>。</p>

<h2 id="toc_5">禁用错误传递</h2>

<p>有时候你知道某个 throwing 函数实际上在运行的时候是不会抛出错误的，在这种情况下，你可以在表达式前面写 <code>try!</code> 来禁用错误传递，这会把调用包装在一个断言不会有错误抛出的运行时断言中。如果实际上抛出了错误，你会得到一个运行时错误。</p>

<h2 id="toc_6">指定清理操作</h2>

<p>可以使用 <code>defer</code> 语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如 <code>return</code> 或者 <code>break</code> 的语句。</p>

<p>例如，你可以用 <code>defer</code> 语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p>

<p><code>defer</code> 语句将代码的执行延迟到当前的作用域退出之前。该语句由 <code>defer</code> 关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如 <code>break</code> 或是 <code>return</code> 语句，或是抛出一个错误。</p>

<p>延迟执行的操作会按照它们被指定时的顺序的相反顺序执行。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：泛型]]></title>
    <link href="http://forresthcang.com/wiki/14615726488001.html"/>
    <updated>2016-04-25T16:24:08+08:00</updated>
    <id>http://forresthcang.com/wiki/14615726488001.html</id>
    <content type="html">
<![CDATA[<p>泛型代码让你能够根据自定义的需求，编写出使用与任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽闲的方式来表达代码的意图。</p>

<h2 id="toc_0">类型约束</h2>

<p>类型约束可以指定一个类型参数必须继承指定类，或者符合一个特定的协议或协议组合。</p>

<p>当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。</p>

<h2 id="toc_1">类型约束语法</h2>

<p>你可以在一个类型参数名后面防止一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）：</p>

<pre><code class="language-swift">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) {
    // 这里是泛型函数的函数体部分
}
</code></pre>

<p>上面这个函数有两个类型参数。第一个类型参数 <code>T</code>，有一个要求是 <code>T</code> 必须是 <code>SomeClass</code> 子类的类型约束，同理，第二个必须符合 <code>SomeProtocol</code> 协议的类型约束。</p>

<h2 id="toc_2">关联类型</h2>

<p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占3位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 <code>associatedtype</code> 关键字来指定关联类型。</p>
]]>
    </content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 学习笔记：协议]]></title>
    <link href="http://forresthcang.com/wiki/14615467401189.html"/>
    <updated>2016-04-25T09:12:20+08:00</updated>
    <id>http://forresthcang.com/wiki/14615467401189.html</id>
    <content type="html">
<![CDATA[<p>协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。</p>

<h2 id="toc_0">协议语法</h2>

<p>拥有父类的类在采纳协议时，应该将父类名放在协议名之前，以逗号分隔。</p>

<h2 id="toc_1">属性要求</h2>

<p>协议不指定属性是存储属性还是计算属性，它只指定属性的名称和类型。此外，协议还指定属性是可读还是可读可写的。</p>

<p>如果要求属性是可读可写的，那么该属性不能是常量属性或只读的计算属性；如果协议要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</p>

<p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型后面加上 <code>{set get}</code> 来表示属性是可读可写的，可读属性则用 <code>{ get }</code> 来表示。</p>

<p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。</p>

<h2 id="toc_2">方法要求</h2>

<p>在协议中定义类方法的时候，总是使用 <code>static</code> 关键字作为前缀。</p>

<h2 id="toc_3">Mutating 方法要求</h2>

<p>有时需要在方法中改变方法所属的实例。将 <code>mutating</code> 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属性的实例以及实例的任意属性的值。</p>

<p>实现协议中的 <code>mutating</code> 方法时，若是类类型，则不用写 <code>mutating</code> 关键字。而对于结构体和枚举，则必须写 <code>mutating</code> 关键字。</p>

<h2 id="toc_4">构造器要求</h2>

<p>协议可以要求采纳协议的类型实现制定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但是不需要写花括号和构造器实体。</p>

<h2 id="toc_5">构造器要求在类中的实现</h2>

<p>你可以在采纳协议的类中实现构造器，无论是作为制定构造器，还是作为便利构造器，你都必须为构造器实现表上 <code>required</code> 修饰符。</p>

<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符。</p>

<h2 id="toc_6">可失败构造器要求</h2>

<h2 id="toc_7">协议作为类型</h2>

<p>尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用：</p>

<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中得元素类型</li>
</ul>

<h2 id="toc_8">委托（代理）模式</h2>

<p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。</p>

<p>委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保采纳协议的类型能提供这些类型。委托模式可以用来响应特定的动作，或者接受外部数据源提供的数据，而无需关心外部数据源的类型。</p>

<h2 id="toc_9">通过扩展添加协议一致性</h2>

<p>即便无法修改源代码，依然可以通过扩展令已有类型采纳并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。</p>

<p>通过扩展采纳并符合协议，和在原始定义中采纳并符合协议的效果完全相同。</p>

<h2 id="toc_10">通过扩展采纳协议</h2>

<p>当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展来采纳该协议。</p>

<h2 id="toc_11">协议类型的集合</h2>

<p>协议类型可以在数组或者字典这样的集合中使用。</p>

<h2 id="toc_12">协议的继承</h2>

<p>协议能够继承一个或者多个其他协议，可以在继承的协议的基础上正价新的要求。</p>

<h2 id="toc_13">类类型专属协议</h2>

<p>你可以在洗衣的继承列表中，通过添加 <code>class</code> 关键字来限制协议只能被类类型采纳，而结构体或枚举不能采纳该协议。<code>class</code> 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前。</p>

<pre><code class="language-swift">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {
    // 这里是类类型专属协议的定义部分
}
</code></pre>

<h2 id="toc_14">协议合成</h2>

<p>有时候需要同时采纳多个协议，你可以将多个协议采用 <code>protocol&lt;SomeProtocol, AnotherProtocol&gt;</code> 这样的格式进行组合，称为协议合成（protocol composition）。你可以在<code>&lt;&gt;</code>张罗列任意多个你想要采纳的协议，以逗号分隔。</p>

<p>协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个旨在局部作用域中的有效临时协议中。</p>

<h2 id="toc_15">检查协议一致性</h2>

<p>你可以使用类型转换中描述的 <code>is</code> 和 <code>as</code> 操作符来检查协议一致性，即是否符合某协议，并且可以转换到制定的协议类型。</p>

<ul>
<li><code>is</code> 用来检查视力是否符合某个协议，符合返回 <code>true</code>。</li>
<li><code>as?</code> 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 <code>nil</code>。</li>
<li><code>as!</code> 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li>
</ul>

<h2 id="toc_16">可选的协议要求</h2>

<p>协议可以定义可选要求，采纳协议的类型可以选择是否实现这些要求。在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 <code>(Int) -&gt; String</code> 的方法会变成 <code>((Int) -&gt; String)?</code>。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p>

<p>可选的协议要求只能用在标记 <code>@objc</code> 特性的协议中。该特性表示协议将暴露给 Objective-C 代码。即使你不打算和 OC 有什么交互，如果你想要指定可选的协议要求，都那么还是要为协议加上 <code>@obj</code> 特性。</p>

<h2 id="toc_17">协议扩展</h2>

<p>协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需再每个采纳协议的类型中都重复同样的实现，也无需使用全局函数。</p>

<h2 id="toc_18">提供默认实现</h2>

<p>可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果采纳协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中默认实现被使用。</p>

<h2 id="toc_19">为协议扩展添加限制条件</h2>

<p>在扩展协议的时候，可以指定一些限制条件，只有采纳协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 <code>where</code> 子句来描述。</p>
]]>
    </content>
  </entry>
  
</feed>
