
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  Network - Wiki
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="Wiki" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">Wiki</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:forresthcang.com/wiki" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="index.html">Home</a></li>
  <li><a href="archives.html">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15078822029815.html">全站必备：网络编程基础</a></h1>
			<p class="meta"><time datetime="2017-10-13T16:10:02+08:00" 
			pubdate data-updated="true">2017/10/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>笔记来源：<a href="http://blog.jobbole.com/110041/">http://blog.jobbole.com/110041/</a></p>

<h2 id="toc_0">关于网络</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14889309726832.html">计算机网络</a></h1>
			<p class="meta"><time datetime="2017-03-08T07:56:12+08:00" 
			pubdate data-updated="true">2017/3/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">HTTP 协议</a>
<ul>
<li>
<a href="#toc_1">HTTP 的特性</a>
</li>
<li>
<a href="#toc_2">HTTP 报文</a>
<ul>
<li>
<a href="#toc_3">请求报文</a>
</li>
<li>
<a href="#toc_4">响应报文</a>
</li>
<li>
<a href="#toc_5">条件 GET</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">持久连接</a>
</li>
<li>
<a href="#toc_7">HTTP Pipelining（HTTP 管线化）</a>
</li>
<li>
<a href="#toc_8">会话跟踪</a>
</li>
<li>
<a href="#toc_9">跨站攻击</a>
<ul>
<li>
<a href="#toc_10">如何防范 CSRF 攻击？</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">XSS（Cross Site Scripting，跨站脚本攻击）</a>
<ul>
<li>
<a href="#toc_12">如何防御 XSS 攻击？</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_13">TCP 协议</a>
<ul>
<li>
<a href="#toc_14">TCP 协议的特性</a>
</li>
<li>
<a href="#toc_15">三次握手与四次握手</a>
</li>
<li>
<a href="#toc_16">SYN 攻击</a>
<ul>
<li>
<a href="#toc_17">什么是 SYN 攻击（SYN Flood）？</a>
</li>
<li>
<a href="#toc_18">如何检测 SYN 攻击？</a>
</li>
<li>
<a href="#toc_19">如何防御 SYN 攻击？</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_20">IP 协议</a>
<ul>
<li>
<a href="#toc_21">广播与多播</a>
<ul>
<li>
<a href="#toc_22">广播</a>
</li>
<li>
<a href="#toc_23">多播</a>
</li>
</ul>
</li>
<li>
<a href="#toc_24">BGP</a>
</li>
</ul>
</li>
<li>
<a href="#toc_25">Socket 编程</a>
</li>
</ul>


<h2 id="toc_0">HTTP 协议</h2>

<h3 id="toc_1">HTTP 的特性</h3>

<ul>
<li>HTTP 构建于 TCP/IP 协议之上</li>
<li>HTTP 是无连接状态的</li>
</ul>

<h3 id="toc_2">HTTP 报文</h3>

<h4 id="toc_3">请求报文</h4>

<p>HTTP 定义了与服务器交互的不同方法，最基本的方法有 4 种，分别是 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>. <code>URL</code> 全称是资源描述符，我们可以这样任务，一个 URL 地址，它用于描述一个网络上的资源，而 HTTP 中的 GET、POST、PUT、DELETE 就对应着对这个资源的差、改、增、删 4 个操作。</p>

<ol>
<li><p>GET 用于信息获取，而且应该是<strong>安全的</strong>和<strong>幂等的</strong></p>

<p>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用，不会影响资源的状态。</p>

<p>幂等的意味着对同一 URL 的多个请求应该返回同样的结果。</p>

<p>GET 请求报文示例：</p>

<pre><code>GET /books/?sex=man&amp;name=Professional HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
</code></pre></li>
<li><p>POST 表示可能修改服务器上的资源</p>

<pre><code>POST / HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive

sex=man&amp;name=Professional
</code></pre></li>
<li><p>注意</p>

<ul>
<li>GET 可提交的数据量受 URL 长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器对它的限制</li>
<li>理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，处于安全考虑，服务器软件在实现时会做一定限制</li>
<li>参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里</li>
</ul></li>
</ol>

<h4 id="toc_4">响应报文</h4>

<p>HTTP 响应与 HTTP 请求相似，HTTP 响应也由 3 个部分构成，分别是：</p>

<ul>
<li>状态行</li>
<li>响应头（Response Header）</li>
<li>响应正文</li>
</ul>

<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>

<p>常见的状态码有如下几种：</p>

<ul>
<li>200 OK：客户端请求成功</li>
<li>302 Moved Temporirily：请求重定向</li>
<li>304 Not Modified：文件未修改，可以直接使用缓存文件</li>
<li>400 Bad Request：由于客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthonzed：请求未经授权。这个状态码必须和 WWW-Authenticate 报头域一起使用</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li>404 Not Found：请求的资源不存在，例如输入了错误的 URL</li>
<li>500 Internal Server Error：服务器发生不可预期的错误，导致无法完成客户端的请求</li>
<li>503 Service Unavailable：服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会回复正常</li>
</ul>

<p>下面是一个 HTTP 响应的例子：</p>

<pre><code>HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Data: Mon,60ct2003 13:23:52 GMT
Content-Length:112

&lt;html&gt;...
</code></pre>

<h4 id="toc_5">条件 GET</h4>

<p>HTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。详见：RFC2616</p>

<ol>
<li><p>HTTP 条件 GET 使用的时机</p>

<p>客户端之前已经访问过某网站，并打算再次访问该网站</p></li>
<li><p>HTTP 条件 GET 使用的方法</p>

<p>客户端想服务器发送一个包询问是否在上一次访问网站的时间后更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p></li>
</ol>

<p>下面是一个具体的发送接收报文的示例：</p>

<p>客户端发送请求：</p>

<pre><code>GET / HTTP/1.1
Host: www.sina.com.cn:80
If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT
Connection: Close
</code></pre>

<p>第一次请求时，服务器端发送请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified 响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。</p>

<pre><code>HTTP/1.0 304 Not Modified
Date: Thu, 04 Feb 2010 12:38:41 GMT
Content-Type: text/html
Expires: Thu, 04 Feb 2010 12:39:41 GMT
Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT
Age: 28
X-Cache: HIT from sy32-21.sina.com.cn
Connection: close
</code></pre>

<p>如果服务器端资源已经更新的话，就返回正常的响应。</p>

<h3 id="toc_6">持久连接</h3>

<p>我们知道 HTTP 协议采用 「请求-应答」模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连击，完成之后立即断开连接（HTTP 协议为无连接协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接。</p>

<p>在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际它是被附加到 HTTP 1.0 协议上，如如过客户端浏览器支持 Keep-Alive，那么就在 HTTP 请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开，当客户端发送另外一个请求时，就是用这条已经建立的连接。</p>

<p>在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 Connection: close 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。</p>

<p>注意：</p>

<ul>
<li>HTTP Keep-Alive 简单说就是保持当前 TCP 连接，避免了重新建立连击</li>
<li>HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100, 表示这个 TCP 通道可以保持 5 秒，max=100 表示这个长连接最多接受 100 次请求就断开</li>
<li>HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。另外，Keep-Alive 也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP 1.1 也是如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于 Keep-Alive 的保持连击特性</li>
<li>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1）判断传输数据是否达到了 Content-Length 指示的大小；2）动态生成的文件没有 Content-Length，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后又一个空 chunked 块，表明本次传输数据结束。</li>
</ul>

<h3 id="toc_7">HTTP Pipelining（HTTP 管线化）</h3>

<p>默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于「请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 —&gt; 响应3」。</p>

<p>HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需要等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样：「请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3」。</p>

<p>注意下面几点：</p>

<ul>
<li>管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0 不支持）</li>
<li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制</li>
<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议</li>
<li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>
<li>HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
<li>由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持</li>
</ul>

<h3 id="toc_8">会话跟踪</h3>

<ul>
<li><p>什么是会话？</p>

<p>客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</p></li>
<li><p>什么是会话跟踪？</p>

<p>会话跟踪指的是对一个用户对服务器的连续的请求和接受响应的监视。</p></li>
<li><p>为什么需要会话跟踪？</p>

<p>浏览器与服务器之间的通信是通过 HTTP 协议进行通信的，而 HTTP 协议是「无状态」的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才会有会话跟踪技术来实现这种要求。</p>

<ol>
<li><p>会话跟踪的常用方法</p>

<ul>
<li>URL 重写。URL 是 Web 上特定页面的地址，URL 重写的技术就是在 URL 结尾添加一个附加数据以标识该会话，把会话 ID 通过 URL 的信息传递过去，以便在服务器端进行识别不同的用户</li>
</ul></li>
<li><p>隐藏表单域</p>

<ul>
<li>将会话 ID 添加到 HTML 表单元素中提交到服务器，此标案元素并不在客户端显示</li>
</ul></li>
<li><p>Cookie</p>

<ul>
<li>Cookie 是 Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端，在客户端可以进行保存，以便下次使用。</li>
<li>客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称之为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。</li>
<li>Cookie 是可以被禁止的。</li>
</ul></li>
<li><p>Session</p>

<ul>
<li>每一个用户都有一个不同的 Session，各个用户之间是不能共享的，是每个用户所独享的，在 Session 中可以存放信息</li>
<li>在服务器端会创建一个 session 对象，产生一个 session ID 来标识这个 session 对象，然后将这个 session ID 放到 Cookie 中发送到客户端，下一次访问时，session ID 会发送到服务器，在服务器端进行标识不同的用户</li>
<li>session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效</li>
</ul></li>
</ol></li>
</ul>

<h3 id="toc_9">跨站攻击</h3>

<p>CSRF（Cross-site request forgery，跨站请求伪造）</p>

<p>CSRF（XSRF）顾名思义，是伪造请求，冒充用户在站内的正常操作。</p>

<p>例如，一论坛网站的发帖是通过 GET 请求访问，点击发帖之后 JS 把发帖内容拼接成目标 URL 并访问：</p>

<pre><code>http://example.com/bbs/create_post.php?title=标题&amp;content=内容
</code></pre>

<p>那么，我们紫瑶在论坛中发一贴，包含一链接：</p>

<pre><code>http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈
</code></pre>

<p>只要有用户点击了这个连接，那么他们的账户就会在不知情的情况下发不了这一帖子。既然发帖的请求可以伪造，那么删帖、转账、改密码、发邮件全部可以伪造。</p>

<h4 id="toc_10">如何防范 CSRF 攻击？</h4>

<p>可以注意以下几点：</p>

<ul>
<li>关键操作只接受 POST 请求</li>
<li>验证码。CSRF 攻击的过程中，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效地防御了 CSRF 攻击。但是如果你在一个网站做出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时使用</li>
<li>检测 Referer

<ul>
<li>常见的互联网页面与页面之间是存在联系的</li>
<li>通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击</li>
</ul></li>
<li>Token

<ul>
<li>目前主流的做法是使用 Token 抵御 CSRF 攻击</li>
<li>CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击</li>
<li>另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的，这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击</li>
</ul></li>
</ul>

<p>Token 使用原则：</p>

<ul>
<li>Token 要足够随机（只有这样才算不可预测）</li>
<li>Token 是一次性的，即每次请求成功后要更新 Token（这样可以增加攻击难度，增加预测难度）</li>
<li>Token 要注意保密性（敏感操作使用 POST，防止操作出现在 URL）中</li>
</ul>

<h3 id="toc_11">XSS（Cross Site Scripting，跨站脚本攻击）</h3>

<p>XSS 全称「跨站脚本」，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到页面上，其他用户访问这个页面的时候就会运行这个脚本。</p>

<p>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p>

<h4 id="toc_12">如何防御 XSS 攻击？</h4>

<p>理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害却绝育攻击代码的威力，攻击代码也不限于 script。防御 XSS 攻击最简单的方法，就是过滤用户的输入。</p>

<p>如果不需要用户输入 HTML，可以直接对用户输入进行 HTML escape。</p>

<p>当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法的 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿去。</p>

<h2 id="toc_13">TCP 协议</h2>

<h3 id="toc_14">TCP 协议的特性</h3>

<ul>
<li>TCP 提供一种面向连接的、可考的字节流服务</li>
<li>在一个 TCP 连接中，仅有两方进行彼此的通信。广播和多播不能用于 TCP</li>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 使用累积确认</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>

<h3 id="toc_15">三次握手与四次握手</h3>

<p>所谓三次握手（Three-way Handshake），是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。</p>

<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connec()</code> 时，将触发三次握手。</p>

<ul>
<li>第一次握手（SYN=1, seq=x）

<ul>
<li>客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器端口，以及初始序列号 X，保存在包头的序列号（Sequence Number）字段里。</li>
<li>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态</li>
</ul></li>
<li>第二次握手（SYN=1, ACK=1, seq=y, ACKnum=x+1）

<ul>
<li>服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序列号（Acknowledgement Number） 设置为客户的 ISN 加 1，即 x+1</li>
<li>发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态</li>
</ul></li>
<li><p>第三次握手（ACK=1, ACKnum=y+1）</p>

<ul>
<li>客户端再次发送确认包（ACK），SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序列号字段 +1，放在确定字段中发送给对方，并且在数据段放写 ISN 的 +1</li>
<li>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</li>
</ul>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-08-060918.jpg" alt=""/></p></li>
</ul>

<p>TCP 的连接的拆除需要发送四个包，因此成为四次握手（Four-way handshake），也叫做改进的三次握手。客户端或服务器均可主动法切握手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生握手动作。</p>

<ul>
<li>第一次握手（FIN=1, seq=x）

<ul>
<li>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据</li>
<li>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态</li>
</ul></li>
<li>第二次握手（ACK=1, ACKnum=x+1）

<ul>
<li>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接</li>
<li>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接受到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接</li>
</ul></li>
<li>第三次握手（FIN=1, seq=y）

<ul>
<li>服务器端准备好关闭连接时，向客户端发送结束连接的请求，FIN 置为 1</li>
<li>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个 ACK</li>
</ul></li>
<li><p>第四次握手（ACK=1, ACKnum=y+1）</p>

<ul>
<li>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code> 状态，等待可能出现的要求重传的 ACK 包</li>
<li>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态</li>
<li>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime） 之后，没有收到服务器端的 ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，计入 <code>CLOSED</code> 状态</li>
</ul>

<p><img src="http://omaacpco9.bkt.clouddn.com/2017-03-08-060951.jpg" alt=""/></p></li>
</ul>

<h3 id="toc_16">SYN 攻击</h3>

<h4 id="toc_17">什么是 SYN 攻击（SYN Flood）？</h4>

<p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接成为半连接（half-open connect）。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态</p>

<p>SYN 攻击指的是，攻击客户端在段时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求会被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>

<p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>

<h4 id="toc_18">如何检测 SYN 攻击？</h4>

<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstats  命令来检测 SYN 攻击。</p>

<h4 id="toc_19">如何防御 SYN 攻击？</h4>

<p>SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 SYN 攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p>

<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN Cookie 技术</li>
</ul>

<h2 id="toc_20">IP 协议</h2>

<h3 id="toc_21">广播与多播</h3>

<p>广播和多播仅用于 UDP（TCP是面向连接的）。</p>

<h4 id="toc_22">广播</h4>

<p>一共有四种广播地址：</p>

<ol>
<li><p>受限的广播</p>

<p>受限的广播地址为 255.255.255.255。该地址用于珠玑配置过程中 IP 数据报的目的地址，在任何情况下，router 不转发目的地址为 255.255.255.255 的数据报，这样的数据报近出现在本地网络中。</p></li>
<li><p>指向网络的广播</p>

<ul>
<li>指向网络的广播地址是主机号为全 1 的地址。A 类网络广播地址为 netid.255.255.255，其中 netid 为 A 类网络的网络号。</li>
<li>一个 router 必须转发指向网络的广播，但它也必须有一个不进行转发的选择</li>
</ul></li>
<li><p>指向子网的广播</p>

<p>指向子网的广播地址为主机号为全 1 且有特定子网号的地址。作为子网直接广播地址的 IP 地址需要了解子网的掩码。例如，router 收到 128.1.2.255 的数据报，当 B 类网路 128.1 的子网掩码为 255.255.255.0 时，该地址就是指向子网的广播地址；但是如果子网掩码为 255.255.254.0，该地址就不是指向子网的广播地址。</p></li>
<li><p>指向所有子网的广播</p>

<p>指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开来。指向所有子网的广播地址的子网号和主机号为全 1. 例如，如果子网掩码为 255.255.255.0，那么 128.1.255.255 就是一个指向所有子网的广播地址。</p>

<p>当前看法是这种广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。</p></li>
</ol>

<p>广播示例：</p>

<pre><code>PING 192.168.0.255 (192.168.0.255): 56 data bytes 64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.199 ms 64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=45.357 ms 64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.203 ms 64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=269.475 ms
64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=189.881 ms
</code></pre>

<p>可以看到的确受到了来自两个主机的答复，其中 192.168.0.107 是本机地址。</p>

<h4 id="toc_23">多播</h4>

<p>多播又叫组播，使用 D 类地址，D 类地址分配的 28bit 均用作多播组号而不再表示其他。</p>

<p>多播组地址包括 1110 的最高 4 bit 和多播组号。它们通常可以表示为点分十进制数，范围从 224.0.0.0 到 239.255.255.255.</p>

<p>多播的出现减少了对应用不感兴趣主机的处理负荷。</p>

<p>多播的特点：</p>

<ul>
<li>允许一个或多个发送者（组播源）发送单一的数据包到多个接收者（一次的、同时的）的网络技术</li>
<li>可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包</li>
<li>多播技术的核心就是针对如何节约网络资源的前提下保证服务质量</li>
</ul>

<p>多播示例：</p>

<pre><code>PING 224.0.0.1 (224.0.0.1): 56 data bytes
64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.081 ms
64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=123.081 ms
64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.122 ms
64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=67.312 ms
64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.132 ms
64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=447.073 ms
64 bytes from 192.168.0.107: icmp_seq=3 ttl=64 time=0.132 ms
64 bytes from 192.168.0.106: icmp_seq=3 ttl=64 time=188.800 ms
</code></pre>

<h3 id="toc_24">BGP</h3>

<ul>
<li>边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议</li>
<li>BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不想管路由域间的多路连接的协议</li>
<li>BGP 是一种外部网关协议（Exterior Gateway Protocol, EGP），与 OSPF、RIP 等 内部网关协议（Interior Gateway Protocol, IGP） 不同，BGP 不在于发现和计算路由，而在于控制路由的传播和选择最佳路由</li>
<li>BGP 使用 TCP 作为其传输层协议（端口号 179），提高了协议的可靠性</li>
<li>BGP 支持 CIDR（Classless Inter-Domain Routing，无类别域间路由）</li>
<li>路由更新时，BGP 只发送更新的路由，大大减少了 BGP 传播路由所占用的贷款，适用于在 Internet 上传播大量的路由信息</li>
<li>BGP 路由通过携带 AS 路径信息彻底解决路由环路问题</li>
<li>BGP 提供了丰富的路由策略，能够对路由实现灵活的过滤和选择</li>
<li>BGP 易于扩展，能够实行网络新的发展</li>
</ul>

<h2 id="toc_25">Socket 编程</h2>

<p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与 TCP/IP 协议族通信的中间软件抽象层。从设计模式的角度来看，Socket 其实是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</p>

<p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip 地址、协议、端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其他进程进行交互。</p>

<p>Socket 起源于 Unix，Unix 基本哲学之一就是「一切皆文件」，都可以用「open -&gt; read/write -&gt; close」 模式来进行操作。因此，Socket 也被处理为一种特殊的文件。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="programming.html"><strong>Programming&nbsp;(24)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="python.html">Python&nbsp;(7)</a>&nbsp;&nbsp;
	        
	        	<a href="algorithms.html">Algorithms&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="swift.html">Swift&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="lisp.html">Lisp&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="network.html">Network&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15078822029815.html">全站必备：网络编程基础</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15078804008494.html">函数式编程</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15077106861971.html">Scheme 笔记</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15075498694747.html">Python Tricks</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15075210302691.html">S-表达式</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>