<!DOCTYPE html>
<html>

<head>
    <title>
         Network - Wiki 
    </title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="asset/yue.css">
    <link rel="stylesheet" type="text/css" href="asset/main.css">
    <link rel="stylesheet" type="text/css" href="asset/tomorrow.css">

    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Wiki">

    <script src="asset/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    <header class="yue site-header">
        <div class="wrapper">
            <a class="site-title" href="index.html">Wiki</a>
            <nav class="site-nav">
                <a href="#" class="menu-icon">
                    
                    <svg viewBox="0 0 18 15">
                        <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"
                        />
                        <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"
                        />
                        <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"
                        />
                    </svg>

                </a>
                <div class="trigger">
                    
                        <a class="page-link" href="index.html">INDEX</a>
                    
                        <a class="page-link" href="archives.html">ARCHIVES</a>
                    
                </div>
            </nav>
        </div>
    </header>
</body>

</html> <div class="page-content yue">
    <div class="wrapper">
        <div class="home">
            <div class="divider">
                <p></p>
            </div>
            <ul class="entry-list">
                
                <li class="entry-item" itemscope="" itemtype="http://schema.org/Article">
                    <div class="entry-meta">
                        <time class="updated" datetime="2017/3/8">2017/3/8</time>
                    </div>
                    <div class="detail">
                        <h2 itemprop="name"><a itemprop="url" href="14889309726832.html">计算机网络</a></h2>
                        <div itemprop="description">
                            
                                <h2 id="toc_0">HTTP 协议</h2>

<h3 id="toc_1">HTTP 的特性</h3>

<ul>
<li>HTTP 构建于 TCP/IP 协议之上</li>
<li>HTTP 是无连接状态的</li>
</ul>

<h3 id="toc_2">HTTP 报文</h3>

<h4 id="toc_3">请求报文</h4>

<p>HTTP 定义了与服务器交互的不同方法，最基本的方法有 4 种，分别是 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>. <code>URL</code> 全称是资源描述符，我们可以这样任务，一个 URL 地址，它用于描述一个网络上的资源，而 HTTP 中的 GET、POST、PUT、DELETE 就对应着对这个资源的差、改、增、删 4 个操作。</p>

<ol>
<li><p>GET 用于信息获取，而且应该是<strong>安全的</strong>和<strong>幂等的</strong></p>

<p>所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用，不会影响资源的状态。</p>

<p>幂等的意味着对同一 URL 的多个请求应该返回同样的结果。</p>

<p>GET 请求报文示例：</p>

<pre><code>GET /books/?sex=man&amp;name=Professional HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
</code></pre></li>
<li><p>POST 表示可能修改服务器上的资源</p>

<pre><code>POST / HTTP/1.1
Host: www.wrox.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 40
Connection: Keep-Alive

sex=man&amp;name=Professional
</code></pre></li>
<li><p>注意</p>

<ul>
<li>GET 可提交的数据量受 URL 长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器对它的限制</li>
<li>理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，处于安全考虑，服务器软件在实现时会做一定限制</li>
<li>参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里</li>
</ul></li>
</ol>

<h4 id="toc_4">响应报文</h4>

<p>HTTP 响应与 HTTP 请求相似，HTTP 响应也由 3 个部分构成，分别是：</p>

<ul>
<li>状态行</li>
<li>响应头（Response Header）</li>
<li>响应正文</li>
</ul>

<p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>

<p>常见的状态码有如下几种：</p>

<ul>
<li>200 OK：客户端请求成功</li>
<li>302 Moved Temporirily：请求重定向</li>
<li>304 Not Modified：文件未修改，可以直接使用缓存文件</li>
<li>400 Bad Request：由于客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthonzed：请求未经授权。这个状态码必须和 WWW-Authenticate 报头域一起使用</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li>404 Not Found：请求的资源不存在，例如输入了错误的 URL</li>
<li>500 Internal Server Error：服务器发生不可预期的错误，导致无法完成客户端的请求</li>
<li>503 Service Unavailable：服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会回复正常</li>
</ul>

<p>下面是一个 HTTP 响应的例子：</p>

<pre><code>HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Data: Mon,60ct2003 13:23:52 GMT
Content-Length:112

&lt;html&gt;...
</code></pre>

<h4 id="toc_5">条件 GET</h4>

<p>HTTP 条件 GET 是 HTTP 协议为了减少不必要的贷款浪费，提出的一种方案。详见：RFC2616</p>

<ol>
<li><p>HTTP 条件 GET 使用的时机</p>

<p>客户端之前已经访问过某网站，并打算再次访问该网站</p></li>
<li><p>HTTP 条件 GET 使用的方法</p>

<p>客户端想服务器发送一个包询问是否在上一次访问网站的时间后更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p></li>
</ol>

<p>下面是一个具体的发送接收报文的示例：</p>

<p>客户端发送请求：</p>

<pre><code>GET / HTTP/1.1
Host: www.sina.com.cn:80
If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT
Connection: Close
</code></pre>

<p>第一次请求时，服务器端发送请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified 响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。</p>

<pre><code>HTTP/1.0 304 Not Modified
Date: Thu, 04 Feb 2010 12:38:41 GMT
Content-Type: text/html
Expires: Thu, 04 Feb 2010 12:39:41 GMT
Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT
Age: 28
X-Cache: HIT from sy32-21.sina.com.cn
Connection: close
</code></pre>

<p>如果服务器端资源已经更新的话，就返回正常的响应。</p>

<h3 id="toc_6">持久连接</h3>

<p>我们知道 HTTP 协议采用 「请求-应答」模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连击，完成之后立即断开连接（HTTP 协议为无连接协议）；当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接。</p>

<p>在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际它是被附加到 HTTP 1.0 协议上，如如过客户端浏览器支持 Keep-Alive，那么就在 HTTP 请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开，当客户端发送另外一个请求时，就是用这条已经建立的连接。</p>

<p>在 HTTP 1.1 版本中，默认情况下所有连接都被保持，如果加入 Connection: close 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。</p>

<p>注意：</p>

<ul>
<li>HTTP Keep-Alive 简单说就是保持当前 TCP 连接，避免了重新建立连击</li>
<li>HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100, 表示这个 TCP 通道可以保持 5 秒，max=100 表示这个长连接最多接受 100 次请求就断开</li>
<li>HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。另外，Keep-Alive 也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP 1.1 也是如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于 Keep-Alive 的保持连击特性</li>
<li>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1）判断传输数据是否达到了 Content-Length 指示的大小；2）动态生成的文件没有 Content-Length，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后又一个空 chunked 块，表明本次传输数据结束。</li>
</ul>

<h3 id="toc_7">HTTP Pipelining（HTTP 管线化）</h3>

<p>默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于「请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 —&gt; 响应3」。</p>

<p>HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需要等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样：「请求1 -&gt; 请求2 -&gt; 请求3 -&gt; 响应1 -&gt; 响应2 -&gt; 响应3」。</p>

<p>注意下面几点：</p>

<ul>
<li>管线化机制通过持久连接（persistent connection）完成，仅 HTTP/1.1 支持此技术（HTTP/1.0 不支持）</li>
<li>只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制</li>
<li>初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议</li>
<li>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</li>
<li>HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</li>
<li>由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持</li>
</ul>

<h3 id="toc_8">会话跟踪</h3>

<ul>
<li><p>什么是会话？</p>

<p>客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。</p></li>
<li><p>什么是会话跟踪？</p>

<p>会话跟踪指的是对一个用户对服务器的连续的请求和接受响应的监视。</p></li>
<li><p>为什么需要会话跟踪？</p>

<p>浏览器与服务器之间的通信是通过 HTTP 协议进行通信的，而 HTTP 协议是「无状态」的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才会有会话跟踪技术来实现这种要求。</p>

<ol>
<li><p>会话跟踪的常用方法</p>

<ul>
<li>URL 重写。URL 是 Web 上特定页面的地址，URL 重写的技术就是在 URL 结尾添加一个附加数据以标识该会话，把会话 ID 通过 URL 的信息传递过去，以便在服务器端进行识别不同的用户</li>
</ul></li>
<li><p>隐藏表单域</p>

<ul>
<li>将会话 ID 添加到 HTML 表单元素中提交到服务器，此标案元素并不在客户端显示</li>
</ul></li>
<li><p>Cookie</p>

<ul>
<li>Cookie 是 Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到刻画段，在客户端可以进行保存，以便下次使用。</li>
<li>客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称之为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。</li>
<li>Cookie 是可以被禁止的。</li>
</ul></li>
<li><p>Session</p>

<ul>
<li>每一个用户都有一个不同的 Session，各个用户之间是不能共享的，是每个用户所独享的，在 Session 中可以存放信息</li>
<li>在服务器端会创建一个 session 对象，产生一个 session ID 来标识这个 session 对象，然后将这个 session ID 放到 Cookie 中发送到客户端，下一次访问时，session ID 会发送到服务器，在服务器端进行标识不同的用户</li>
<li>session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效</li>
</ul></li>
</ol></li>
</ul>

<h3 id="toc_9">跨站攻击</h3>

<p>CSRF（Cross-site request forgery，跨站请求伪造）</p>

<p>CSRF（XSRF）顾名思义，是伪造请求，冒充用户在站内的正常操作。</p>

<p>例如，一论坛网站的发帖是通过 GET 请求访问，点击发帖之后 JS 把发帖内容拼接成目标 URL 并访问：</p>

<pre><code>http://example.com/bbs/create_post.php?title=标题&amp;content=内容
</code></pre>

<p>那么，我们紫瑶在论坛中发一贴，包含一链接：</p>

<pre><code>http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈
</code></pre>

<p>只要有用户点击了这个连接，那么他们的账户就会在不知情的情况下发不了这一帖子。既然发帖的请求可以伪造，那么删帖、转账、改密码、发邮件全部可以伪造。</p>

<h4 id="toc_10">如何防范 CSRF 攻击？</h4>

<p>可以注意以下几点：</p>

<ul>
<li>关键操作只接受 POST 请求</li>
<li>验证码。CSRF 攻击的过程中，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效地防御了 CSRF 攻击。但是如果你在一个网站做出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时使用</li>
<li>检测 Referer

<ul>
<li>常见的互联网页面与页面之间是存在联系的</li>
<li>通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击</li>
</ul></li>
<li>Token

<ul>
<li>目前主流的做法是使用 Token 抵御 CSRF 攻击</li>
<li>CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击</li>
<li>另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的，这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击</li>
</ul></li>
</ul>

<p>Token 使用原则：</p>

<ul>
<li>Token 要足够随机（只有这样才算不可预测）</li>
<li>Token 是一次性的，即每次请求成功后要更新 Token（这样可以增加攻击难度，增加预测难度）</li>
<li>Token 要注意保密性（敏感操作使用 POST，防止操作出现在 URL）中</li>
</ul>

<h3 id="toc_11">XSS（Cross Site Scripting，跨站脚本攻击）</h3>

<p>XSS 全称「跨站脚本」，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到页面上，其他用户访问这个页面的时候就会运行这个脚本。</p>

<p>XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。</p>

<h4 id="toc_12">如何防御 XSS 攻击？</h4>

<p>理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害却绝育攻击代码的威力，攻击代码也不限于 script。防御 XSS 攻击最简单的方法，就是过滤用户的输入。</p>

<p>如果不需要用户输入 HTML，可以直接对用户输入进行 HTML escape。</p>

<p>当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法的 HTML 标签都可以添加 onclick </p>

                            
                        </div>
                    </div>
                </li>
                
            </ul>
            <p class="paging">
                 
            </p>
        </div>
    </div>
</div>  <footer id="footer" class="yue">
    <div class="wrapper">
        <p>© Copyright 2014 - 2017 by <a href="https://twitter.com/Tisoga">@Tisoga</a> and powered by <a href="http://zh.mweb.im/">Mweb</a></p>
    </div>
</footer>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>
