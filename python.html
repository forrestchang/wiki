
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  Python - Wiki
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="Wiki" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">Wiki</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:forresthcang.com/wiki" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="index.html">Home</a></li>
  <li><a href="archives.html">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15079725923338.html">雾里看花之 Python Asyncio</a></h1>
			<p class="meta"><time datetime="2017-10-14T17:16:32+08:00" 
			pubdate data-updated="true">2017/10/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>笔记来源：<a href="https://linux.cn/article-8051-1.html">https://linux.cn/article-8051-1.html</a></p>

<h2 id="toc_0">原语</h2>

<p>asyncio 通过协程的帮助来实现异步 IO。最初它是通过 yield 和 yield from 表达式实现的一个库，因为 Python 语言本身演进的缘故，现在它已经变成了一个更复杂的怪兽。所以，为了在同一个频道讨论下去，你需要了解如下一些术语：</p>

<ul>
<li><a href="%5B%E4%BB%80%E4%B9%88%E6%98%AF%20Event%20Loop%EF%BC%9F%5D(15079735695142.html)">事件循环</a></li>
<li>时间循环策略</li>
<li>awaitable</li>
<li>协程函数</li>
<li>老式协程函数</li>
<li>协程</li>
<li>协程封装</li>
<li>生成器</li>
<li>future</li>
<li>并发的 future</li>
<li>任务</li>
<li>句柄</li>
<li>执行器（executor）</li>
<li>传输（transport）</li>
<li>协议</li>
</ul>

<p>此外，Python 还新增了一些新的特殊方法：</p>

<ul>
<li><code>__aenter__</code> 和 <code>__aexit__</code>，用于异步块的操作</li>
<li><code>__aiter__</code> 和 <code>__anext__</code>，用于异步迭代器（异步循环和异步推导）。为了更强大些，协议已经改变过一次了。在 Python 3.5 它返回一个 awaitable（这是个协程）；在 3.6 它返回一个新的异步生成器。</li>
<li><code>__await__</code>，用于自定义的 awaitable</li>
</ul>

<h2 id="toc_1">事件循环</h2>

<p>asyncio 事件循环和你第一眼看上去的略有不同。表面看，每个线程都有一个事件循环，然而事实并非如此。我认为它们应该按照如下的方式工作：</p>

<ul>
<li>如果是主线程，当调用 <code>asyncio.get_event_loop()</code> 时创建一个事件循环</li>
<li>如果是其他线程，当调用 <code>asyncio.get_event_loop()</code> 时返回运行时错误</li>
<li>当前线程可以使用 <code>asyncio.set_event_loop()</code> 在任何事件节点绑定事件循环。该事件循环可由 <code>asyncio.new_event_loop()</code> 函数创建</li>
<li>事件循环可以在不绑定到当前线程的情况下使用</li>
<li><code>asyncio.get_event_loop()</code> 返回绑定线程的事件循环，而非当前运行的事件循环</li>
</ul>

<p>这些行为的组合是很混淆的，主要有以下几个原因。首先，你需要知道这些函数被委托到全局设置的底层事件循环策略。默认是hi将事件循环绑定到线程。或者，如果需要的话，可以在理论上将事件循环绑定到一个 greenlet 或类似的。然而，重要是要知道库代码不控制策略，因此不能推断 asyncio 将适用于线程。</p>

<p>其次，asyncio 不需要通过策略将事件循环绑定到上下文。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15075498694747.html">Python Tricks</a></h1>
			<p class="meta"><time datetime="2017-10-09T19:51:09+08:00" 
			pubdate data-updated="true">2017/10/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">1. <code>__init__.py</code> 里面可以写什么</h2>

<p>有如下层级的代码：</p>

<pre><code>graphics/
    __init__.py
    primitive/
        __init__.py
        line.py
        fill.py
        text.py
    formats/
        __init__.py
        png.py
        jpg.py
</code></pre>

<p>绝大部分时候让<code>__init__.py</code>空着就好，但是有些情况可能包含代码。例如用来自动加载子模块：</p>

<pre><code class="language-python"># graphics/formats/__init__.py
from . import jpg
from . import png
</code></pre>

<p>像这样一个文件，用户可以仅仅通过<code>import graphics.formats</code>来代替<code>import graphics.formats.jpg</code>以及<code>import graphics.formats.png</code>。</p>

<h2 id="toc_1">2. 控制模块被全部导入的内容</h2>

<p>在模块中定义变量 <code>__all__</code>（列表） 来明确地列出需要导出的内容。如果定义了 <code>__call__</code>，那么只有被列举出的东西会被导出。</p>

<h2 id="toc_2">3. 使用相对路径名导入包中子模块</h2>

<p>使用绝对路径名导入的不利之处是这将顶层包名硬编码到你的源码中，如果你想要重新组织它，你的代码将很难工作。</p>

<p>假设在你的文件系统上有 mypackage 包，组织如下：</p>

<pre><code>mypackage/
    __init__.py
    A/
        __init__.py
        spam.py
        grok.py
    B/
        __init__.py
        bar.py
</code></pre>

<p>如果模块 mypackage.A.spam 要导入同目录吓得模块 grok：</p>

<pre><code class="language-python">from . import grok
</code></pre>

<p>如果模块 mypackage.A.spam 要导入不同目录吓得模块 B.bar：</p>

<pre><code class="language-python">from ..B import bar
</code></pre>

<p>两个 import 都没有包含顶层包名，而是使用了 spam.py 的相对路径。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15073552964811.html">Scheme 解释器相关笔记</a></h1>
			<p class="meta"><time datetime="2017-10-07T13:48:16+08:00" 
			pubdate data-updated="true">2017/10/7</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Scheme 程序的语法和语义</h2>

<ul>
<li>语法（syntax）：指的是字母排列成正确表达式或声明的顺序；</li>
<li>语义（semantics）：指的是这些表达式或声明的意义。</li>
</ul>

<p>Scheme 的语法非常简单：</p>

<ul>
<li>Scheme 程序中只有表达式，表达式和声明之间并无区别；</li>
<li>数字（例如 10）和符号（例如 A）被称为原子表达式（atomic expression），它们无法被拆分成更小的表达式。</li>
<li>除此以外的一切都是列表表达式（list expression）：以 <code>(</code> 为首，以 <code>)</code> 为尾，中间包括这零个或更多表达式。列表的第一个元素决定了它的含义：

<ul>
<li>若第一个元素是关键字，例如 <code>(if ...)</code>，那么这个列表是一个特殊形式（special form）；特殊形式的意义取决于关键字；</li>
<li>若第一个元素并非关键字，例如<code>(fn ...)</code>，那这个列表则是函数调用。</li>
</ul></li>
</ul>

<h2 id="toc_1">语言解释器做些什么</h2>

<p>一个计算机语言的解释器分为两部分：</p>

<ol>
<li>分析（parse）：解释器的分析部分将程序以一串字符串形式读入，依照语法规则（syntactic rules）验证其正确性并将程序转换成一种内部表达形式。在一个简单的解释器中，内部表达形式是一个树形结构，人们一般将其称为抽象语法树（abstract syntax tree）。抽象语法树的结构和程序中层层嵌套的声明及表达式非常接近，几乎可以说是完美对应。在编译器之中万网存在多个内部表达式，一开始先转换成抽象语法树，随后再转换成可以直接被计算器执行的指令序列。</li>
<li>执行（execution）：内部表达式被按照语言的语法规则进行处理，以此来进行计算。</li>
</ol>

<pre><code>程序 --&gt; [parser] --&gt; 抽象语法树 --&gt; [eval] --&gt; 结果
</code></pre>

<h3 id="toc_2">分析：parser, tokenize, read_from_tokens</h3>

<p>依照传统，分析被分成两个部分：</p>

<ol>
<li>词法分析（lexical analysis）：在这一部分中，输入的字符串被拆分为一系列的 token；</li>
<li>语法分析（syntactic analysis）：将 token 汇编为抽象语法树。</li>
</ol>

<h2 id="toc_3">环境（Environments）</h2>

<p>eval 函数接收两个参数：一个我们想要求值的表达式 x，还有一个环境 env，x 将在这个环境中被求值。环境指的是变量名和它们值之间的映射。eval 默认会使用全局环境（global environment）进行求值，全局环境包含着一系列的标准函数（比如 sqrt, max, * 这类操作符）。这一环境可以用用户定义的变量扩展，语法为<code>(define variable value)</code>。我们可以用 Python 自带的字典来实现环境，字典中的键对为 <code>{变量: 值}</code> 的形式。</p>

<h2 id="toc_4">Scheme 的语法规则</h2>

<table>
<thead>
<tr>
<th>表达式（Expression）</th>
<th>语法（Syntax）</th>
<th>语义（Semantics）和范例</th>
</tr>
</thead>

<tbody>
<tr>
<td>变量引用（variable reference）</td>
<td>var</td>
<td>该符号被认为是变量名；它的值是变量的值。</td>
</tr>
<tr>
<td>字面常量（constant literal）</td>
<td>number</td>
<td>一个数字（number）求值得到它自身。</td>
</tr>
<tr>
<td>条件（conditional）</td>
<td>(if test conseq alt)</td>
<td>对 test 进行求值；如果结果为真，对 conseq 进行求值并返回结果；否则对 alt 进行求值并返回结果。</td>
</tr>
<tr>
<td>定义（definition）</td>
<td>(define var exp)</td>
<td>定义一个新的变量，将 var 的值定义为 exp 求值得到的结果。</td>
</tr>
<tr>
<td>过程调用（procedure call）</td>
<td>(proc arg...)</td>
<td>如果 proc 不是 if/define/quote 其中之一，那它就被认为是一个过程（procedure）。对 proc 和所有的 args 求值，然后将 proc 过程应用于所有的 args 之上。</td>
</tr>
<tr>
<td>引用（quotation）</td>
<td>(quote exp)</td>
<td>直接按字面返回 exp，不对其进行求值。范例：(quote (+ 1 2)) --&gt; (+ 1 2)</td>
</tr>
<tr>
<td>赋值（assignment）</td>
<td>(set! var exp)</td>
<td>对 exp 进行求值并将结果赋值给 var，exp 必须在之前定义过（被 define 定义过或者是包含 set! 表达式的过程中的一个参数）</td>
</tr>
<tr>
<td>过程（procedure）</td>
<td>(lambda (var...) (exp))</td>
<td>创造一个过程，参数为 var...，exp为过程的主体，范例：(lambda (r) (* pi (* r r)))</td>
</tr>
</tbody>
</table>

<p>lambda 特殊形式会创建一个过程（procedure）：</p>

<pre><code class="language-scheme">&gt;&gt;&gt; (define circle-area (lambda (r) (* pi (* r r))))
&gt;&gt;&gt; (circle-area 10)
314.159265359
</code></pre>

<p>过程调用 (circle-area 10) 使我们队过程的主体部分 (* pi (* r r)) 进行求值。求值所在的环境中 pi 与 r 的值同全局环境相同，而 r 的值为 10.事实上，解释器并不会简单地在全局环境之中将 r 的值设为 10。如果我们将 r 用于其他用途会怎么样？我们不希望对 circle-area 的调用改变 r 的值，因此我们希望讲一个局部变量 r 设为 10，这样就不会影响到其他同名的变量。因此，我们需要构建一种新的环境，允许同时创建局部和全局变量。</p>

<p>想法如下：在我们对 <code>(circle-area 10)</code> 求值时，首先提取过程主体部分 <code>(* pi (* r r))</code>，随后在仅有一个本地变量 r 的环境中求值，但该环境同时也能访问全局环境。下图演示了这种环境模型，局部环境（蓝色）嵌套在全局环境（红色）之中：</p>

<p><img src="media/15073552964811/15073755364588.jpg" alt=""/></p>

<p>当我们在一个被嵌套的环境中查找变量时，首先在本层查找，如果没有找到对应值的话就到外一层查找。</p>

<pre><code class="language-python">class Procedure(object):
    &quot;用户定义的Scheme过程。&quot;
    def __init__(self, parms, body, env):
        self.parms, self.body, self.env = parms, body, env
    def __call__(self, *args): 
        return eval(self.body, Env(self.parms, args, self.env))

class Env(dict):
    &quot;环境是以{&#39;var&#39;:val}为键对的字典，它还带着一个指向外层环境的引用。&quot;
    def __init__(self, parms=(), args=(), outer=None):
        self.update(zip(parms, args))
        self.outer = outer
    def find(self, var):
        &quot;寻找变量出现的最内层环境。&quot;
        return self if (var in self) else self.outer.find(var)

global_env = standard_env()
</code></pre>

<p>我们看到每个过程有 3 个组成部分：一个包含变量名的列表，一个主体表达式，以及一个外层环境。外层环境使得我们在局部环境中无法找到变量时有下一个地方可以寻找。</p>

<p>环境是 dict 的子类，因此它含有 dict 拥有的所有方法。除此之外还有两个额外的方法：</p>

<ol>
<li>构造器 <code>__init__</code> 接受一个变量名列表以及对应的变量值列表，构造一个新环境，内部形式为 {variable: value} 键对，并拥有一个纸箱外层环境的引用；</li>
<li>find 函数用于找到某个变量所在的正确环境，可能是内层环境也可能是更外层的环境。</li>
</ol>

<p>要想知道这部分的工作原理，我们首先来看看 eval 的定义。注意，现在我们需要调用 env.find(x) 来寻找变量处于哪一层环境之中；随后我们才能从那一层环境中提取 x（define 分支的定义没有改变，因为 define 总是向最内一层的环境添加变量）。同时我们还增加了两个判定分支：set! 分支中，我们寻找变量所处的环境并将其设为新的值；通过 lambda，我们可以传入参数列表、主体以及环境以创建一个新的过程。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15058857487655.html">《流利的 Python》笔记</a></h1>
			<p class="meta"><time datetime="2017-09-20T13:35:48+08:00" 
			pubdate data-updated="true">2017/9/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">第 17 章：使用 futures 处理并发</h2>

<blockquote>
<p>抨击线程的往往是系统程序员，他们考虑的使用场景对一般的应用程序员来说，也许一生都不会遇到……应用程序员遇到的使用场景，99% 的情况下只需知道如何派生一堆独立的线程，然后用队列收集结果。—— Michele Simionato</p>
</blockquote>

<p>本章主要讨论 Python 3.2 引入的 concurrent.futures 模块，这个库封装了前面引文中 Michele 所述的模式，特别易于使用。</p>

<p>这一章还会介绍 futures 的概念，futures 指一种对象，表示异步执行的操作。这个概念的作用很大，是 corcurrent.futures 模块和 asyncio 包的基础。</p>

<h3 id="toc_1">示例：网络下载的三种风格</h3>

<p>为了高效处理网络 I/O，需要使用并发，因为网络有很高的延迟，所以为了不浪费 CPU 周期去等待，最好在收到网络相应之前做些其他事情。</p>

<p>为了通过代码说明这一点，我写了三个示例程序：从网上下载 20 个国家的国旗图像。第一个示例程序 flag.py 是依序下载的：下载完一个图像，并将其保存在硬盘中之后，才请求下载下一个图像；另外两个脚本是并发下载的：几乎同时请求所有图像，每下载完一个文件就保存一个文件。flags_threadpool.py 脚本使用 concurrent.futures 模块，而 flags_asyncio.py 脚本是会用 asyncio 包。</p>

<h4 id="toc_2">依序下载的脚本</h4>

<pre><code class="language-python"># flags.py：依序下载的脚本；另外两个脚本会重用其中几个函数

import os
import time
import sys

import requests

POP20_CC = (&#39;CN IN US ID BR PK NG BD RU JP &#39;
            &#39;MX PH VN ET EG DE IR TR CD FR&#39;).split()

BASE_URL = &#39;http://flupy.org/data/flags&#39;

DEST_DIR = &#39;/Users/jiayuan/Downloads/&#39;


def save_flag(img, filename):
    path = os.path.join(DEST_DIR, filename)
    with open(path, &#39;wb&#39;) as fp:
        fp.write(img)
        

def get_flag(cc):
    url = &#39;{}/{cc}/{cc}.gif&#39;.format(BASE_URL, cc=cc.lower())
    resp = requests.get(url)
    return resp.content


def show(text):
    print(text, end=&#39; &#39;)
    sys.stdout.flush()
    
    
def download_many(cc_list):
    for cc in sorted(cc_list):
        image = get_flag(cc)
        show(cc)
        save_flag(image, cc.lower() + &#39;.gif&#39;)
    return len(cc_list)


def main(download_many):
    t0 = time.time()
    count = download_many(POP20_CC)
    elapsed = time.time() - t0
    msg = &#39;\n{} flags downloads in {:.2f}s&#39;
    print(msg.format(count, elapsed))
</code></pre>

<p>测试结果：</p>

<pre><code class="language-python">&gt;&gt;&gt; main(download_many)
BD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN 
20 flags downloads in 30.90s
</code></pre>

<h4 id="toc_3">使用 concurrent.futures 模块下载</h4>

<p>concurrent.futures 模块的主要特色是 ThreadPoolExecutor 和 ProcessPollExecutor 类，这两个类实现的接口能分别在不同的线程或进程中执行可调用的对象。这两个雷子啊内部维护这一个工作线程或进程池，以及要执行的任务队列。不过，这个接口抽象层级很高，像下载国旗这种简单的案例，无需关心任何实现细节。</p>

<pre><code class="language-python"># flags_threadpool.py: 使用 futures.ThreadPoolExecutor 类实现多线程下载的脚本
from concurrent import futures

MAX_WORKERS = 20


def download_one(cc):
    image = get_flag(cc)
    show(cc)
    save_flag(image, cc.lower() + &#39;.gif&#39;)
    return cc


def download_many(cc_list):
    workers = min(MAX_WORKERS, len(cc_list))
    with futures.ThreadPoolExecutor(workers) as executor:
        res = executor.map(download_one, sorted(cc_list)) # 1
        
    return len(list(res)) # 2
</code></pre>

<p>测试结果：</p>

<pre><code class="language-python">&gt;&gt;&gt; main(download_many)
IN VN BD FR DE JP CN ID BR PH EG NG ET MX IR RU US CD PK TR 
20 flags downloads in 70.05s
</code></pre>

<p>关于这个示例的一些注解：</p>

<ul>
<li>1）map 方法的作用与内置的 map 函数类似，不过 download_one 函数会在多个线程中并发调用；map 方法返回一个生成器，因此可以迭代，获取各个函数返回的值。</li>
<li>2）返回获取的结果数量；如果有线程抛出异常，异常会在这里抛出，这与隐式调用 next() 函数从迭代器中获取相应的返回值一样</li>
</ul>

<h4 id="toc_4">futures 在哪里</h4>

<p>futures 是 concurrent.futures 模块和 asyncio 包的重要组件，作为这两个库的用户，我们有时却见不到 Future。</p>

<p>从 Python 3.4 起，标准库中有两个名为 futures 的类：concurrent.futures.Future 和 asyncio.Future。这两个类的作用相同：<strong>两个 futures 类的实例都表示可能已经完成或者尚未完成的延迟计算</strong>。这与 Twisted 引擎中的 Deferred 类、Tornado 框架中的 Future 类，以及多个 JavaScript 库中的 Promise 对象类似。</p>

<p><strong>futures 封装待完成的操作，可以放入队列，完成的状态可以查询，得到结果（或抛出异常），后可以获取结果（或异常）</strong>。</p>

<p>我们要记住一件事：通常情况下自己不应该创建 futures，而只能由并发框架（concurrent.futures 或 asyncio）实例化。原因很简单：futures 表示终将发生的事情，而<strong>确定某件事会发生的唯一方式是执行的时间已经排定</strong>。因此，只有排定把某事件交给 concurrent.futures.Executor 子类处理时，才会创建 concurrent.futures.Future 实例。例如，Executor.submit() 方法的参数时一个可调用的对象，调用这个方法后会为传入的可调用对象排期，并返回一个 future。</p>

<p>客户端代码不应该改变 futures 的状态，并发框架在 future 表示的延迟计算结束后会改变 futures 的状态，而我们无法控制计算何时结束。</p>

<p>这两种 future 都有 .done() 方法，这个方法不阻塞，返回值是布尔值，指明 future 链接的可调用对象是否已经执行。客户端代码通常不会询问 future 是否运行结束，而是会等待通知。因此，两个 future 类都有 .add_done_callback() 方法：这个方法只有一个参数，类型是可调用的对象，futures 运行结束后会调用指定的可调用对象。</p>

<p>此外，还有 .result() 方法。在 Future 运行结束后调用的话，这个方法在两个 Future 类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。</p>

<p>但是，如果 Future 没有运行结束，result 方法在两个 Future 类中的行为相差很大。对于 concurrenct.futures.Future 实例来说，调用 f.result() 方法会阻塞调用方所在的线程，直到有结果可返回。此时，result 方法可以接收可选的 timeout 参数，如果在指定的时间内 Future 没有运行完毕，会抛出 TimeoutError 异常。asyncio.Future.result 方法不支持设定超时时间，在那个库中获取 Future 的结果最好使用 yield from 结构。不过，对 concurrent.futures.Future 实例不能这么做。</p>

<p>这两个库中有几个函数会返回 Future，其他函数则使用 Future，以用户易于理解的方式实现自身。使用 Executor.map 方法属于后者：返回值是一个迭代器，迭代器的 <code>__next__</code> 方法调用各个 Future 的 result 方法，因此我们得到的是各个 Future 的结果，而非 Future 本身。</p>

<p>为了从使用的角度理解 Future，我们可以使用 concurrent.futures.as_completed 函数重写上节的示例，这个函数的参数是一个 Future 列表，返回值是一个迭代器，在 Future 运行结束后产出 Future。</p>

<p>为了使用 futures.as_completed 函数，只需修改 download_many 函数，把较抽象的 executor.map 调用换成两个 for 循环：一个用于创建并排定 Future，另一个用于获取 Future 的结果。同时，我们会添加几个 print 调用，显式运行结束前后的 Future。</p>

<pre><code class="language-python"># flags_threadpool_ac.py: 把 download_many 函数中的 executor.map 方法换成 executor.submit 方法和 futures.as_completed 函数

def download_many(cc_list):
    cc_list = cc_list[:5]
    with futures.ThreadPoolExecutor(max_workers=3) as executor:
        to_do = []
        for cc in sorted(cc_list):
            future = executor.submit(download_one, cc)
            to_do.append(future)
            msg = &#39;Scheduled for {}: {}&#39;
            print(msg.format(cc, future))
            
        results = []
        for future in futures.as_completed(to_do):
            res = future.result()
            msg = &#39;{} result: {!r}&#39;
            print(msg.format(future, res))
            results.append(res)
    return len(results)
</code></pre>

<p>测试结果：</p>

<pre><code class="language-python">&gt;&gt;&gt; main(download_many)
Scheduled for BR: &lt;Future at 0x109a12be0 state=running&gt;
Scheduled for CN: &lt;Future at 0x109a12da0 state=running&gt;
Scheduled for ID: &lt;Future at 0x109a620f0 state=running&gt;
Scheduled for IN: &lt;Future at 0x1099b9710 state=pending&gt;
Scheduled for US: &lt;Future at 0x106ac29e8 state=pending&gt;
IDCN BR  &lt;Future at 0x109a12da0 state=finished returned str&gt; result: &#39;CN&#39;
&lt;Future at 0x109a620f0 state=finished returned str&gt; result: &#39;ID&#39;
&lt;Future at 0x109a12be0 state=finished returned str&gt; result: &#39;BR&#39;
IN &lt;Future at 0x1099b9710 state=finished returned str&gt; result: &#39;IN&#39;
US &lt;Future at 0x106ac29e8 state=finished returned str&gt; result: &#39;US&#39;

5 flags downloads in 3.81s
</code></pre>

<p>注意，在这个示例中调用 future.result() 方法绝不会堵塞，因为 future 由 as_completed 函数产出。</p>

<p>严格来说，我们目前测试的并发脚本都不能并行下载，使用 concurrent.futures 库实现的两个示例收到 GIL 的限制。</p>

<p>有个问题：既然 Python 线程受 GIL 的限制，任何时候都只允许运行一个线程，那个为什么 flags_threadpool.py 脚本的下载速度会比 flags.py 脚本快 5 倍？</p>

<h3 id="toc_5">阻塞型 I/O 和 GIL</h3>

<p>CPython 解释器本身就不是线程安全的，因此有全局解释器锁，一次只允许使用一个线程执行 Python 字节码。因此，一个 Python 进程通常不能同时使用多个 CPU 核心（语言无关，解释器相关）。</p>

<p>编写 Python 代码时无法控制 GIL，不过，执行耗时的任务时，可以使用一个内置的函数或一个使用 C 语言编写的扩展释放 GIL。</p>

<p>然而，标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放 GIL。这意味着在 Python 语言这个层次上可以使用多线程，而 IO 密集型 Python 程序能从中受益：一个 Python 线程等待网络响应时，阻塞型 IO 函数会释放 GIL，再运行一个线程。</p>

<p>Python 标准库中所有阻塞型 IO 函数都会释放 GIL，允许其他线程运行。因此，尽管有 GIL，Python 线程还是能在 IO 密集型应用中发挥作用。</p>

<p>下面加单说明如何在 CPU 密集型作业中使用 concurrent.futures 模块轻松绕开 GIL。</p>

<h3 id="toc_6">使用 concurrent.futures 模块启动进程</h3>

<p>concurrent.futures 模块实现的是真正的并行计算，因为它使用 ProcessPoolExecutor 类把工作分配给多个 Python 进程处理，因此，如果需要做 CPU 密集型处理，使用这个模块能绕开 GIL，利用所有可用的 CPU 核心。</p>

<p>ProcessPoolExecutor 和 ThreadPoolExecutor 类都实现了通用的 Executor 接口，因此使用 concurrent.futures 模块能轻松地把基于线程的方案转换成基于进程的方案。</p>

<p>下载国旗的示例或其他 IO 密集型作业使用 ProcessPoolExecutor 类得不到任何好处，因为对于 CPU 密集型的处理来说，不吭呢要求使用超过 CPU 数量的进程，而对于 IO 密集型来说，可以在一个 ThreadPoolExecutor 实例中使用 10 个、100 个或 1000 个线程，最佳线程数取决于做的是什么事，以及可用内存是多少，因此要自习测试才能找到最佳的线程数。</p>

<p>ProcessPoolExecutor 的价值体现在 CPU 密集型作业上。有两个 CPU 密集型的脚本：</p>

<ul>
<li>arcfour_futures.py: 这个脚本纯粹使用 Python 实现 RC4 算法；</li>
<li>sha_futures.py: 这个脚本使用标准库中的 haslib 模块（使用 OpenSSL 库实现）实现 SHA-256 算法。</li>
</ul>

<p>这两个脚本除了显示汇总结果外，没有使用 IO，测试的结果如下：</p>

<p><img src="media/15058857487655/15063175994496.jpg" alt=""/></p>

<p>可以看出，对加密算法来说，使用 ProcessPoolExecutor 类派生 4 个工作进程后（如果有 4 个 CPU 核心的话），性能可能提高两倍。</p>

<p>如果使用 Python 处理 CPU 密集型工作，应该试试 PyPy，使用 PyPy 运行上面脚本，速度快乐 3.8~5.1 倍。</p>

<h3 id="toc_7">实现 Executor.map 方法</h3>

<p>下面通过一个演示程序来研究线程池的行为，这个程序会创建一个包含 3 个 worker 的线程池，运行 5 个可调用对象，输出带有时间戳的消息。</p>

<p>若想并发运行多个可调用对象，最简单的方式是使用 Executor.map 方法。Executor.map 函数易于使用，不过有个特性可能有用，也可能没用，具体情况取决于需求：这个函数返回结果的顺序与调用开始的顺序一致。如果第一个调用生成结果用时 10 秒，而其他调用只用 1 秒，代码会阻塞 10 秒，获取 map 方法返回的生成器产出的第一个结果。在此之后，获取后续结果时不会阻塞，因为后续的调用已经结束。如果必须等到获取所有结果后再处理，这种行为没有问题；不过，通常更可取的做法是，不管提交的顺序，只要有结果就获取。为此，要把 Executor.submit 方法和 futures.as_completed 函数结合起来使用。</p>

<p>executor.submit 和 futures.as_completed 这个组合比 executor.map 更灵活，因为 submit 方法能处理不同的可调用对象和参数，而 executor.map 只能处理参数不同的同一个可调用对象。此外，传给 futures.as_completed 函数的 futres 集合可以来自多个 Executor 实例，例如一些由 ThreadPoolExecutor 实例创建，另一些由 ProcessPoolExecutor 实例创建。</p>

<h3 id="toc_8">显示下载进度并处理错误</h3>

<p>之前的示例脚本中没有处理错误，这么做是为了便于阅读和比较三种方案（依序、多线程和异步）的结构。</p>

<p>这三个示例在负责下载一个文件的函数（download_one）中使用相同的策略处理 HTTP 404 错误，其他异常则向上冒泡，交给 download_many 函数处理。</p>

<pre><code class="language-python"># flags2_sequential.py: 负责下载的基本函数；flags2_threadpool.py 脚本重用了这两个函数

def get_flag(base_url, cc):
    url = &#39;{}/{cc}.gif&#39;.format(base_url, cc=cc.lower())
    resp = requests.get(url)
    if resp.status_code != 200:
        resp.raise_for_status()
    return resp.content


def download_one(cc, base_url, verbose=False):
    try:
        image = get_flag(base_url, cc)
    except requests.exceptions.HTTPError as exc:
        res = exc.response
        if res.status_code == 404:
            status = HTTPSatus.not_fount
            msg = &#39;not found&#39;
        else:
            raise
    else:
        save_flag(image, cc.lower() + &#39;.gif&#39;)
        status = HTTPStatus.ok
        msg = &#39;OK&#39;
        
    if verbose:
        print(cc, msg)
        
    return Result(status, cc)
</code></pre>

<p>Python 线程特别适合 IO 密集型应用，concurrent.futures 模块大大简化了某些使用场景下 Python 线程的用法。下面讨论不适合使用 ThreadPoolExecutor 或 ProcessPoolExecutor 类时，有哪些替代方案。</p>

<h3 id="toc_9">杂谈</h3>

<p>concurrent.futures 包把线程、进程和队列视作服务的基础设施，不用自己动手直接处理。当然，这个包针对的是简单的作业，也就是所谓的「高度并行」问题，编写应用（而非操作系统或数据库服务器）时，遇到的大部分并发问题都属于这一种。</p>

<p>GIL 简化了了 CPython 解释器和 C 语言扩展的实现，得益于 GIL，Python 有很多 C 语言扩展。GIL 并不会导致 Python 线程没有用武之地，因为标准库中每一个阻塞型 IO 函数都会释放 GIL，Python 线程特别适合在 IO 密集型系统中使用。</p>

<h2 id="toc_10">第 18 章：使用 asyncio 包处理并发</h2>

<blockquote>
<p>并发是指一次处理多件事；<br/>
并行是指一次做多件事；<br/>
二者不同，但是有联系；<br/>
一个关于结构，一个关于执行；<br/>
并发用于制定方案，用来解决可能并行的问题。<br/>
—— Rob Pike（Go 语言的创造者之一）</p>
</blockquote>

<p>真正的并行需要多个核心。现代的笔记本电脑有 4 个 CPU 核心，但是通常不经意间就有超过 100 个进程同时运行。因此，实际上大多数过程都是并发处理的，而不是并行处理。</p>

<p>本章介绍 asyncio 包，这个包使用事件循环驱动的协程实现并发。asyncio 大量使用 yield from 表达式，因此与 Python 旧版不兼容。</p>

<p>本章讨论以下话题：</p>

<ul>
<li>对比一个简单的多线程程序和对应的 asyncio 版，说明多线程和异步任务之间的关系</li>
<li>asyncio.Futures 类与 concurrent.futures.Future 类之间的区别</li>
<li>第 17 章中下载国旗的那些示例的异步版</li>
<li>摒弃线程或进程，如何使用异步编程管理网络应用中的高并发</li>
<li>在异步编程中，与回调相比，协程显著提升性能的方式</li>
<li>如何把阻塞的操作交给线程池处理，从而避免阻塞事件循环</li>
<li>使用 asyncio 编写服务器，重新审视 Web 应用对高并发的处理方式</li>
<li>为什么 asyncio 已经准备好了对 Python 生态系统产生重大影响</li>
</ul>

<h3 id="toc_11">线程与协程对比</h3>

<p>有一次讨论线程和 GIL 时，Michele Simionato 发布了一个简单但有趣的示例：在长时间计算的过程中，使用 multiprocessing 包在控制台中显示一个由 ASCII 字符「\/-\」构成的动画旋转指针。</p>

<p>我们改写了 Simionato 的示例，一个借由 threading 模块使用线程实现，一个借由 asyncio 包使用协程实现。我们这么做是为了让你对比两种实现，理解如何不使用线程来实现并发行为。</p>

<pre><code class="language-python"># spinner_thread.py: 通过线程以动画形式显示文本格式旋转指针
import threading
import itertools
import time
import sys


class Signal:
    go = True


def spin(msg, signal):
    write, flush = sys.stdout.write, sys.stdout.flush
    for char in itertools.cycle(&#39;|/-\\&#39;):
        status = char + &#39; &#39; + msg
        write(status)
        flush()
        write(&#39;\x08&#39; * len(status))  # 这是显示文本动画的诀窍所在：使用退格符（\x08）把光标移回来
        time.sleep(.1)
        if not signal.go:
            break
    write(&#39; &#39; * len(status) + &#39;\x08&#39; * len(status))  # 使用空格键清除状态信息，把光标移回开头


def slow_function():
    # 假装等待 I/O 一段时间
    time.sleep(3)  # 调用 sleep 函数会阻塞主线程，不过一定哟啊这么做，以便释放 GIL，创建从属线程
    return 42


def supervisor():
    signal = Signal()
    spinner = threading.Thread(
        target=spin,
        args=(&#39;thinking&#39;, signal)
    )
    print(&#39;spinner object: &#39;, spinner)
    spinner.start()
    result = slow_function()
    signal.go = False
    spinner.join()
    return result


def main():
    result = supervisor()
    print(&#39;Answer: &#39;, result)


if __name__ == &#39;__main__&#39;:
    main()

</code></pre>

<p>注意，Python 没有提供终止线程的 API，这是有意为之的。若想关闭线程，必须给线程发送消息。这里我们使用的是 signal.go 属性：在主线程中把它设置为 False 后，spinner 线程最终会注意到，然后干净地退出。</p>

<p>下面来看如何使用 @asyncio.coroutine 装饰器替代线程，实现相同的行为。asyncio 包使用的「协程」是较严格的定义。适合 asyncio API 的协程在定义体中必须使用 yield from，而不能使用 yield。此外，适合 asyncio 的协程要由调用方驱动，并由调用方通过 yield from 调用；或者把协程传给 asyncio 包中的某个函数，例如 asyncio.async(...) 和本章要介绍的其他函数，从而驱动协程。最后，@asyncio.coroutine 装饰器应该用在协程上，如下述示例所示。</p>

<pre><code class="language-python"># spinner_asyncio.py: 通过协程以动画形式显示文本式旋转指针
import asyncio
import itertools
import sys


@asyncio.coroutine
def spin(msg):
    write, flush = sys.stdout.write, sys.stdout.flush
    for char in itertools.cycle(&#39;|/-\\&#39;):
        status = char + &#39; &#39; + msg
        write(status)
        flush()
        write(&#39;\x08&#39; * len(status))
        try:
            yield from asyncio.sleep(.1)
        except asyncio.CancelledError:
            break
    write(&#39; &#39; * len(status) + &#39;\x08&#39; * len(status))


@asyncio.coroutine
def slow_function():
    # 假装等待 I/O 一段时间
    yield from asyncio.sleep(3)
    return 42


@asyncio.coroutine
def supervisor():
    spinner = asyncio.async(spin(&#39;thinking!&#39;))
    print(&#39;spinner object: &#39;, spinner)
    result = yield from slow_function()
    spinner.cancel()
    return result


def main():
    loop = asyncio.get_event_loop()
    result = loop.run_until_complete(supervisor())
    loop.close()
    print(&#39;Answer: &#39;, result)


if __name__ == &#39;__main__&#39;:
    main()

</code></pre>

<p>若非想阻塞主线程，从而冻结事件循环或整个应用，否则不要在 asyncio 协程中使用 time.sleep(...)。如果协程需要在一段时间内什么也不做，应该使用 yield from asyncio.sleep(DELAY)。</p>

<p>使用 @asyncio.coroutine 装饰器不是强制要求，但是强烈建议这么做，因为这样能在一众普通的函数中把协程凸显出来，也有助于调试：如果还没从中产出值，协程就被垃圾回收了（意味着有操作未完成，因此有可能是个缺陷），那就可以发出警告。<strong>这个装饰器不会预激协程。</strong></p>

<p>上面两个例子中的 supervisor 实现之间的主要区别概述如下：</p>

<ul>
<li>asyncio.Task 对象差不多与 threading.Thread 对象等效，「Task 对象像是实现协作式多任务库（如 gevent）中的绿色线程（green thread）」。</li>
<li>Task 对象用于驱动协程，Thread 对象用于调用可调用的对象。</li>
<li>Task 对象不由自己手动实例化，而是通过把协程传给 asyncio.async(...) 函数或 loop.create_task(...) 方法获取。</li>
<li>获取的 Task 对象已经排定了运行时间；Thread 实例则必须调用 start 方法，明确告知让它运行。</li>
<li>在线程版 supervisor 函数中，slow_function 函数是普通的函数，直接由线程调用。在异步版 supervisor 函数中，slow_function 函数时协程，由 yield from 驱动。</li>
<li>没有 API 能从外部终止线程，因为线程随时可能被终端，导致系统处于无效状态。如果想终止任务，可以使用 Task.cancel() 实例方法，在协程内部抛出 CancelledError 异常。协程可以在暂停的 yield 处捕获这个异常，处理终止请求。</li>
<li>supervisor 协程必须在 main 函数中由 loop.run_until_complete 方法执行。</li>
</ul>

<p>使用线程编程，因为调度程序任何时候都能终端线程，所以必须记住保留锁，去保护程序中的重要部分，防止多步操作在执行的过程中终端，防止数据处于无效状态。而协程默认会做好全方位保护，以防止中断。我们必须显式产出才能让程序的余下部分运行。对协程来说，无需保留锁，在多个线程之间同步操作，协程自身就会同步，因为在任意时刻只有一个协程运行。想交出控制权时，可以使用 yield 或 yield from 把控制权交还给调度程序。这就是能够安全地取消协程的原因：按照定义，协程只能在暂停的 yield 处取消，因此可以处理 CancelledError 异常，执行清理操作。</p>

<h4 id="toc_12">asyncio.Future：故意不阻塞</h4>

<p>asyncio.Future 类与 concurrent.futures.Future 类的接口基本一致，不过实现方式不同，不可以互换。</p>

<p>期物只是调度执行某物的结果，在 asyncio 包中， BaseEventLoop.create_task() 方法接收一个协程，排定它的运行时间，然后返回一个 asyncio.Task 实例——也是 asyncio.Future 类的实例，因为 Task 是 Future 的子类，用于包装协程。这与调用 Executor.submit() 方法创建 concurrent.futures.Future 实例是一个道理。</p>

<p>使用 yield from 处理期物，等待期物运行完毕这一步无需我们关心，而且不会阻塞事件循环，因为在 asyncio 包中，yield from 的作用是把控制权交还给事件循环。</p>

<p>注意，使用 yield from 处理期物与使用 add_done_callback 方法处理协程的作用一样：延迟的操作结束后，事件循环不会触发回调对象，而是设置期物的返回值；而 yield from 表达式则在暂停的协程中产生返回值，回复执行协程。</p>

<p>总之，因为 asyncio.Future 类的目的是与 yield from 一起使用，所以通常不需要使用以下方法：</p>

<ul>
<li>无需调用 my_future.add_done_callback()，因为可以直接把像在期物运行结束后执行的操作放在协程中 yield from my_future 表达式的后面。这是协程的一大优势：协程时可以暂停和恢复的函数。</li>
<li>无需调用 my_future.result()，因为 yield from 从期物中产出的值就是结果（例如 result = yield from my_future）。</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14892052747708.html">Python 面试笔记</a></h1>
			<p class="meta"><time datetime="2017-03-11T12:07:54+08:00" 
			pubdate data-updated="true">2017/3/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">Python 语言特性</a>
<ul>
<li>
<a href="#toc_1">Python 的函数参数传递</a>
</li>
<li>
<a href="#toc_2">Python 中的元类</a>
</li>
<li>
<a href="#toc_3">@staticmethod 和 @classmethod</a>
</li>
<li>
<a href="#toc_4">类变量和实例变量</a>
</li>
<li>
<a href="#toc_5">Python 自省</a>
</li>
<li>
<a href="#toc_6">字典推导式</a>
</li>
<li>
<a href="#toc_7">Python 中单下划线与双下划线的区别</a>
</li>
<li>
<a href="#toc_8">迭代器和生成器</a>
</li>
<li>
<a href="#toc_9"><code>*args</code> 和 <code>**kwargs</code></a>
</li>
<li>
<a href="#toc_10">面向切面编程 AOP 和装饰器</a>
</li>
<li>
<a href="#toc_11">鸭子类型</a>
</li>
<li>
<a href="#toc_12">Python 中的重载</a>
</li>
<li>
<a href="#toc_13">新式类和旧式类</a>
</li>
<li>
<a href="#toc_14"><code>__new__</code> 和 <code>__init__</code></a>
</li>
<li>
<a href="#toc_15">单例模式</a>
<ul>
<li>
<a href="#toc_16">什么是单例模式</a>
</li>
<li>
<a href="#toc_17">1. 使用 <code>__new__</code> 方法</a>
</li>
<li>
<a href="#toc_18">2. 共享属性</a>
</li>
<li>
<a href="#toc_19">3. 装饰器版本</a>
</li>
<li>
<a href="#toc_20">4. import 方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">Python 中的作用域</a>
</li>
<li>
<a href="#toc_22">GIL 线程全局锁</a>
</li>
<li>
<a href="#toc_23">协程</a>
</li>
<li>
<a href="#toc_24">闭包</a>
</li>
<li>
<a href="#toc_25">lambda 函数</a>
</li>
<li>
<a href="#toc_26">Python 函数式编程</a>
</li>
<li>
<a href="#toc_27">Python 里的拷贝</a>
</li>
<li>
<a href="#toc_28">Python 垃圾回收机制</a>
<ul>
<li>
<a href="#toc_29">1. 引用计数</a>
</li>
<li>
<a href="#toc_30">2. 「标记-清除」机制</a>
</li>
<li>
<a href="#toc_31">3. 分代技术</a>
</li>
</ul>
</li>
<li>
<a href="#toc_32">Python 中 list 的实现</a>
</li>
<li>
<a href="#toc_33">Python 的 is</a>
</li>
<li>
<a href="#toc_34">read/readline/readlines</a>
</li>
<li>
<a href="#toc_35">Python 2 和 3 的区别</a>
</li>
</ul>
</li>
<li>
<a href="#toc_36">操作系统</a>
<ul>
<li>
<a href="#toc_37">select、poll 和 epoll</a>
</li>
<li>
<a href="#toc_38">调度算法</a>
</li>
<li>
<a href="#toc_39">死锁</a>
</li>
<li>
<a href="#toc_40">程序的编译和链接</a>
</li>
<li>
<a href="#toc_41">静态链接和动态链接</a>
</li>
<li>
<a href="#toc_42">虚拟内存技术</a>
</li>
<li>
<a href="#toc_43">分页和分段</a>
</li>
<li>
<a href="#toc_44">页面置换算法</a>
</li>
<li>
<a href="#toc_45">边缘触发和水平触发</a>
</li>
</ul>
</li>
<li>
<a href="#toc_46">数据库</a>
<ul>
<li>
<a href="#toc_47">事务</a>
</li>
<li>
<a href="#toc_48">数据库索引</a>
</li>
<li>
<a href="#toc_49">Redis 原理</a>
</li>
<li>
<a href="#toc_50">乐观锁和悲观锁</a>
</li>
</ul>
</li>
<li>
<a href="#toc_51">网络</a>
<ul>
<li>
<a href="#toc_52">ARP 协议</a>
</li>
<li>
<a href="#toc_53">POST 和 GET</a>
</li>
<li>
<a href="#toc_54">Cookie 和 Session</a>
</li>
<li>
<a href="#toc_55">Apache 和 Nginx 的区别</a>
</li>
<li>
<a href="#toc_56">网站用户密码保存</a>
</li>
<li>
<a href="#toc_57">HTTP 和 HTTPS</a>
</li>
<li>
<a href="#toc_58">XSRF 和 XSS</a>
</li>
<li>
<a href="#toc_59">CGI 和 WSGI</a>
</li>
<li>
<a href="#toc_60">中间人攻击</a>
</li>
<li>
<a href="#toc_61">CK10 问题</a>
</li>
<li>
<a href="#toc_62">Ajax</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">Python 语言特性</h2>

<h3 id="toc_1">Python 的函数参数传递</h3>

<p>所有的变量都可以理解为内存中一个对象的引用。</p>

<p>类型是属于对象的，而不是变量。而对象有两种，「可更改」（mutable） 与「不可更改」（inmutable） 对象。==在 Python 中，strings, tuples, numbers 是不可更改的对象，list, dict 则是可以更改的对象。</p>

<p>当一个引用传递给函数的时候，函数自动复制一份引用，这个函数里的引用就和外部的引用没有关系了。而在函数内的引用指向的是可变对象的时候，对它的操作就和定位了指针地址一样，可以直接在内存里进行修改。</p>

<p>参考阅读：<a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>

<h3 id="toc_2">Python 中的元类</h3>

<p>ORM 中会用到。</p>

<p>详细的解释：<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>

<h3 id="toc_3">@staticmethod 和 @classmethod</h3>

<p>Python 有三个方法：即静态方法（staticmethod）、类方法（classmethod）和实例方法。</p>

<pre><code class="language-python">def foo(x):
    print &quot;executing foo(%s)&quot;%(x)

class A(object):
    def foo(self,x):
        print &quot;executing foo(%s,%s)&quot;%(self,x)

    @classmethod
    def class_foo(cls,x):
        print &quot;executing class_foo(%s,%s)&quot;%(cls,x)

    @staticmethod
    def static_foo(x):
        print &quot;executing static_foo(%s)&quot;%x

a=A()
</code></pre>

<p><code>self</code> 和 <code>cls</code> 是对类或者实例的绑定。对于一般的函数我们可以这么调用 <code>foo(x)</code>，这个函数就是最常用的，它的工作和任何东西（类、实例）无关。对于实例方法，我们知道在类中每次定义方法都需要绑定这个实例，即 <code>foo(self, x)</code> ，因为实例方法的调用离不开实例，我们需要把实例自己传给函数，调用的时候是这样的 <code>a.foo(x)</code>（其实是 <code>foo(a, x)</code>）。类方法一样，只不过它传递的是类而不是实例，<code>A.class_foo(x)</code>。注意这里的 self 和 cls 可以替换成别的参数，但是 Python 的约定就是这两个，所以还是不要改比较好。</p>

<p>对于静态方法其实和普通方法一样，不需要对谁进行绑定，唯一的区别就是需要使用 <code>a.static_foo(x)</code> 或者 <code>A.static_foo(x)</code> 这样的方式来调用。</p>

<table>
<thead>
<tr>
<th></th>
<th>实例方法</th>
<th>类方法</th>
<th>静态方法</th>
</tr>
</thead>

<tbody>
<tr>
<td>a = A()</td>
<td>a.foo(x)</td>
<td>a.class_foo(x)</td>
<td>a.static_foo(x)</td>
</tr>
<tr>
<td>A</td>
<td>不可用</td>
<td>A.class_foo(x)</td>
<td>A.static_foo(x)</td>
</tr>
</tbody>
</table>

<p>详细讨论：<a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></p>

<h3 id="toc_4">类变量和实例变量</h3>

<pre><code class="language-python">class Person:
    name=&quot;aaa&quot;

p1=Person()
p2=Person()
p1.name=&quot;bbb&quot;
print p1.name  # bbb
print p2.name  # aaa
print Person.name  # aaa
</code></pre>

<p>类变量就是供类使用的变量，实例变量就是供实例使用的。</p>

<p>这里的 <code>p1.name=&quot;bbb&quot;</code> 是实例调用了类变量，这和上面的一个问题一样，就是函数传参的问题，<code>p1.name</code> 一开始指向的是类变量 <code>Person.name</code>，但在实例的作用域里把类变量的引用改变了，就变成了一个实例变量。</p>

<p>可以对比一下下面这个例子：</p>

<pre><code class="language-python">class Person:
    name=[]

p1=Person()
p2=Person()
p1.name.append(1)
print p1.name  # [1]
print p2.name  # [1]
print Person.name  # [1]
</code></pre>

<p>参考：<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>

<h3 id="toc_5">Python 自省</h3>

<p>自省就是面向对象的语言所写的程序在运行时，所能知道对象的类型。简单讲就是运行时能够获得对象的类型，比如 <code>type()</code>, <code>dir()</code>, <code>getattr()</code>, <code>hasattr()</code>, <code>isinstance()</code>。</p>

<h3 id="toc_6">字典推导式</h3>

<p>2.7 中加入的内容。</p>

<pre><code class="language-python">d = {key: value for (key, value) in iterable}
</code></pre>

<h3 id="toc_7">Python 中单下划线与双下划线的区别</h3>

<pre><code class="language-python">&gt;&gt;&gt; class MyClass():
...     def __init__(self):
...             self.__superprivate = &quot;Hello&quot;
...             self._semiprivate = &quot;, world!&quot;
...
&gt;&gt;&gt; mc = MyClass()
&gt;&gt;&gt; print mc.__superprivate
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: myClass instance has no attribute &#39;__superprivate&#39;
&gt;&gt;&gt; print mc._semiprivate
, world!
&gt;&gt;&gt; print mc.__dict__
{&#39;_MyClass__superprivate&#39;: &#39;Hello&#39;, &#39;_semiprivate&#39;: &#39;, world!&#39;}
</code></pre>

<ul>
<li><code>__foo__</code>：一种约定，Python 内部的名字，用来区别其他用户自定义的命名，以防冲突</li>
<li><code>_foo</code>：一种约定，用来指定变量是私有变量</li>
<li><code>__foo</code>：解析器用 <code>_classname__foo</code> 来代替这个名字，以区别和其他类相同的命名。</li>
</ul>

<p>参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></li>
<li><a href="http://www.zhihu.com/question/19754941">http://www.zhihu.com/question/19754941</a></li>
</ul>

<h3 id="toc_8">迭代器和生成器</h3>

<p>详细解释：<a href="https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html">https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p>

<h3 id="toc_9"><code>*args</code> 和 <code>**kwargs</code></h3>

<p>使用 <code>*args</code> 和 <code>**kwargs</code> 只是为了方便，并没有强制使用它们。</p>

<p>当你不确定函数中将要传入多少个参数时可以使用 <code>*args</code> ，它可以传递任意数量的参数。</p>

<p><code>**kwargs</code> 允许你使用事先未定义的参数名。</p>

<p>你也可混着使用，命名参数首先获得参数值，然后其他所有的参数都传给 <code>*args</code> 和 <code>**kwargs</code>。命名参数在列表的最前端：</p>

<pre><code class="language-python">def table_things(titlestring, **kwargs)
</code></pre>

<p><code>*args</code> 和 <code>**kwargs</code> 可以同时在函数的定义中，但是 <code>*args</code> 必须在 <code>**kwargs</code> 前面。</p>

<p>在调用函数时也可以使用 <code>*</code> 和 <code>**</code> 语法，例如：</p>

<pre><code class="language-python">&gt;&gt;&gt; def print_three_things(a, b, c):
...     print &#39;a = {0}, b = {1}, c = {2}&#39;.format(a,b,c)
...
&gt;&gt;&gt; mylist = [&#39;aardvark&#39;, &#39;baboon&#39;, &#39;cat&#39;]
&gt;&gt;&gt; print_three_things(*mylist)

a = aardvark, b = baboon, c = cat
</code></pre>

<p>它可以传递列表（或元组）并将它们解包。注意必须与它们在函数中的参数相吻合</p>

<p>参考：<a href="http://stackoverflow.com/questions/3394835/args-and-kwargs">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>

<h3 id="toc_10">面向切面编程 AOP 和装饰器</h3>

<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数本身无关的雷同代码并继续重用。概括来讲，<mark>装饰器的作用就是为已经存在的对象添加额外的功能</mark>。</p>

<p>详细参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></li>
<li><a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></li>
<li><a href="https://www.zhihu.com/question/24863332">https://www.zhihu.com/question/24863332</a></li>
</ul>

<p>什么是 AOP：</p>

<blockquote>
<p>面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。<br/><br/>
但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。<br/><br/>
也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<mark>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</mark><br/><br/>
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br/><br/>
AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。</p>
</blockquote>

<h3 id="toc_11">鸭子类型</h3>

<blockquote>
<p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p>
</blockquote>

<p>我们不关心对象是什么类型，到底是不是鸭子，只关心行为。</p>

<p>比如在 Python 中，有很多 file-like 的东西，StringIO/GzipFile/socket。它们有很多相同的方法，我们把它们都当做文件使用。</p>

<p>鸭子类型在动态语言中经常使用，非常灵活。使得 Python 不必像 Java 那样专门弄一堆设计模式。</p>

<h3 id="toc_12">Python 中的重载</h3>

<p><mark>Python 不支持函数重载</mark>。</p>

<p>函数重载主要是为了解决两个问题：</p>

<ul>
<li>可变参数类型</li>
<li>可变参数个数</li>
</ul>

<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数其实功能不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>

<p>对于情况 1，函数功能相同，但参数类型不同， 在 Python 中根本不需要处理，因为 Python 可以接受任何类型的参数，如果函数功能相同，那么不同的参数类型在 Python 中很可能是相同的代码，没有必要写成两个不同的函数。</p>

<p>对于情况 2，函数功能相同，但参数个数不同，Python 中处理的方式是使用缺省参数。对那些缺少的参数设定为缺省参数即可。</p>

<p>鉴于情况 1 和情况 2 Python 都有解决方案，所以就不需要重载了。</p>

<p>但是 Python 也可以实现重载的功能。</p>

<p>参考：<a href="http://www.zhihu.com/question/20053359">http://www.zhihu.com/question/20053359</a></p>

<h3 id="toc_13">新式类和旧式类</h3>

<p>详细参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python</a></li>
<li><a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></li>
</ul>

<h3 id="toc_14"><code>__new__</code> 和 <code>__init__</code></h3>

<ul>
<li><code>__new__</code> 是一个静态方法，而 <code>__init__</code> 是一个实例方法</li>
<li><code>__new__</code> 方法会返回一个创建的实例，而 <code>__init__</code> 什么都不返回</li>
<li>只有在 <code>__new__</code> 返回一个 cls 实例时后面的 <code>__init__</code> 才能被调用</li>
<li>当创建一个新实例时调用 <code>__new__</code>，初始化一个实例时用 <code>__init__</code></li>
</ul>

<p>参考：<a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init">http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init</a></p>

<h3 id="toc_15">单例模式</h3>

<p>Important！</p>

<h4 id="toc_16">什么是单例模式</h4>

<p>单例模式，也叫单子模式，是一种常用的软件设计模式。<mark>在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</mark>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>

<p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>

<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>

<h4 id="toc_17">1. 使用 <code>__new__</code> 方法</h4>

<pre><code class="language-python">class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, &#39;_instance&#39;):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1
</code></pre>

<h4 id="toc_18">2. 共享属性</h4>

<p>创建实例时把所有实例的 <code>__dict__</code> 指向同一个字典，这样它们具有相同的属性和方法。</p>

<pre><code class="language-python">class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1
</code></pre>

<h4 id="toc_19">3. 装饰器版本</h4>

<pre><code class="language-python">def singleton(cls, *args, **kw):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance

@singleton
class MyClass:
  ...
</code></pre>

<h4 id="toc_20">4. import 方法</h4>

<pre><code class="language-python"># mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()

# to use
from mysingleton import my_singleton

my_singleton.foo()
</code></pre>

<p>作为 Python 的模块是天然的单例方法。</p>

<h3 id="toc_21">Python 中的作用域</h3>

<p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>

<p>当 Python 遇到一个变量的话它会按照如下顺序进行搜索：</p>

<p>本地作用域（Local） -&gt; 当前作用域没嵌入的作用域（Enclosing locals） -&gt; 全局/模块作用域（Global） -&gt; 内置作用域（Built-in）</p>

<h3 id="toc_22">GIL 线程全局锁</h3>

<p>线程全局锁（Global Interpreter Lock），即 Python 为了保证线程安全而采取的独立线程运行的机制，说白了就是一个核只能在同一时间运行一个线程。</p>

<p>解决办法就是多进程和下面的协程（协程也只是单 CPU，但能减小切换代价提升性能）。</p>

<p>参考：<a href="http://www.oschina.net/translate/pythons-hardest-problem">http://www.oschina.net/translate/pythons-hardest-problem</a></p>

<h3 id="toc_23">协程</h3>

<p>待补充</p>

<h3 id="toc_24">闭包</h3>

<p>闭包（Closure）是函数式编程中的重要语法结构。</p>

<p><mark>当一个内嵌函数引用其外部作用域的变量，我们就会得到一个闭包。</mark> 创建一个闭包必须满足以下几点：</p>

<ul>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ul>

<h3 id="toc_25">lambda 函数</h3>

<p>Python 中的 lambda 函数即匿名函数。</p>

<p>参考：<a href="https://www.zhihu.com/question/20125256">https://www.zhihu.com/question/20125256</a></p>

<h3 id="toc_26">Python 函数式编程</h3>

<p>详细参考：<a href="http://coolshell.cn/articles/10822.html">http://coolshell.cn/articles/10822.html</a></p>

<h3 id="toc_27">Python 里的拷贝</h3>

<p>引用和 <code>copy()</code>, <code>deepcopy()</code> 的区别：</p>

<pre><code class="language-python">import copy
a = [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append(&#39;c&#39;)  #修改对象a中的[&#39;a&#39;, &#39;b&#39;]数组对象

print &#39;a = &#39;, a
print &#39;b = &#39;, b
print &#39;c = &#39;, c
print &#39;d = &#39;, d

输出结果：
a =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5]
b =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5]
c =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]
d =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]]
</code></pre>

<h3 id="toc_28">Python 垃圾回收机制</h3>

<p>Python GC 主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用基础上，通过「标记-清除」（mark and sweep）解决容器对象可能产生的循环引用问题，通过「分代回收」（generation collection）以空间换时间的方法提高垃圾回收效率。</p>

<h4 id="toc_29">1. 引用计数</h4>

<p>PyObject 是每个对象必有的内容，其中，<code>ob_refcnt</code> 就是作为引用计数。当一个对象有新的引用时，它的 <code>ob_refcnt</code> 就会增加，当引用它的对象呗删除，它的 <code>ob_refcnt</code> 就会减少。引用计数为 0 时，该对象的生命就结束了。</p>

<p>优点：</p>

<ul>
<li>简单</li>
<li>实时性</li>
</ul>

<p>缺点：</p>

<ul>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ul>

<h4 id="toc_30">2. 「标记-清除」机制</h4>

<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为结点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>

<h4 id="toc_31">3. 分代技术</h4>

<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个「代」，垃圾收集频率随着「代」存货时间的增大而减小，存货时间通常利用经过几次垃圾回收来度量。</p>

<p>Python 默认定义了三代对象集合，索引数越大，对象存货时间越长。</p>

<p>举例：当某些内存块 M 经过了 3 此垃圾收集的清洗之后还存活时，我们就将内存块 M 划分到一个集合 A 中去，而新分配的内存都划分到集合 B 中去。当垃圾收集开始工作时，大多数情况都只对集合 B 进行垃圾回收，而对集合 A 进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存减少了，效率自然就提高了。在这个过程中，集合 B 中的某些内存块由于存货时间长而会被转移到集合 A 中，当然，集合 A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代机制而被延迟。</p>

<h3 id="toc_32">Python 中 list 的实现</h3>

<p>详细参考：<a href="http://www.jianshu.com/p/J4U6rR">Python 中 List 的实现</a></p>

<h3 id="toc_33">Python 的 is</h3>

<p><code>is</code> 是对比地址，<code>==</code> 是对比值</p>

<h3 id="toc_34">read/readline/readlines</h3>

<ul>
<li>read 读取整个文件</li>
<li>readline 读取下一行，使用生成器的方式</li>
<li>readlines 读取整个文件到一个迭代器以供我们遍历</li>
</ul>

<h3 id="toc_35">Python 2 和 3 的区别</h3>

<p>详细参考：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/">http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/</a></p>

<h2 id="toc_36">操作系统</h2>

<h3 id="toc_37">select、poll 和 epoll</h3>

<p>待补充。</p>

<h3 id="toc_38">调度算法</h3>

<ol>
<li>先来先服务（FCFS, First Come First Server）</li>
<li>短作业优先（SJF, Shortest Job First）</li>
<li>最高优先权调度（Priority Scheduling）</li>
<li>时间片轮转（RR, Round Robin）</li>
<li>多级反馈队列调度（multilevel feedback queue scheduling）</li>
</ol>

<p>实时调度算法：</p>

<ol>
<li>最早截止时间优先 EDF</li>
<li>最低松弛度优先 LLF</li>
</ol>

<h3 id="toc_39">死锁</h3>

<p>原因：</p>

<ol>
<li>竞争资源</li>
<li>程序推进顺序不当</li>
</ol>

<p>必要条件：</p>

<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>

<p>处理死锁的基本方法：</p>

<ol>
<li>预防死锁</li>
<li>避免死锁（银行家算法）</li>
<li>检测死锁（资源分配图）</li>
<li>解除死锁

<ul>
<li>剥夺资源</li>
<li>撤销进程</li>
</ul></li>
</ol>

<h3 id="toc_40">程序的编译和链接</h3>

<p>待补充。</p>

<h3 id="toc_41">静态链接和动态链接</h3>

<p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来，静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库。</p>

<p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算（被调用的那部分）动态代码的逻辑地址，然后等到某个时候，程序有需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以这种方式使程序初始化的时间较短，但运行期间的性能比不上静态链接的程序。</p>

<h3 id="toc_42">虚拟内存技术</h3>

<p>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储系统。</p>

<h3 id="toc_43">分页和分段</h3>

<p>分页：用户程序的地址空间被划分为若干个固定大小的区域，称为「页」，相应的，内存空间分成若干个物理块，页和块的大小相等，可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>

<p>分段：将用户程序的地址空间分成若干个大小不等的「段」，每段可以定义一组相对完整的逻辑信息。存储分配时，以段位单位，段与段在内存中可以不相邻接，也实现了离散分配。</p>

<p>分页与分段的主要区别：</p>

<ol>
<li>页的信息是物理单位，分页是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要，段是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了更好得实现共享，满足用户的需要。</li>
<li>页的大小固定，由系统决定，将逻辑地址划分为页号和页内地址是由及其硬件实现的。而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分。</li>
<li>分页的作业地址空间是一维的，分段的地址空间是二维的。</li>
</ol>

<h3 id="toc_44">页面置换算法</h3>

<ol>
<li>最先置换算法 OPT：不可能实现</li>
<li>先进先出 FIFO</li>
<li>最近最久未使用算法 LRU：最近一段时间里最久没有使用过的页面予以置换</li>
<li>clock 算法</li>
</ol>

<h3 id="toc_45">边缘触发和水平触发</h3>

<p>边缘触发是指每当状态发生变化时发生一个 IO 事件，条件触发是只要满足条件就发生一个 IO 事件。</p>

<h2 id="toc_46">数据库</h2>

<h3 id="toc_47">事务</h3>

<p>数据库事务（Database Transaction），是指作为单个逻辑工作单元执行的一系列操作，要么完全得执行，要么完全得不执行。</p>

<h3 id="toc_48">数据库索引</h3>

<p>参考资料：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>

<h3 id="toc_49">Redis 原理</h3>

<p>待补充。</p>

<h3 id="toc_50">乐观锁和悲观锁</h3>

<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>
<li>乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性</li>
</ul>

<h2 id="toc_51">网络</h2>

<h3 id="toc_52">ARP 协议</h3>

<p>地址解析协议（Address Resolution Protocol），其基本功能为透过目标设备的 IP 地址，查询目标的 Mac 地址，以保证通信的顺利进行。它是 IPv4 网络层必不可少的协议，不过在 IPv6 中已不再适用，并被邻居发现协议（NDP）替代。</p>

<h3 id="toc_53">POST 和 GET</h3>

<p>参考阅读：</p>

<ul>
<li><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html">GET和POST有什么区别？及为什么网上的多数答案都是错的</a></li>
<li><a href="https://www.zhihu.com/question/31640769?rf=37401322">post 相比get 有很多优点，为什么现在的HTTP通信中大多数请求还是使用get？</a></li>
</ul>

<h3 id="toc_54">Cookie 和 Session</h3>

<table>
<thead>
<tr>
<th></th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>

<tbody>
<tr>
<td>存储位置</td>
<td>客户端</td>
<td>服务器端</td>
</tr>
<tr>
<td>目的</td>
<td>跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td>跟踪会话</td>
</tr>
<tr>
<td>安全性</td>
<td>不安全</td>
<td>安全</td>
</tr>
</tbody>
</table>

<p>Session 技术是要使用到 Cookie 的，之所以出现 Session 技术，主要是为了安全。</p>

<h3 id="toc_55">Apache 和 Nginx 的区别</h3>

<p>Nginx 相对于 Apache 的优点：</p>

<ul>
<li>轻量级：同样的 Web 服务，比 Apache 占用更少的内存及资源</li>
<li>抗并发：Nginx 处理请求时异步非阻塞的，支持更多的并发连接，而 Apache 则是阻塞型的，在高并发下 Nginx 能保持低资源低消耗高性能</li>
<li>配置简洁</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>

<p>Apache 相对 Nginx 的优点：</p>

<ul>
<li>rewrite 比 Nginx 的 rewrite 强大</li>
<li>模块很多，基本可以想到的都能找到</li>
<li>bug 少，Nginx bug 多</li>
<li>很稳定</li>
</ul>

<h3 id="toc_56">网站用户密码保存</h3>

<ul>
<li>明文保存</li>
<li>明文 hash 后保存，如 md5</li>
<li>MD5 + salt 方式，这个 salt 可以随机</li>
<li>知乎使用了 Bcrypy 加密（待考）</li>
</ul>

<h3 id="toc_57">HTTP 和 HTTPS</h3>

<p>待补充。</p>

<h3 id="toc_58">XSRF 和 XSS</h3>

<p>参考 <a href="14889309726832.html">计算机网络</a></p>

<h3 id="toc_59">CGI 和 WSGI</h3>

<p>CGI 是通用网关接口，是连接 web 服务器和应用程序的接口，用户通过 CGI 来获取动态数据或文件等。CGI 程序是一个独立的程序，它可以用几乎所有语言来写。</p>

<p>WSGI（Web Server Gateway Interface），是 Python 应用程序或 Web 框架与服务器之间的一种接口，WSGI 的其中一个目的就是让用户可以用统一的语言（Python）来编写前后端。</p>

<h3 id="toc_60">中间人攻击</h3>

<p>中间人攻击（Man in the middle attack, MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为它们正在通过一个私密的连接与对方直接对话，但事实上整个对话都被攻击者完全控制。</p>

<h3 id="toc_61">CK10 问题</h3>

<p>指的是服务器同时支持成千上万个客户端的问题。</p>

<p>参考阅读：<a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></p>

<h3 id="toc_62">Ajax</h3>

<p>Ajax（Asynchronous JavaScript and Xml，异步的 JavaScript 和 XML），是指在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14872260244406.html">Python Cookbook</a></h1>
			<p class="meta"><time datetime="2017-02-16T14:20:24+08:00" 
			pubdate data-updated="true">2017/2/16</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">调用父类的方法</h2>

<p><code>super()</code> 的常见用法：</p>

<ol>
<li>在 <code>__init__()</code> 方法中确保父类被正确初始化了</li>
<li>另外一个常见用法出现在覆盖 Python 特殊方法的代码中</li>
</ol>

<p>Ex:</p>

<pre><code class="language-python">class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith(&#39;_&#39;):
            super().__setattr__(name, value) # Call original __setattr__
        else:
            setattr(self._obj, name, value)
</code></pre>

<p>在上面代码中，<code>__setattr__()</code> 的实现包含一个名字检查。如果某个属性名以 <code>_</code> 开头，就通过 <code>super()</code> 调用原始的 <code>__setattr__()</code>，否则的话就委派给类内部的代理对象 <code>self._obj</code> 去处理。这看上去有点意思，因为就算没有显式指明某个类的父类，<code>super()</code> 仍然可以有效地工作。</p>

<h2 id="toc_1">子类中扩展 Property</h2>

<p>在自雷中扩展一个 property 可能会引起很多不易察觉的问题，因为一个 property 其实是 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法的几何，而不是单个的方法。因此，当你扩展一个 property 的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中的一个。</p>

<h2 id="toc_2">创建新的类或实例属性</h2>

<p>描述器：一个实现了三个核心的属性访问操作（get, set, delete）的类，分别为 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code> 这三个特殊的方法。这些方法接受一个实例作为输入，之后相应的操作实例实例底层的字典。</p>

<p>为了使用一个描述器，需要将这个描述器的实例作为类属性放到一个类的定义中。</p>

<p>一个基于描述器的高级代码：</p>

<pre><code class="language-python"># Descriptor for a type-checked attribute
class Typed:
    def __init__(self, name, expected_type):
        self.name = name
        self.expected_type = expected_type
    def __get__(self, instance, cls):
        if instance is None:
            return self
        else:
            return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(&#39;Expected &#39; + str(self.expected_type))
        instance.__dict__[self.name] = value
    def __delete__(self, instance):
        del instance.__dict__[self.name]

# Class decorator that applies it to selected attributes
def typeassert(**kwargs):
    def decorate(cls):
        for name, expected_type in kwargs.items():
            # Attach a Typed descriptor to the class
            setattr(cls, name, Typed(name, expected_type))
        return cls
    return decorate

# Example use
@typeassert(name=str, shares=int, price=float)
class Stock:
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14871569977647.html">Python 风格指南笔记</a></h1>
			<p class="meta"><time datetime="2017-02-15T19:09:57+08:00" 
			pubdate data-updated="true">2017/2/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>
<a href="#toc_0">函数与方法装饰器</a>
</li>
<li>
<a href="#toc_1">线程</a>
</li>
<li>
<a href="#toc_2">威力过大的特性</a>
</li>
<li>
<a href="#toc_3">注释</a>
<ul>
<li>
<a href="#toc_4">模块</a>
</li>
<li>
<a href="#toc_5">函数和方法</a>
</li>
<li>
<a href="#toc_6">类</a>
</li>
<li>
<a href="#toc_7">块注释和行注释</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">类</a>
</li>
<li>
<a href="#toc_9">TODO 注释</a>
</li>
<li>
<a href="#toc_10">导入格式</a>
</li>
<li>
<a href="#toc_11">访问控制</a>
</li>
<li>
<a href="#toc_12">命名</a>
</li>
</ul>


<h2 id="toc_0">函数与方法装饰器</h2>

<ul>
<li>优点：优雅的在函数上指定一些转换，该转换可能减少一些重复代码，保持已有函数不变（enforce invariants）</li>
<li>缺点：装饰器可以在函数的参数或返回值上执行任何操作，这可能导致让人惊异的隐藏行为。而且，装饰器在导入时执行。从装饰器代码的失败中恢复更加不可能。</li>
<li>结论：如果好处很显然，就明智而谨慎的使用装饰器。装饰器应该遵守和函数一样的导入和命名规则。装饰器的 Python 文档应该清晰的说明函数是一个装饰器。请为装饰器编写单元测试。<strong>避免装饰器自身对外界的依赖（即不要依赖于文件、socket、数据库连接等）</strong>。</li>
</ul>

<h2 id="toc_1">线程</h2>

<p>优先使用 Queue 模块的 <code>Queue</code> 数据类型作为线程间的数据通信方式。另外，使用 threading 模块及其锁原语（locking primitives）。了解条件变量的合适使用方式，这样你就可以使用 <code>threading.Condition</code> 来取代低级级别的锁了。</p>

<h2 id="toc_2">威力过大的特性</h2>

<ul>
<li>Tip：避免使用这些特性</li>
<li>优点：强大的语言特性，能让你的代码更紧凑</li>
<li>缺点：使用这些很 cool 的特性十分诱人，但不是绝对必要。使用奇技淫巧的代码将更加难以阅读和调试。开始可能还好，但当你回顾代码，它们可能比那些稍长一点但是更直接的代码更加难以理解。</li>
<li>结论：在你的代码中避免使用这些特性。</li>
</ul>

<h2 id="toc_3">注释</h2>

<p>Python 有一种独一无二的注释方式：使用文档字符串。文档字符串是包、模块、类或函数的第一个语句。这些字符串可以通过对象的 <code>__doc__</code> 成员被自动提取，并且被 <code>pydoc</code> 所用。</p>

<p>组织方式：</p>

<ul>
<li>第一行以句号、问号或惊叹号结尾的概述（或者改文档字符串只有单纯的一行）</li>
<li>接着是一个空行</li>
<li>接着是文档字符串的剩余部分，它应当与文档字符串的第一行的第一个引号对齐</li>
</ul>

<h3 id="toc_4">模块</h3>

<p>每个文件应该包含一个许可样板。根据项目使用的许可（例如：Apache 2.0、BSD、LGPL、GPL）选择合适的样板。</p>

<h3 id="toc_5">函数和方法</h3>

<p>一个函数必须要有文档字符串，除非它满足以下条件：</p>

<ol>
<li>外部不可见</li>
<li>非常短小</li>
<li>简单明了</li>
</ol>

<p>文档字符串应该包含函数做什么，以及输入和输出的详细描述。通常，<strong>不应该描述「怎么做」，除非是一些复杂的算法</strong>。文档字符串应该提供足够的信息，当别人编写代码调用该函数时，他不需要看一行代码，只要看文档字符串就可以了。<strong>对于复杂的代码，在代码旁边加注释胡比使用文档字符串更有意义</strong>。</p>

<p>关于函数的几个方面应该在特定的小节中进行描述记录，这几个方面入下文所示，每节应该以一个标题行开始。标题行以冒号结尾，除标题行外，节的其他内容应被缩进 2 个空格。</p>

<ul>
<li>Args：列出每个每个参数的名字，并在名字后面使用一个冒号和空格，分隔对该参数的描述。如果描述太长超过了单行 80 个字符，使用 2 或者 4 个空格的悬挂缩进。<strong>描述应该包括所需的类型和含义</strong>。如果一个函数接受<code>可变长参数列表</code>或者<code>任意关键字参数</code>，应该详细列出这两者。</li>
<li>Returns（或者 Yields，用于生成器）：描述返回值的类型和语义，如果函数返回 None，这一部分可以省略。</li>
<li>Raises：列出与接口有关的所有异常。</li>
</ul>

<p>例子：</p>

<pre><code class="language-python">def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):
    &quot;&quot;&quot;Fetches rows from a Bigtable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by big_table.  Silly things may happen if
    other_silly_variable is not None.

    Args:
        big_table: An open Bigtable Table instance.
        keys: A sequence of strings representing the key of each table row
            to fetch.
        other_silly_variable: Another optional variable, that has a much
            longer name than the other args, and which does nothing.

    Returns:
        A dict mapping keys to the corresponding table row data
        fetched. Each row is represented as a tuple of strings. For
        example:

        {&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),
         &#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),
         &#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}

        If a key from the keys argument is missing from the dictionary,
        then that row was not found in the table.

    Raises:
        IOError: An error occurred accessing the bigtable.Table object.
    &quot;&quot;&quot;
    pass
</code></pre>

<h3 id="toc_6">类</h3>

<p>类应该在其定义下有一个用于描述该类的文档字符串。如果你的类有公有属性，那么文档中应该有一个属性段，并且应该遵守和函数参数相同的格式。</p>

<pre><code class="language-python">class SampleClass(object):
    &quot;&quot;&quot;Summary of class here.

    Longer class information....
    Longer class information....

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
    &quot;&quot;&quot;

    def __init__(self, likes_spam=False):
        &quot;&quot;&quot;Inits SampleClass with blah.&quot;&quot;&quot;
        self.likes_spam = likes_spam
        self.eggs = 0

    def public_method(self):
        &quot;&quot;&quot;Performs operation blah.&quot;&quot;&quot;
</code></pre>

<h3 id="toc_7">块注释和行注释</h3>

<p><strong>最需要些注释的是代码中那些技巧性的部分</strong>。对于复杂的操作，应该在其操作开始前写上若干行注释，对于不是一幕了然的代码，应该在其行尾添加注释。</p>

<p>为了提高可读性，注释至少应该离开代码 2 个空格。</p>

<p><strong>绝对不要描述代码</strong>，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么。</p>

<h2 id="toc_8">类</h2>

<p>如果一个类不继承自其它类，就显式的从 object 继承，嵌套类也一样。</p>

<h2 id="toc_9">TODO 注释</h2>

<p>TODO 注释应该在所有开头处包含「TODO」字符串，紧跟着的是用括号括起来的你的名字，email 地址或者其他标识符。接着必须有一行注释，解释要做什么。</p>

<p>Example：</p>

<pre><code class="language-python"># TODO(kl@gmail.com): Use a &quot;*&quot; here for string repetition.
# TODO(Zeke) Change this to use relations.
</code></pre>

<p>如果你的 TODO 是「将来做某事」的形式，那么请确保你包含了一个指定的日期或者一个特定的时间。</p>

<h2 id="toc_10">导入格式</h2>

<p>每个导入应该独占一行。导入总应该放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前，导入应该按照从最通用到最不通用的顺序分组：</p>

<ol>
<li>标准库导入</li>
<li>第三方库导入</li>
<li>应用程序制定导入</li>
</ol>

<p>每种分组中，应该根据每个模块的完整包路径按字典顺序排序，忽略大小写。</p>

<h2 id="toc_11">访问控制</h2>

<p>字啊 Python 中，对于琐碎又不太重要的访问函数，你应该直接使用公有变量来取代它们，这样可以避免额外的函数调用开销。当添加更多的功能时，你可以用属性（property）来保持语法的一致性。</p>

<p>另一方面，如果访问更复杂，或者变量的访问开销很显著，那么你应该使用像 <code>get_foo()</code> 和 <code>set_foo()</code> 这样的函数调用。如果之前的代码行为允许通过属性（property）访问，那么久不要井新的访问函数与属性绑定。这样，任何试图通过老方法访问变量的代码就没法运行，使用者也就会意识到复杂性发生了变化。</p>

<h2 id="toc_12">命名</h2>

<p>Python 之父 Guido 推荐的规范：</p>

<p><img src="media/14871569977647/14872190162425.jpg" alt=""/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="14824095038232.html">The Python Tutorial Reading Notes</a></h1>
			<p class="meta"><time datetime="2016-07-17T20:25:03+08:00" 
			pubdate data-updated="true">2016/7/17</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h2 id="toc_0">Data Structures</h2>

<h3 id="toc_1">More on Lists</h3>

<ul>
<li><code>list.append(x)</code>: Equivalent to <code>a[len(a):] = [x]</code></li>
<li><code>list.extend(L)</code>: Extend the list by appending all the items in the given list. Equivalent to <code>a[len(a):] = L</code></li>
<li><code>list.insert(i, x)</code>: The first argument is the index of the element before which to insert. <code>a.insert(len(a), x)</code> == <code>a.append(x)</code>.</li>
<li><code>list.remove(x)</code>: Remove the first item form the list whose value is x.</li>
<li><code>list.pop([i])</code>: Remove the item at the given position in the list, and return it. If no index is specified, <code>a.pop()</code> removes and returns the last item in the list.（parameters with square brackets are optional）</li>
<li><code>list.clear()</code>: Remove all item from the list. Equivalent to <code>del a[:]</code></li>
<li><code>list.index(x)</code>: Return the index in the list of the first item whose value is x.</li>
<li><code>list.count(x)</code>: Return the number of times x appears in the list.</li>
<li><code>list.sort(key=None, reverse=False)</code>: Sort the items of the list in place.</li>
<li><code>list.reverse()</code>: Reverse the elements of the list in place.</li>
<li><code>list.copy()</code>: Return a shallow copy of the list. Equivalent to <code>a[:]</code>.</li>
</ul>

<h4 id="toc_2">Using Lists as Stacks</h4>

<p>Use <code>append</code> and <code>pop</code>.</p>

<h4 id="toc_3">Using Lists as Queues</h4>

<p>Lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from beginning of a list is slow.</p>

<p>Better to use <code>collections.deque</code>.</p>

<h4 id="toc_4">List Comprehensions</h4>

<ul>
<li><code>x = [item for item in series]</code></li>
<li><code>x = [do_something(item) for item in series if expression]</code></li>
</ul>

<h4 id="toc_5">Nested List Comprehensions</h4>

<p>The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension.</p>

<p>Example: <code>[[row[i] for row in matrix] for i in range(4)]</code>.</p>

<h4 id="toc_6">The <code>del</code> statement</h4>

<p>Remove an item from a list given its index. (Do not return a value) It can also remove slices from a list.</p>

<p><code>del</code> can also be used to delete entire variables: <code>del a</code>.</p>

<h3 id="toc_7">Tuples and Sequences</h3>

<p>Tuples are <code>immutable</code>, and usually contain a heterogeneous sequence of elements that are accessed via unpacking or indexing. List are <code>mutable</code>, and their element are usually homogeneous and are accessed by iterating over the list.</p>

<ul>
<li>Empty tuples are constructed by and empty pair of parentheses: <code>empty = ()</code></li>
<li>A tuple with one item is constructed by following a value with a comma:     <code>sigleton = &#39;hello&#39;,</code></li>
</ul>

<p>The statement <code>t = 1, 2, &#39;hello&#39;</code> is an example of <code>tuple packing</code>: the values are packed together in a tuple. The reverse operation is also possible: <code>x, y, z = t</code>.</p>

<h3 id="toc_8">Sets</h3>

<p><code>{}</code> or <code>set()</code> function can be used to create sets. Note: to create an empty set you have to use <code>set()</code>, not <code>{}</code>; the latter creates an empty dictionary.</p>

<p>Example: </p>

<pre><code class="language-python">a = set(&#39;abracadabra&#39;)
b = set(&#39;alacazam&#39;)
</code></pre>

<ul>
<li><code>a - b</code>: letters in a but not in b</li>
<li><code>a | b</code>: letters in either a or b</li>
<li><code>a &amp; b</code>: letters in both a and b</li>
<li><code>a ^ b</code>: letters in a or b but not both</li>
</ul>

<p>Similaryly to list comprehensions, set comprehensions are also supported.</p>

<h3 id="toc_9">Dictionaries</h3>

<p>Dictionaries are indexed by keys, which can be any immutable type; strings and numbers can slways be keys. Tuples can be used as keys if they contain only one kind of item. You can&#39;t use use lists as keys, since lists can be modified in place using index assignments, slice assignments, or method like append() and extend().</p>

<p>It is best to think of a dictionary as an unordered set of <code>key: value</code> pairs.</p>

<ul>
<li><code>del</code> can delete a <code>key: value</code></li>
<li><code>list(d.keys())</code> on a dictionary returns a list of all the keys used in the dictionary, in arbitrary order (if you want it sorted, use <code>sortted(d.keys())</code> instead).</li>
<li>To check whether a single key is in the dictionary, use the <code>in</code> keyword. (<code>in</code> or <code>not in</code>)</li>
<li>Dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: <code>{x: x**2 for x in range(10)}</code></li>
<li>When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments: <code>dic(sape=1, guido=2, jack=3)</code> =&gt; <code>{&#39;sape&#39;: 1, &#39;jack&#39;: 3, &#39;guido&#39;: 2}</code></li>
</ul>

<h3 id="toc_10">Looping Techniques</h3>

<p>When looping through dictionaries, the key and corresponding value can be retrieved at the same time using the items() method.</p>

<pre><code class="language-python">knights = {&#39;gallahad&#39;: &#39;the pure&#39;, &#39;robin&#39;: &#39;the brave&#39;}
for k, v in knights.items():
    print(k, v)
</code></pre>

<p>When looping through a sequence, the position index and correspoding value can be retrieved at the same time using the <code>enumerate()</code> function.</p>

<pre><code class="language-python">for i, v in enumerate([&#39;tic&#39;, &#39;tac&#39;, &#39;toe&#39;]):
    print(i, v)
</code></pre>

<p>To loop over two or more sequences at the same time, the entries can be paired with the <code>zip()</code> function.</p>

<pre><code class="language-python">numbers = [1, 2, 3]
names = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]
for number, name in zip(numbers, names):
    print(&#39;Number: {0}, Name: {1}&#39;.format(number, name))
</code></pre>

<p>To loop over a sequence in sorted order, use the <code>sorted()</code> function which return a new sorted list while leaving the source unaltered. <code>for item in soted(list)</code></p>

<p>It is sometimes tempting to change a list while you are looping over it; however, it is often simple and safer to create a new list instead.</p>

<h3 id="toc_11">More on Conditions</h3>

<ul>
<li><code>in</code> and <code>not in</code>: check whether a value occurs (or not) in a sequence.</li>
<li><code>is</code> and <code>is not</code>: compare whether two objects are really the same object; this only matters for mutable objcts like lists.</li>
<li>Comparisons can be chained. <code>a &lt; b == c</code></li>
<li><code>and</code> and <code>or</code> are <code>short-circuit</code> operators</li>
</ul>

<h3 id="toc_12">Comparing Sequences and Other Types</h3>

<p>The comparison uses lexicographical ordering.</p>

<h2 id="toc_13">Modules</h2>

<p>A module is a file containing Python definitions and statements. The file name is the module name with the suffix <code>.py</code> appended. Within a module, the module&#39;s name (as a string) is available as the value of the global variable <code>__name__</code>.</p>

<h3 id="toc_14">More on Modules</h3>

<p>Note that in general the practice of importing <code>*</code> from a module is frowned upon, since it often causes poorly readable code. (It ok to use in interactive sessions.)</p>

<p>It&#39;s one module you want to test interactively, use <code>importlib.reload()</code>.</p>

<pre><code class="language-python">import importlib
importlib.reload(modulename)
</code></pre>

<h4 id="toc_15">Executing modules as scripts</h4>

<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    code
</code></pre>

<p>This is often used either to provide a convenient user interface to a module, or for testing purposes (running the module as a script executes a test suite).</p>

<h4 id="toc_16">The Module Search Path</h4>

<p>When a module named <em>spam</em> is imported, the interpreter first searches for a built-in module with that name. If not found, it then searches for a file named <code>spam.py</code> in a list of directories given by the variable <code>sys.path</code>, it is initialized from these locations:</p>

<ul>
<li>The directory containing the input script (or the current directory when no file is specified).</li>
<li><code>PYTHONPATH</code> (a list of directory names, with the same syntax as the shell variable <em>PATH</em>).</li>
<li>The installation-dependent default.</li>
</ul>

<p>After initialization, Python programs can modify <code>sys.path</code>. The directory containing the script being run is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in that directory will be loaded instead of modules of the same name in the library directory.</p>

<h4 id="toc_17">&quot;Compiled&quot; Python files</h4>

<p>Python caches the compiled version of each module in the <code>__pycache__</code> directory. It generally contains the Python version number. This naming convention allows compiled modules from dirrerent release and different version of Python to coexist. (Example: <code>__pycache__/fib.python-27.pyc</code>)</p>

<p>Python check the modification date of the source against the compiled version to see if it&#39;s out of date and needs to be recompiled.</p>

<h3 id="toc_18">Standard Modules</h3>

<pre><code class="language-python">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.ps1
&#39;&gt;&gt;&gt; &#39;
&gt;&gt;&gt; sys.ps2
&#39;... &#39;
&gt;&gt;&gt; sys.ps1 = &#39;C&gt; &#39;
C&gt; print(&#39;Yuck!&#39;)
Yuck!
</code></pre>

<p>The variable <code>sys.path</code> is a list of strings that determines the interpreter&#39;s search path for modules. You can modify it using standard list operations.</p>

<h3 id="toc_19">The <code>dir()</code> Function</h3>

<p>The built-in function <code>dir()</code> is used to find out which names a module defines.</p>

<p>Without arguments, <code>dir()</code> lists the names you have defined currently.</p>

<p>It list all types of names: variable, modules, functions, etc.</p>

<h2 id="toc_20">Input and Output</h2>

<h3 id="toc_21">Methods of File Objects</h3>

<p>It is good practice to use the <code>with</code> keyword when dealing with file objects. This has the advantage that the file is properly closed after its suite finishes, even if an exceptiohn is raissed on the way. It is also much shorter thatn writing equivalent <code>try-finally</code> blocks:</p>

<pre><code class="language-python">with open(&#39;workfile&#39;, &#39;r&#39;) as f:
    read_data = f.read()
</code></pre>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="programming.html"><strong>Programming&nbsp;(26)</strong></a>
	         <p class="cat-children-p"> 
	        
	        	<a href="python.html">Python&nbsp;(8)</a>&nbsp;&nbsp;
	        
	        	<a href="algorithms.html">Algorithms&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="swift.html">Swift&nbsp;(11)</a>&nbsp;&nbsp;
	        
	        	<a href="lisp.html">Lisp&nbsp;(3)</a>&nbsp;&nbsp;
	        
	        	<a href="javascript.html">JavaScript&nbsp;(1)</a>&nbsp;&nbsp;
	        
	        	<a href="network.html">Network&nbsp;(2)</a>&nbsp;&nbsp;
	        
	         </p> 
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="15079735695142.html">什么是 Event Loop？</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15079725923338.html">雾里看花之 Python Asyncio</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15078822029815.html">全栈必备：网络编程基础</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15078804008494.html">函数式编程</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15077106861971.html">Scheme 笔记</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>