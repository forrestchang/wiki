<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Python 面试笔记 - Wiki
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Wiki" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">Wiki</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">Python 面试笔记</h1>
		<div class="entry-content" itemprop="articleBody">
			<ul>
<li>
<a href="#toc_0">Python 语言特性</a>
<ul>
<li>
<a href="#toc_1">Python 的函数参数传递</a>
</li>
<li>
<a href="#toc_2">Python 中的元类</a>
</li>
<li>
<a href="#toc_3">@staticmethod 和 @classmethod</a>
</li>
<li>
<a href="#toc_4">类变量和实例变量</a>
</li>
<li>
<a href="#toc_5">Python 自省</a>
</li>
<li>
<a href="#toc_6">字典推导式</a>
</li>
<li>
<a href="#toc_7">Python 中单下划线与双下划线的区别</a>
</li>
<li>
<a href="#toc_8">迭代器和生成器</a>
</li>
<li>
<a href="#toc_9"><code>*args</code> 和 <code>**kwargs</code></a>
</li>
<li>
<a href="#toc_10">面向切面编程 AOP 和装饰器</a>
</li>
<li>
<a href="#toc_11">鸭子类型</a>
</li>
<li>
<a href="#toc_12">Python 中的重载</a>
</li>
<li>
<a href="#toc_13">新式类和旧式类</a>
</li>
<li>
<a href="#toc_14"><code>__new__</code> 和 <code>__init__</code></a>
</li>
<li>
<a href="#toc_15">单例模式</a>
<ul>
<li>
<a href="#toc_16">什么是单例模式</a>
</li>
<li>
<a href="#toc_17">1. 使用 <code>__new__</code> 方法</a>
</li>
<li>
<a href="#toc_18">2. 共享属性</a>
</li>
<li>
<a href="#toc_19">3. 装饰器版本</a>
</li>
<li>
<a href="#toc_20">4. import 方法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">Python 中的作用域</a>
</li>
<li>
<a href="#toc_22">GIL 线程全局锁</a>
</li>
<li>
<a href="#toc_23">协程</a>
</li>
<li>
<a href="#toc_24">闭包</a>
</li>
<li>
<a href="#toc_25">lambda 函数</a>
</li>
<li>
<a href="#toc_26">Python 函数式编程</a>
</li>
<li>
<a href="#toc_27">Python 里的拷贝</a>
</li>
<li>
<a href="#toc_28">Python 垃圾回收机制</a>
<ul>
<li>
<a href="#toc_29">1. 引用计数</a>
</li>
<li>
<a href="#toc_30">2. 「标记-清除」机制</a>
</li>
<li>
<a href="#toc_31">3. 分代技术</a>
</li>
</ul>
</li>
<li>
<a href="#toc_32">Python 中 list 的实现</a>
</li>
<li>
<a href="#toc_33">Python 的 is</a>
</li>
<li>
<a href="#toc_34">read/readline/readlines</a>
</li>
<li>
<a href="#toc_35">Python 2 和 3 的区别</a>
</li>
</ul>
</li>
<li>
<a href="#toc_36">操作系统</a>
<ul>
<li>
<a href="#toc_37">select、poll 和 epoll</a>
</li>
<li>
<a href="#toc_38">调度算法</a>
</li>
<li>
<a href="#toc_39">死锁</a>
</li>
<li>
<a href="#toc_40">程序的编译和链接</a>
</li>
<li>
<a href="#toc_41">静态链接和动态链接</a>
</li>
<li>
<a href="#toc_42">虚拟内存技术</a>
</li>
<li>
<a href="#toc_43">分页和分段</a>
</li>
<li>
<a href="#toc_44">页面置换算法</a>
</li>
<li>
<a href="#toc_45">边缘触发和水平触发</a>
</li>
</ul>
</li>
<li>
<a href="#toc_46">数据库</a>
<ul>
<li>
<a href="#toc_47">事务</a>
</li>
<li>
<a href="#toc_48">数据库索引</a>
</li>
<li>
<a href="#toc_49">Redis 原理</a>
</li>
<li>
<a href="#toc_50">乐观锁和悲观锁</a>
</li>
</ul>
</li>
<li>
<a href="#toc_51">网络</a>
<ul>
<li>
<a href="#toc_52">ARP 协议</a>
</li>
<li>
<a href="#toc_53">POST 和 GET</a>
</li>
<li>
<a href="#toc_54">Cookie 和 Session</a>
</li>
<li>
<a href="#toc_55">Apache 和 Nginx 的区别</a>
</li>
<li>
<a href="#toc_56">网站用户密码保存</a>
</li>
<li>
<a href="#toc_57">HTTP 和 HTTPS</a>
</li>
<li>
<a href="#toc_58">XSRF 和 XSS</a>
</li>
<li>
<a href="#toc_59">CGI 和 WSGI</a>
</li>
<li>
<a href="#toc_60">中间人攻击</a>
</li>
<li>
<a href="#toc_61">CK10 问题</a>
</li>
<li>
<a href="#toc_62">Ajax</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">Python 语言特性</h2>

<h3 id="toc_1">Python 的函数参数传递</h3>

<p>所有的变量都可以理解为内存中一个对象的引用。</p>

<p>类型是属于对象的，而不是变量。而对象有两种，「可更改」（mutable） 与「不可更改」（inmutable） 对象。==在 Python 中，strings, tuples, numbers 是不可更改的对象，list, dict 则是可以更改的对象。</p>

<p>当一个引用传递给函数的时候，函数自动复制一份引用，这个函数里的引用就和外部的引用没有关系了。而在函数内的引用指向的是可变对象的时候，对它的操作就和定位了指针地址一样，可以直接在内存里进行修改。</p>

<p>参考阅读：<a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>

<h3 id="toc_2">Python 中的元类</h3>

<p>ORM 中会用到。</p>

<p>详细的解释：<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>

<h3 id="toc_3">@staticmethod 和 @classmethod</h3>

<p>Python 有三个方法：即静态方法（staticmethod）、类方法（classmethod）和实例方法。</p>

<pre><code class="language-python">def foo(x):
    print &quot;executing foo(%s)&quot;%(x)

class A(object):
    def foo(self,x):
        print &quot;executing foo(%s,%s)&quot;%(self,x)

    @classmethod
    def class_foo(cls,x):
        print &quot;executing class_foo(%s,%s)&quot;%(cls,x)

    @staticmethod
    def static_foo(x):
        print &quot;executing static_foo(%s)&quot;%x

a=A()
</code></pre>

<p><code>self</code> 和 <code>cls</code> 是对类或者实例的绑定。对于一般的函数我们可以这么调用 <code>foo(x)</code>，这个函数就是最常用的，它的工作和任何东西（类、实例）无关。对于实例方法，我们知道在类中每次定义方法都需要绑定这个实例，即 <code>foo(self, x)</code> ，因为实例方法的调用离不开实例，我们需要把实例自己传给函数，调用的时候是这样的 <code>a.foo(x)</code>（其实是 <code>foo(a, x)</code>）。类方法一样，只不过它传递的是类而不是实例，<code>A.class_foo(x)</code>。注意这里的 self 和 cls 可以替换成别的参数，但是 Python 的约定就是这两个，所以还是不要改比较好。</p>

<p>对于静态方法其实和普通方法一样，不需要对谁进行绑定，唯一的区别就是需要使用 <code>a.static_foo(x)</code> 或者 <code>A.static_foo(x)</code> 这样的方式来调用。</p>

<table>
<thead>
<tr>
<th></th>
<th>实例方法</th>
<th>类方法</th>
<th>静态方法</th>
</tr>
</thead>

<tbody>
<tr>
<td>a = A()</td>
<td>a.foo(x)</td>
<td>a.class_foo(x)</td>
<td>a.static_foo(x)</td>
</tr>
<tr>
<td>A</td>
<td>不可用</td>
<td>A.class_foo(x)</td>
<td>A.static_foo(x)</td>
</tr>
</tbody>
</table>

<p>详细讨论：<a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></p>

<h3 id="toc_4">类变量和实例变量</h3>

<pre><code class="language-python">class Person:
    name=&quot;aaa&quot;

p1=Person()
p2=Person()
p1.name=&quot;bbb&quot;
print p1.name  # bbb
print p2.name  # aaa
print Person.name  # aaa
</code></pre>

<p>类变量就是供类使用的变量，实例变量就是供实例使用的。</p>

<p>这里的 <code>p1.name=&quot;bbb&quot;</code> 是实例调用了类变量，这和上面的一个问题一样，就是函数传参的问题，<code>p1.name</code> 一开始指向的是类变量 <code>Person.name</code>，但在实例的作用域里把类变量的引用改变了，就变成了一个实例变量。</p>

<p>可以对比一下下面这个例子：</p>

<pre><code class="language-python">class Person:
    name=[]

p1=Person()
p2=Person()
p1.name.append(1)
print p1.name  # [1]
print p2.name  # [1]
print Person.name  # [1]
</code></pre>

<p>参考：<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>

<h3 id="toc_5">Python 自省</h3>

<p>自省就是面向对象的语言所写的程序在运行时，所能知道对象的类型。简单讲就是运行时能够获得对象的类型，比如 <code>type()</code>, <code>dir()</code>, <code>getattr()</code>, <code>hasattr()</code>, <code>isinstance()</code>。</p>

<h3 id="toc_6">字典推导式</h3>

<p>2.7 中加入的内容。</p>

<pre><code class="language-python">d = {key: value for (key, value) in iterable}
</code></pre>

<h3 id="toc_7">Python 中单下划线与双下划线的区别</h3>

<pre><code class="language-python">&gt;&gt;&gt; class MyClass():
...     def __init__(self):
...             self.__superprivate = &quot;Hello&quot;
...             self._semiprivate = &quot;, world!&quot;
...
&gt;&gt;&gt; mc = MyClass()
&gt;&gt;&gt; print mc.__superprivate
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: myClass instance has no attribute &#39;__superprivate&#39;
&gt;&gt;&gt; print mc._semiprivate
, world!
&gt;&gt;&gt; print mc.__dict__
{&#39;_MyClass__superprivate&#39;: &#39;Hello&#39;, &#39;_semiprivate&#39;: &#39;, world!&#39;}
</code></pre>

<ul>
<li><code>__foo__</code>：一种约定，Python 内部的名字，用来区别其他用户自定义的命名，以防冲突</li>
<li><code>_foo</code>：一种约定，用来指定变量是私有变量</li>
<li><code>__foo</code>：解析器用 <code>_classname__foo</code> 来代替这个名字，以区别和其他类相同的命名。</li>
</ul>

<p>参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></li>
<li><a href="http://www.zhihu.com/question/19754941">http://www.zhihu.com/question/19754941</a></li>
</ul>

<h3 id="toc_8">迭代器和生成器</h3>

<p>详细解释：<a href="https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html">https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p>

<h3 id="toc_9"><code>*args</code> 和 <code>**kwargs</code></h3>

<p>使用 <code>*args</code> 和 <code>**kwargs</code> 只是为了方便，并没有强制使用它们。</p>

<p>当你不确定函数中将要传入多少个参数时可以使用 <code>*args</code> ，它可以传递任意数量的参数。</p>

<p><code>**kwargs</code> 允许你使用事先未定义的参数名。</p>

<p>你也可混着使用，命名参数首先获得参数值，然后其他所有的参数都传给 <code>*args</code> 和 <code>**kwargs</code>。命名参数在列表的最前端：</p>

<pre><code class="language-python">def table_things(titlestring, **kwargs)
</code></pre>

<p><code>*args</code> 和 <code>**kwargs</code> 可以同时在函数的定义中，但是 <code>*args</code> 必须在 <code>**kwargs</code> 前面。</p>

<p>在调用函数时也可以使用 <code>*</code> 和 <code>**</code> 语法，例如：</p>

<pre><code class="language-python">&gt;&gt;&gt; def print_three_things(a, b, c):
...     print &#39;a = {0}, b = {1}, c = {2}&#39;.format(a,b,c)
...
&gt;&gt;&gt; mylist = [&#39;aardvark&#39;, &#39;baboon&#39;, &#39;cat&#39;]
&gt;&gt;&gt; print_three_things(*mylist)

a = aardvark, b = baboon, c = cat
</code></pre>

<p>它可以传递列表（或元组）并将它们解包。注意必须与它们在函数中的参数相吻合</p>

<p>参考：<a href="http://stackoverflow.com/questions/3394835/args-and-kwargs">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>

<h3 id="toc_10">面向切面编程 AOP 和装饰器</h3>

<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数本身无关的雷同代码并继续重用。概括来讲，<mark>装饰器的作用就是为已经存在的对象添加额外的功能</mark>。</p>

<p>详细参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></li>
<li><a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></li>
<li><a href="https://www.zhihu.com/question/24863332">https://www.zhihu.com/question/24863332</a></li>
</ul>

<p>什么是 AOP：</p>

<blockquote>
<p>面向切面编程（AOP是Aspect Oriented Program的首字母缩写） ，我们知道，面向对象的特点是继承、多态和封装。而封装就要求将功能分散到不同的对象中去，这在软件设计中往往称为职责分配。实际上也就是说，让不同的类设计不同的方法。这样代码就分散到一个个的类中去了。这样做的好处是降低了代码的复杂程度，使类可重用。<br/><br/>
但是人们也发现，在分散代码的同时，也增加了代码的重复性。什么意思呢？比如说，我们在两个类中，可能都需要在每个方法中做日志。按面向对象的设计方法，我们就必须在两个类的方法中都加入日志的内容。也许他们是完全相同的，但就是因为面向对象的设计让类与类之间无法联系，而不能将这些重复的代码统一起来。<br/><br/>
也许有人会说，那好办啊，我们可以将这段代码写在一个独立的类独立的方法里，然后再在这两个类中调用。但是，这样一来，这两个类跟我们上面提到的独立的类就有耦合了，它的改变会影响这两个类。那么，有没有什么办法，能让我们在需要的时候，随意地加入代码呢？<mark>这种在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</mark><br/><br/>
一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。这样看来，AOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。如果加上时间维度，AOP使OOP由原来的二维变为三维了，由平面变成立体了。从技术上来说，AOP基本上是通过代理机制实现的。<br/><br/>
AOP在编程历史上可以说是里程碑式的，对OOP编程是一种十分有益的补充。</p>
</blockquote>

<h3 id="toc_11">鸭子类型</h3>

<blockquote>
<p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。</p>
</blockquote>

<p>我们不关心对象是什么类型，到底是不是鸭子，只关心行为。</p>

<p>比如在 Python 中，有很多 file-like 的东西，StringIO/GzipFile/socket。它们有很多相同的方法，我们把它们都当做文件使用。</p>

<p>鸭子类型在动态语言中经常使用，非常灵活。使得 Python 不必像 Java 那样专门弄一堆设计模式。</p>

<h3 id="toc_12">Python 中的重载</h3>

<p><mark>Python 不支持函数重载</mark>。</p>

<p>函数重载主要是为了解决两个问题：</p>

<ul>
<li>可变参数类型</li>
<li>可变参数个数</li>
</ul>

<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数其实功能不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>

<p>对于情况 1，函数功能相同，但参数类型不同， 在 Python 中根本不需要处理，因为 Python 可以接受任何类型的参数，如果函数功能相同，那么不同的参数类型在 Python 中很可能是相同的代码，没有必要写成两个不同的函数。</p>

<p>对于情况 2，函数功能相同，但参数个数不同，Python 中处理的方式是使用缺省参数。对那些缺少的参数设定为缺省参数即可。</p>

<p>鉴于情况 1 和情况 2 Python 都有解决方案，所以就不需要重载了。</p>

<p>但是 Python 也可以实现重载的功能。</p>

<p>参考：<a href="http://www.zhihu.com/question/20053359">http://www.zhihu.com/question/20053359</a></p>

<h3 id="toc_13">新式类和旧式类</h3>

<p>详细参考：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python">http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python</a></li>
<li><a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></li>
</ul>

<h3 id="toc_14"><code>__new__</code> 和 <code>__init__</code></h3>

<ul>
<li><code>__new__</code> 是一个静态方法，而 <code>__init__</code> 是一个实例方法</li>
<li><code>__new__</code> 方法会返回一个创建的实例，而 <code>__init__</code> 什么都不返回</li>
<li>只有在 <code>__new__</code> 返回一个 cls 实例时后面的 <code>__init__</code> 才能被调用</li>
<li>当创建一个新实例时调用 <code>__new__</code>，初始化一个实例时用 <code>__init__</code></li>
</ul>

<p>参考：<a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init">http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init</a></p>

<h3 id="toc_15">单例模式</h3>

<p>Important！</p>

<h4 id="toc_16">什么是单例模式</h4>

<p>单例模式，也叫单子模式，是一种常用的软件设计模式。<mark>在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。</mark>比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>

<p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>

<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>

<h4 id="toc_17">1. 使用 <code>__new__</code> 方法</h4>

<pre><code class="language-python">class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, &#39;_instance&#39;):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1
</code></pre>

<h4 id="toc_18">2. 共享属性</h4>

<p>创建实例时把所有实例的 <code>__dict__</code> 指向同一个字典，这样它们具有相同的属性和方法。</p>

<pre><code class="language-python">class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1
</code></pre>

<h4 id="toc_19">3. 装饰器版本</h4>

<pre><code class="language-python">def singleton(cls, *args, **kw):
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance

@singleton
class MyClass:
  ...
</code></pre>

<h4 id="toc_20">4. import 方法</h4>

<pre><code class="language-python"># mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()

# to use
from mysingleton import my_singleton

my_singleton.foo()
</code></pre>

<p>作为 Python 的模块是天然的单例方法。</p>

<h3 id="toc_21">Python 中的作用域</h3>

<p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>

<p>当 Python 遇到一个变量的话它会按照如下顺序进行搜索：</p>

<p>本地作用域（Local） -&gt; 当前作用域没嵌入的作用域（Enclosing locals） -&gt; 全局/模块作用域（Global） -&gt; 内置作用域（Built-in）</p>

<h3 id="toc_22">GIL 线程全局锁</h3>

<p>线程全局锁（Global Interpreter Lock），即 Python 为了保证线程安全而采取的独立线程运行的机制，说白了就是一个核只能在同一时间运行一个线程。</p>

<p>解决办法就是多进程和下面的协程（协程也只是单 CPU，但能减小切换代价提升性能）。</p>

<p>参考：<a href="http://www.oschina.net/translate/pythons-hardest-problem">http://www.oschina.net/translate/pythons-hardest-problem</a></p>

<h3 id="toc_23">协程</h3>

<p>待补充</p>

<h3 id="toc_24">闭包</h3>

<p>闭包（Closure）是函数式编程中的重要语法结构。</p>

<p><mark>当一个内嵌函数引用其外部作用域的变量，我们就会得到一个闭包。</mark> 创建一个闭包必须满足以下几点：</p>

<ul>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ul>

<h3 id="toc_25">lambda 函数</h3>

<p>Python 中的 lambda 函数即匿名函数。</p>

<p>参考：<a href="https://www.zhihu.com/question/20125256">https://www.zhihu.com/question/20125256</a></p>

<h3 id="toc_26">Python 函数式编程</h3>

<p>详细参考：<a href="http://coolshell.cn/articles/10822.html">http://coolshell.cn/articles/10822.html</a></p>

<h3 id="toc_27">Python 里的拷贝</h3>

<p>引用和 <code>copy()</code>, <code>deepcopy()</code> 的区别：</p>

<pre><code class="language-python">import copy
a = [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append(&#39;c&#39;)  #修改对象a中的[&#39;a&#39;, &#39;b&#39;]数组对象

print &#39;a = &#39;, a
print &#39;b = &#39;, b
print &#39;c = &#39;, c
print &#39;d = &#39;, d

输出结果：
a =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5]
b =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], 5]
c =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]]
d =  [1, 2, 3, 4, [&#39;a&#39;, &#39;b&#39;]]
</code></pre>

<h3 id="toc_28">Python 垃圾回收机制</h3>

<p>Python GC 主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用基础上，通过「标记-清除」（mark and sweep）解决容器对象可能产生的循环引用问题，通过「分代回收」（generation collection）以空间换时间的方法提高垃圾回收效率。</p>

<h4 id="toc_29">1. 引用计数</h4>

<p>PyObject 是每个对象必有的内容，其中，<code>ob_refcnt</code> 就是作为引用计数。当一个对象有新的引用时，它的 <code>ob_refcnt</code> 就会增加，当引用它的对象呗删除，它的 <code>ob_refcnt</code> 就会减少。引用计数为 0 时，该对象的生命就结束了。</p>

<p>优点：</p>

<ul>
<li>简单</li>
<li>实时性</li>
</ul>

<p>缺点：</p>

<ul>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ul>

<h4 id="toc_30">2. 「标记-清除」机制</h4>

<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为结点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>

<h4 id="toc_31">3. 分代技术</h4>

<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个「代」，垃圾收集频率随着「代」存货时间的增大而减小，存货时间通常利用经过几次垃圾回收来度量。</p>

<p>Python 默认定义了三代对象集合，索引数越大，对象存货时间越长。</p>

<p>举例：当某些内存块 M 经过了 3 此垃圾收集的清洗之后还存活时，我们就将内存块 M 划分到一个集合 A 中去，而新分配的内存都划分到集合 B 中去。当垃圾收集开始工作时，大多数情况都只对集合 B 进行垃圾回收，而对集合 A 进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存减少了，效率自然就提高了。在这个过程中，集合 B 中的某些内存块由于存货时间长而会被转移到集合 A 中，当然，集合 A 中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代机制而被延迟。</p>

<h3 id="toc_32">Python 中 list 的实现</h3>

<p>详细参考：<a href="http://www.jianshu.com/p/J4U6rR">Python 中 List 的实现</a></p>

<h3 id="toc_33">Python 的 is</h3>

<p><code>is</code> 是对比地址，<code>==</code> 是对比值</p>

<h3 id="toc_34">read/readline/readlines</h3>

<ul>
<li>read 读取整个文件</li>
<li>readline 读取下一行，使用生成器的方式</li>
<li>readlines 读取整个文件到一个迭代器以供我们遍历</li>
</ul>

<h3 id="toc_35">Python 2 和 3 的区别</h3>

<p>详细参考：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/">http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/</a></p>

<h2 id="toc_36">操作系统</h2>

<h3 id="toc_37">select、poll 和 epoll</h3>

<p>待补充。</p>

<h3 id="toc_38">调度算法</h3>

<ol>
<li>先来先服务（FCFS, First Come First Server）</li>
<li>短作业优先（SJF, Shortest Job First）</li>
<li>最高优先权调度（Priority Scheduling）</li>
<li>时间片轮转（RR, Round Robin）</li>
<li>多级反馈队列调度（multilevel feedback queue scheduling）</li>
</ol>

<p>实时调度算法：</p>

<ol>
<li>最早截止时间优先 EDF</li>
<li>最低松弛度优先 LLF</li>
</ol>

<h3 id="toc_39">死锁</h3>

<p>原因：</p>

<ol>
<li>竞争资源</li>
<li>程序推进顺序不当</li>
</ol>

<p>必要条件：</p>

<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>

<p>处理死锁的基本方法：</p>

<ol>
<li>预防死锁</li>
<li>避免死锁（银行家算法）</li>
<li>检测死锁（资源分配图）</li>
<li>解除死锁

<ul>
<li>剥夺资源</li>
<li>撤销进程</li>
</ul></li>
</ol>

<h3 id="toc_40">程序的编译和链接</h3>

<p>待补充。</p>

<h3 id="toc_41">静态链接和动态链接</h3>

<p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来，静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库。</p>

<p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算（被调用的那部分）动态代码的逻辑地址，然后等到某个时候，程序有需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以这种方式使程序初始化的时间较短，但运行期间的性能比不上静态链接的程序。</p>

<h3 id="toc_42">虚拟内存技术</h3>

<p>虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储系统。</p>

<h3 id="toc_43">分页和分段</h3>

<p>分页：用户程序的地址空间被划分为若干个固定大小的区域，称为「页」，相应的，内存空间分成若干个物理块，页和块的大小相等，可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>

<p>分段：将用户程序的地址空间分成若干个大小不等的「段」，每段可以定义一组相对完整的逻辑信息。存储分配时，以段位单位，段与段在内存中可以不相邻接，也实现了离散分配。</p>

<p>分页与分段的主要区别：</p>

<ol>
<li>页的信息是物理单位，分页是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要，段是信息的逻辑单位，它含有一组意义相对完整的信息，分段的目的是为了更好得实现共享，满足用户的需要。</li>
<li>页的大小固定，由系统决定，将逻辑地址划分为页号和页内地址是由及其硬件实现的。而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分。</li>
<li>分页的作业地址空间是一维的，分段的地址空间是二维的。</li>
</ol>

<h3 id="toc_44">页面置换算法</h3>

<ol>
<li>最先置换算法 OPT：不可能实现</li>
<li>先进先出 FIFO</li>
<li>最近最久未使用算法 LRU：最近一段时间里最久没有使用过的页面予以置换</li>
<li>clock 算法</li>
</ol>

<h3 id="toc_45">边缘触发和水平触发</h3>

<p>边缘触发是指每当状态发生变化时发生一个 IO 事件，条件触发是只要满足条件就发生一个 IO 事件。</p>

<h2 id="toc_46">数据库</h2>

<h3 id="toc_47">事务</h3>

<p>数据库事务（Database Transaction），是指作为单个逻辑工作单元执行的一系列操作，要么完全得执行，要么完全得不执行。</p>

<h3 id="toc_48">数据库索引</h3>

<p>参考资料：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>

<h3 id="toc_49">Redis 原理</h3>

<p>待补充。</p>

<h3 id="toc_50">乐观锁和悲观锁</h3>

<ul>
<li>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</li>
<li>乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性</li>
</ul>

<h2 id="toc_51">网络</h2>

<h3 id="toc_52">ARP 协议</h3>

<p>地址解析协议（Address Resolution Protocol），其基本功能为透过目标设备的 IP 地址，查询目标的 Mac 地址，以保证通信的顺利进行。它是 IPv4 网络层必不可少的协议，不过在 IPv6 中已不再适用，并被邻居发现协议（NDP）替代。</p>

<h3 id="toc_53">POST 和 GET</h3>

<p>参考阅读：</p>

<ul>
<li><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html">GET和POST有什么区别？及为什么网上的多数答案都是错的</a></li>
<li><a href="https://www.zhihu.com/question/31640769?rf=37401322">post 相比get 有很多优点，为什么现在的HTTP通信中大多数请求还是使用get？</a></li>
</ul>

<h3 id="toc_54">Cookie 和 Session</h3>

<table>
<thead>
<tr>
<th></th>
<th>Cookie</th>
<th>Session</th>
</tr>
</thead>

<tbody>
<tr>
<td>存储位置</td>
<td>客户端</td>
<td>服务器端</td>
</tr>
<tr>
<td>目的</td>
<td>跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td>跟踪会话</td>
</tr>
<tr>
<td>安全性</td>
<td>不安全</td>
<td>安全</td>
</tr>
</tbody>
</table>

<p>Session 技术是要使用到 Cookie 的，之所以出现 Session 技术，主要是为了安全。</p>

<h3 id="toc_55">Apache 和 Nginx 的区别</h3>

<p>Nginx 相对于 Apache 的优点：</p>

<ul>
<li>轻量级：同样的 Web 服务，比 Apache 占用更少的内存及资源</li>
<li>抗并发：Nginx 处理请求时异步非阻塞的，支持更多的并发连接，而 Apache 则是阻塞型的，在高并发下 Nginx 能保持低资源低消耗高性能</li>
<li>配置简洁</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>

<p>Apache 相对 Nginx 的优点：</p>

<ul>
<li>rewrite 比 Nginx 的 rewrite 强大</li>
<li>模块很多，基本可以想到的都能找到</li>
<li>bug 少，Nginx bug 多</li>
<li>很稳定</li>
</ul>

<h3 id="toc_56">网站用户密码保存</h3>

<ul>
<li>明文保存</li>
<li>明文 hash 后保存，如 md5</li>
<li>MD5 + salt 方式，这个 salt 可以随机</li>
<li>知乎使用了 Bcrypy 加密（待考）</li>
</ul>

<h3 id="toc_57">HTTP 和 HTTPS</h3>

<p>待补充。</p>

<h3 id="toc_58">XSRF 和 XSS</h3>

<p>参考 <a href="14889309726832.html">计算机网络</a></p>

<h3 id="toc_59">CGI 和 WSGI</h3>

<p>CGI 是通用网关接口，是连接 web 服务器和应用程序的接口，用户通过 CGI 来获取动态数据或文件等。CGI 程序是一个独立的程序，它可以用几乎所有语言来写。</p>

<p>WSGI（Web Server Gateway Interface），是 Python 应用程序或 Web 框架与服务器之间的一种接口，WSGI 的其中一个目的就是让用户可以用统一的语言（Python）来编写前后端。</p>

<h3 id="toc_60">中间人攻击</h3>

<p>中间人攻击（Man in the middle attack, MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为它们正在通过一个私密的连接与对方直接对话，但事实上整个对话都被攻击者完全控制。</p>

<h3 id="toc_61">CK10 问题</h3>

<p>指的是服务器同时支持成千上万个客户端的问题。</p>

<p>参考阅读：<a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></p>

<h3 id="toc_62">Ajax</h3>

<p>Ajax（Asynchronous JavaScript and Xml，异步的 JavaScript 和 XML），是指在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p>

		</div>
	</article>
	<div class="share-comment">
	<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://tisogas-wiki.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>